{
  "language": "Solidity",
  "sources": {
    "@nilfoundation/evm-placeholder-verification/contracts/algebra/field.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\n/**\n * @title Bn254 elliptic curve crypto\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\n */\nlibrary field {\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\n    // it is cheaper than using the pow precompile\n    function pow_small(uint256 base, uint256 exponent, uint256 modulus)\n    internal pure returns (uint256 result) {\n        result = 1;\n        assembly {\n            for {let count := 1}\n            lt(count, add(exponent, 0x01))\n            {count := shl(1, count)} {\n                if and(exponent, count) {\n                    result := mulmod(result, base, modulus)\n                }\n                base := mulmod(base, base, modulus)\n            }\n        }\n    }\n\n    /// @dev Modular inverse of a (mod p) using euclid.\n    /// 'a' and 'p' must be co-prime.\n    /// @param a The number.\n    /// @param p The mmodulus.\n    /// @return x such that ax = 1 (mod p)\n    function invmod(uint256 a, uint256 p)\n    internal pure returns (uint256) {\n        require(a != 0 && a != p && p != 0);\n        if (a > p)\n            a = a % p;\n        int256 t1;\n        int256 t2 = 1;\n        uint256 r1 = p;\n        uint256 r2 = a;\n        uint256 q;\n        while (r2 != 0) {\n            q = r1 / r2;\n            (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\n        }\n        if (t1 < 0)\n            return (p - uint256(- t1));\n        return uint256(t1);\n    }\n\n    function fadd(uint256 a, uint256 b, uint256 modulus)\n    internal pure returns (uint256 result) {\n        assembly {\n            result := addmod(a, b, modulus)\n        }\n    }\n\n    function fsub(uint256 a, uint256 b, uint256 modulus)\n    internal pure returns (uint256 result) {\n        assembly {\n            result := addmod(a, sub(modulus, b), modulus)\n        }\n    }\n\n    function fmul(uint256 a, uint256 b, uint256 modulus)\n    internal pure returns (uint256 result) {\n        assembly {\n            result := mulmod(a, b, modulus)\n        }\n    }\n\n    function fdiv(uint256 a, uint256 b, uint256 modulus)\n    internal pure returns (uint256 result) {\n        uint256 b_inv = invmod(b, modulus);\n        assembly {\n            result := mulmod(a, b_inv, modulus)\n        }\n    }\n\n    // See https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\n    function log2(uint256 x)\n    internal pure returns (uint256 y){\n        assembly {\n            let arg := x\n            x := sub(x, 1)\n            x := or(x, div(x, 0x02))\n            x := or(x, div(x, 0x04))\n            x := or(x, div(x, 0x10))\n            x := or(x, div(x, 0x100))\n            x := or(x, div(x, 0x10000))\n            x := or(x, div(x, 0x100000000))\n            x := or(x, div(x, 0x10000000000000000))\n            x := or(x, div(x, 0x100000000000000000000000000000000))\n            x := add(x, 1)\n            let m := mload(0x40)\n            mstore(m, 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\n            mstore(add(m, 0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\n            mstore(add(m, 0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\n            mstore(add(m, 0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\n            mstore(add(m, 0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\n            mstore(add(m, 0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\n            mstore(add(m, 0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\n            mstore(add(m, 0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\n            mstore(0x40, add(m, 0x100))\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\n            let a := div(mul(x, magic), shift)\n            y := div(mload(add(m, sub(255, a))), shift)\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\n        }\n    }\n\n    function expmod_static(uint256 base, uint256 exponent, uint256 modulus)\n    internal view returns (uint256 res) {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base.\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\n            mstore(add(p, 0x60), base) // Base.\n            mstore(add(p, 0x80), exponent) // Exponent.\n            mstore(add(p, 0xa0), modulus) // Modulus.\n        // Call modexp precompile.\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse_static(uint256 val, uint256 modulus)\n    internal view returns (uint256 res) {\n        //        return expmod_static(val, modulus - 2, modulus); // code below similar to this call\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base.\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\n            mstore(add(p, 0x60), val) // Base.\n            mstore(add(p, 0x80), sub(modulus, 0x02)) // Exponent.\n            mstore(add(p, 0xa0), modulus) // Modulus.\n        // Call modexp precompile.\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function double(uint256 val, uint256 modulus) internal pure returns (uint256 result) {\n        assembly {\n            result := mulmod(2, val, modulus)\n        }\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/algebra/polynomial.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\n\npragma solidity >=0.8.4;\n\nimport \"./field.sol\";\nimport \"../basic_marshalling.sol\";\n\n\n/**\n * @title Turbo Plonk polynomial evaluation\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\n *\n * Expected to be inherited by `TurboPlonk.sol`\n */\nlibrary polynomial {\n    uint256 constant LENGTH_OCTETS = 8;\n\n    function multiply_poly_on_coeff(uint256[] memory coeffs, uint256 mul, uint256 modulus)\n    internal pure{\n        for(uint256 i = 0; i < coeffs.length; i++){\n            coeffs[i] = mulmod(coeffs[i], mul, modulus);\n        }\n    }\n\n    /*\n      Computes the evaluation of a polynomial f(x) = sum(a_i * x^i) on the given point.\n      The coefficients of the polynomial are given in\n        a_0 = coefsStart[0], ..., a_{n-1} = coefsStart[n - 1]\n      where n = nCoeffs = friLastLayerDegBound. Note that coefsStart is not actually an array but\n      a direct pointer.\n      The function requires that n is divisible by 8.\n    */\n    function evaluate(uint256[] memory coeffs, uint256 point, uint256 modulus)\n    internal pure returns (uint256) {\n        uint256 result;\n        assembly {\n            let cur_coefs := add(coeffs, mul(mload(coeffs), 0x20))\n            for { } gt(cur_coefs, coeffs) {} {\n                result := addmod(mulmod(result, point, modulus),\n                                mload(cur_coefs), // (i - 1) * 32\n                                modulus)\n                cur_coefs := sub(cur_coefs, 0x20)\n            }\n        }\n        return result;\n    }\n\n    function evaluate_by_ptr(bytes calldata blob, uint256 offset, uint256 len, uint256 point, uint256 modulus)\n    internal pure returns (uint256) {\n        uint256 result;\n        for (uint256 i = len; i > 0;) {\n            assembly {\n                result := addmod(mulmod(result, point, modulus),\n                                 calldataload(add(add(blob.offset, offset), shl(0x05, sub(i, 0x01)))), // (i - 1) * 32\n                                 modulus)\n            }\n            unchecked{ i--; }\n        }\n//        assembly {\n//            let i := sub(add(blob.offset, add(offset, mul(len, 0x20))), 0x20)\n//            let coeff := sub(add(blob.offset, offset), 0x20)\n//            for { } gt(coefsPtr, coeff) {} {\n//                result := addmod(mulmod(result, point, modulus), calldataload(coefsPtr), modulus)\n//                coefsPtr := sub(coefsPtr, 0x20)\n//            }\n//        }\n        return result;\n    }\n\n    function add_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\n    internal pure returns (uint256[] memory result) {\n        if (a.length < b.length) {\n            result = new uint256[](b.length);\n            assembly {\n                let i := 0\n                for {} lt(i, mul(mload(a), 0x20)) {\n                    i := add(i, 0x20)\n                } {\n                    mstore(\n                    add(add(result, 0x20), i),\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\n                    )\n                }\n                for {} lt(i, mul(mload(b), 0x20)) {\n                    i := add(i, 0x20)\n                } {\n                    mstore(\n                    add(add(result, 0x20), i),\n                    mload(add(b, add(0x20, i)))\n                    )\n                }\n            }\n        } else {\n            result = new uint256[](a.length);\n            assembly {\n                let i := 0\n                for {} lt(i, mul(mload(b), 0x20)) {\n                    i := add(i, 0x20)\n                } {\n                    mstore(\n                    add(add(result, 0x20), i),\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\n                    )\n                }\n                for {} lt(i, mul(mload(a), 0x20)) {\n                    i := add(i, 0x20)\n                } {\n                    mstore(\n                    add(add(result, 0x20), i),\n                    mload(add(a, add(0x20, i)))\n                    )\n                }\n            }\n        }\n    }\n\n    function mul_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\n    internal pure returns (uint256[] memory result) {\n        result = new uint256[](a.length + b.length - 1);\n        for (uint256 i = 0; i < b.length;) {\n            for (uint256 j = 0; j < a.length;) {\n                assembly {\n                    mstore(add(add(result, 0x20), mul(add(j, i), 0x20)),\n                           addmod(mload(add(add(result, 0x20), mul(add(j, i), 0x20))),\n                                   mulmod(mload(add(add(a, 0x20), mul(j, 0x20))),\n                                          mload(add(add(b, 0x20), mul(i, 0x20))), modulus),\n                                   modulus)\n                    )\n                }\n                unchecked{ j++; }\n            }\n            unchecked{ i++; }\n        }\n        return result;\n    }\n\n    function lagrange_interpolation(\n        uint256[] memory xs,\n        uint256[] memory fxs,\n        uint256 modulus\n    ) internal pure returns (uint256[] memory result) {\n        require(xs.length == fxs.length);\n        uint256 len = fxs.length;\n        for (uint256 i = 0; i < len;) {\n            uint256[] memory thisPoly = new uint256[](1);\n            thisPoly[0] = 1;\n            for (uint256 j = 0; j < len;) {\n                if (i == j) {\n                    continue;\n                }\n                uint256 denominator = field.fsub(xs[i], xs[j], modulus);\n                uint256[] memory thisTerm = new uint256[](2);\n                thisTerm[0] = field.fdiv(modulus - xs[j], denominator, modulus);\n                thisTerm[1] = field.fdiv(uint256(1), denominator, modulus);\n                thisPoly = mul_poly(thisPoly, thisTerm, modulus);\n                unchecked{ j++; }\n            }\n            if (fxs.length + 1 >= i) {\n                uint256[] memory multiple = new uint256[](1);\n                multiple[0] = fxs[i];\n                thisPoly = mul_poly(thisPoly, multiple, modulus);\n            }\n            result = add_poly(result, thisPoly, modulus);\n            unchecked { i++; }\n        }\n    }\n\n    function interpolate_evaluate_by_2_points_neg_x(uint256 x, uint256 dblXInv, uint256 fX, uint256 fMinusX,\n                                                    uint256 evalPoint, uint256 modulus\n    ) internal pure returns (uint256 result) {\n        assembly {\n            result := addmod(\n                mulmod(\n                    mulmod(\n                        addmod(fX, sub(modulus, fMinusX), modulus),\n                        dblXInv,\n                        modulus\n                    ),\n                    addmod(evalPoint, sub(modulus, x), modulus),\n                    modulus\n                ),\n                fX,\n                modulus\n            )\n        }\n    }\n\n    function interpolate_evaluate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\n    internal view returns (uint256 result) {\n        require(x.length == 2, \"x length is not equal to 2\");\n        require(fx.length == 2, \"fx length is not equal to 2\");\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\n        assembly {\n            let y2_minus_y1 := addmod(\n                mload(add(fx, 0x40)),\n                sub(modulus, mload(add(fx, 0x20))),\n                modulus\n            )\n            let x3_minus_x1 := addmod(\n                eval_point,\n                sub(modulus, mload(add(x, 0x20))),\n                modulus\n            )\n            result := addmod(\n                mulmod(\n                    mulmod(y2_minus_y1, x2_minus_x1_inv, modulus),\n                    x3_minus_x1,\n                    modulus\n                ),\n                mload(add(fx, 0x20)),\n                modulus\n            )\n        }\n    }\n\n    function interpolate_evaluate(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\n    internal view returns (uint256) {\n        if (x.length == 1 && fx.length == 1) {\n            return fx[0];\n        }\n        if (x.length == 2) {\n            return interpolate_evaluate_by_2_points(x, fx, eval_point, modulus);\n        }\n        require(false, \"unsupported number of points for interpolation\");\n        return 0;\n    }\n\n    function interpolate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 modulus)\n    internal view returns (uint256[] memory result) {\n        require(x.length == 2, \"x length is not equal to 2\");\n        require(fx.length == 2, \"fx length is not equal to 2\");\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\n        result = new uint256[](2);\n        assembly {\n            let y2_minus_y1 := addmod(mload(add(fx, 0x40)), sub(modulus, mload(add(fx, 0x20))), modulus)\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\n            let a_mul_x1_neg := sub(modulus, mulmod(a, mload(add(x, 0x20)), modulus))\n            let b := addmod(mload(add(fx, 0x20)), a_mul_x1_neg, modulus)\n            mstore(add(result, 0x20), b)\n            mstore(add(result, 0x40), a)\n        }\n    }\n\n    function interpolate(uint256[] memory x, uint256[] memory fx, uint256 modulus)\n    internal view returns (uint256[] memory result) {\n        if (x.length == 1 && fx.length == 1) {\n            result = new uint256[](1);\n            result[0] = fx[0];\n            return result;\n        } else if (x.length == 2) {\n            result = interpolate_by_2_points(x, fx, modulus);\n            return result;\n        } else {\n            require(false, \"unsupported number of points for interpolation\");\n        }\n    }\n\n    function interpolate_by_2_points(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\n    internal view returns (uint256[] memory result) {\n        require(x.length == 2, \"x length is not equal to 2\");\n        require(basic_marshalling.get_length(blob, fx_offset) == 2, \"fx length is not equal to 2\");\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\n        result = new uint256[](2);\n\n        assembly {\n            let y2_minus_y1 := addmod(\n                calldataload(\n                    add(blob.offset, add(add(fx_offset, LENGTH_OCTETS), 0x20))\n                ),\n                sub(\n                    modulus,\n                    calldataload(\n                        add(blob.offset, add(fx_offset, LENGTH_OCTETS))\n                    )\n                ),\n                modulus\n            )\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\n            let a_mul_x1_neg := sub(\n                modulus,\n                mulmod(a, mload(add(x, 0x20)), modulus)\n            )\n            let b := addmod(\n                calldataload(add(blob.offset, add(fx_offset, LENGTH_OCTETS))),\n                a_mul_x1_neg,\n                modulus\n            )\n            mstore(add(result, 0x20), b)\n            mstore(add(result, 0x40), a)\n        }\n    }\n\n    function interpolate(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\n    internal view returns (uint256[] memory result) {\n        if (x.length == 1 && basic_marshalling.get_length(blob, fx_offset) == 1) {\n            result = new uint256[](1);\n            result[0] = basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0);\n            return result;\n        } else if (x.length == 2) {\n            result = interpolate_by_2_points(blob, x, fx_offset, modulus);\n            return result;\n        } else if (x.length == 3) {\n            uint256 y0 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0), field.fmul(field.fsub(x[0], x[1],modulus), field.fsub(x[0], x[2],modulus), modulus), modulus);\n            uint256 y1 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 1), field.fmul(field.fsub(x[1], x[0],modulus), field.fsub(x[1], x[2],modulus), modulus), modulus);\n            uint256 y2 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 2), field.fmul(field.fsub(x[2], x[0],modulus), field.fsub(x[2], x[1],modulus), modulus), modulus);\n\n            result = new uint256[](3);\n            assembly {\n                let x1 := mulmod(y0, mulmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus), modulus)\n                let x2 := mulmod(y1, mulmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus), modulus)\n                let x3 := mulmod(y2, mulmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus), modulus)\n                mstore(add(result, 0x20), addmod(addmod(x1, x2, modulus), x3, modulus))\n\n                x1 := mulmod(y0, sub(modulus, addmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus)), modulus)\n                x2 := mulmod(y1, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus)), modulus)\n                x3 := mulmod(y2, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus)), modulus)\n                mstore(add(result, 0x40), addmod(addmod(x1, x2, modulus), x3, modulus))\n                mstore(add(result, 0x60), addmod(addmod(y0, y1, modulus), y2, modulus))\n            }\n            return result;\n        }\n        require(false, \"unsupported number of points for interpolation\");\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nlibrary basic_marshalling {\n    uint256 constant LENGTH_OCTETS = 8;\n    // 256 - 8 * LENGTH_OCTETS\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\n    uint256 constant LENGTH_OCTETS_ADD_32 = 40;\n\n    //================================================================================================================\n    // Bounds non-checking functions\n    //================================================================================================================\n    // TODO: general case\n    function skip_octet_vector_32_be(uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\n    }\n\n    function get_octet_vector_32_be(bytes calldata blob, uint256 offset)\n    internal pure returns (bytes32 result) {\n        assembly {\n            result := mload(add(add(blob.offset, offset), LENGTH_OCTETS))\n        }\n    }\n\n    // TODO: general case\n    function skip_vector_of_octet_vectors_32_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        assembly {\n            result_offset := add(\n                result_offset,\n                mul(\n                    LENGTH_OCTETS_ADD_32,\n                    shr(\n                        LENGTH_RESTORING_SHIFT,\n                        calldataload(add(blob.offset, offset))\n                    )\n                )\n            )\n        }\n    }\n\n    function skip_uint256_be(uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + 32; }\n    }\n\n    function skip_vector_of_uint256_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        assembly {\n            result_offset := add(\n                add(\n                    offset,\n                    mul(\n                        0x20,\n                        shr(\n                            LENGTH_RESTORING_SHIFT,\n                            calldataload(add(blob.offset, offset))\n                        )\n                    )\n                ),\n                LENGTH_OCTETS\n            )\n        }\n    }\n\n    function skip_vector_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        uint256 n;\n        assembly {\n            n := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(add(blob.offset, offset))\n            )\n        }\n        for (uint256 i = 0; i < n;) {\n            result_offset = skip_vector_of_uint256_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n    function skip_v_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        uint256 n = get_length(blob, offset);\n        result_offset = skip_length(offset);\n        for (uint256 i = 0; i < n;) {\n            result_offset = skip_vector_of_vectors_of_uint256_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n    \n    function skip_vv_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        uint256 n = get_length(blob, offset);\n        result_offset = skip_length(offset);\n        for (uint256 i = 0; i < n;) {\n            result_offset = skip_v_of_vectors_of_vectors_of_uint256_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n\n    function skip_length(uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n    }\n\n    function get_length(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_length){\n        assembly {\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\n        }\n    }\n\n    function get_skip_length(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_length, uint256 result_offset){\n        assembly {\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\n        }\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n    }\n\n    function get_i_uint256_from_vector(bytes calldata blob, uint256 offset, uint256 i)\n    internal pure returns (uint256 result) {\n        assembly {\n            result := calldataload(add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20))))\n        }\n    }\n\n    function get_i_bytes32_from_vector(bytes calldata blob, uint256 offset, uint256 i)\n    internal pure returns (bytes32 result) {\n        assembly {\n            result := calldataload(\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\n            )\n        }\n    }\n\n    function get_i_uint256_ptr_from_vector(bytes calldata blob, uint256 offset, uint256 i)\n    internal pure returns (uint256 result_ptr) {\n        assembly {\n            result_ptr := add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\n        }\n    }\n\n    function get_i_j_uint256_from_vector_of_vectors_true(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\n    internal pure returns (uint256 result) {\n        for (uint256 _i = 0; _i < i;) {\n            offset = skip_vector_of_uint256_be(blob, offset);\n        unchecked{ _i++; }\n        }\n        result = get_i_uint256_from_vector(blob, offset, j);\n    }\n\n    function get_i_j_uint256_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\n    internal pure returns (uint256 result) {\n        offset = skip_length(offset);\n        for (uint256 _i = 0; _i < i;) {\n            offset = skip_vector_of_uint256_be(blob, offset);\n            unchecked{ _i++; }\n        }\n        result = get_i_uint256_from_vector(blob, offset, j);\n    }\n\n    function get_i_j_uint256_ptr_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\n    internal pure returns (uint256 result_ptr) {\n        offset = skip_length(offset);\n        for (uint256 _i = 0; _i < i;) {\n            offset = skip_vector_of_uint256_be(blob, offset);\n            unchecked{ _i++; }\n        }\n        result_ptr = get_i_uint256_ptr_from_vector(blob, offset, j);\n    }\n\n    function get_uint256_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result) {\n        assembly {\n            result := calldataload(add(blob.offset, offset))\n        }\n    }\n\n    //================================================================================================================\n    // Bounds checking functions\n    //================================================================================================================\n    // TODO: general case\n    function skip_octet_vector_32_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\n        require(result_offset <= blob.length);\n    }\n\n    // TODO: general case\n    function skip_vector_of_octet_vectors_32_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        require(result_offset <= blob.length);\n        assembly {\n            result_offset := add(\n                result_offset,\n                mul(\n                    LENGTH_OCTETS_ADD_32,\n                    shr(\n                        LENGTH_RESTORING_SHIFT,\n                        calldataload(add(blob.offset, offset))\n                    )\n                )\n            )\n        }\n        require(result_offset <= blob.length);\n    }\n\n    function skip_uint256_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + 32; }\n        require(result_offset <= blob.length);\n    }\n\n    function skip_vector_of_uint256_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        assembly {\n            result_offset := add(\n                add(\n                    offset,\n                    mul(\n                        0x20,\n                        shr(\n                            LENGTH_RESTORING_SHIFT,\n                            calldataload(add(blob.offset, offset))\n                        )\n                    )\n                ),\n                LENGTH_OCTETS\n            )\n        }\n        require(result_offset <= blob.length);\n    }\n\n    function skip_vector_of_vectors_of_uint256_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        require(result_offset <= blob.length);\n        uint256 n;\n        assembly {\n            n := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(add(blob.offset, offset))\n            )\n        }\n        for (uint256 i = 0; i < n;) {\n            result_offset = skip_vector_of_uint256_be_check(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n    function skip_length_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset){\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        require(result_offset < blob.length);\n    }\n\n    function get_length_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_length){\n        require(offset + LENGTH_OCTETS <= blob.length);\n        assembly {\n            result_length := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(add(blob.offset, offset))\n            )\n        }\n    }\n\n    function get_skip_length_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_length, uint256 result_offset) {\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\n        require(result_offset <= blob.length);\n        assembly {\n            result_length := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(add(blob.offset, offset))\n            )\n        }\n    }\n\n    function get_i_uint256_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\n    internal pure returns (uint256 result) {\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\n        assembly {\n            result := calldataload(\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\n            )\n        }\n    }\n\n    function get_i_uint256_ptr_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\n    internal pure returns (uint256 result_ptr) {\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\n        assembly {\n            result_ptr := add(\n                blob.offset,\n                add(add(offset, LENGTH_OCTETS), mul(i, 0x20))\n            )\n        }\n    }\n\n    function get_i_j_uint256_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\n    internal pure returns (uint256 result) {\n        offset = skip_length_check(blob, offset);\n        for (uint256 _i = 0; _i < i;) {\n            offset = skip_vector_of_uint256_be_check(blob, offset);\n            unchecked{ _i++; }\n        }\n        result = get_i_uint256_from_vector_check(blob, offset, j);\n    }\n\n    function get_i_j_uint256_ptr_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\n    internal pure returns (uint256 result_ptr) {\n        offset = skip_length_check(blob, offset);\n        for (uint256 _i = 0; _i < i;) {\n            offset = skip_vector_of_uint256_be_check(blob, offset);\n            unchecked{ _i++; }\n        }\n        result_ptr = get_i_uint256_ptr_from_vector_check(blob, offset, j);\n    }\n\n    function get_uint256_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result){\n        require(offset + 0x20 <= blob.length);\n        assembly {\n            result := calldataload(add(blob.offset, offset))\n        }\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_fri_verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n// Copyright (c) 2022 Elena Tatuzova <e.tatuzova@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\nimport \"../containers/merkle_verifier.sol\";\nimport \"../cryptography/transcript.sol\";\nimport \"../algebra/polynomial.sol\";\nimport \"../basic_marshalling.sol\";\n\n\nlibrary batched_fri_verifier {\n    uint256 constant FRI_PARAMS_COEFFS_OFFSET = 0x280;\n\n    uint256 constant S1_OFFSET = 0x00;                                      \n    uint256 constant X_OFFSET = 0x20;                                      \n    uint256 constant ALPHA_OFFSET = 0x40;                                   // alpha challenge\n    uint256 constant COEFFS_OFFSET = 0x60;\n    uint256 constant Y_OFFSET = 0x80;\n    uint256 constant COLINEAR_OFFSET = 0xa0;                                // colinear_value_offset\n    uint256 constant C1_OFFSET = 0xc0;                                      // coefficient1_offset\n    uint256 constant C2_OFFSET = 0xe0;                                      // coefficient2_offset\n    uint256 constant INTERPOLANT_OFFSET = 0x100;\n    uint256 constant PREV_COEFFS_LEN_OFFSET = 0x120;\n\n    uint256 constant m = 2;\n\n    function skip_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        // fri_roots\n        uint256 value_len;\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        for (uint256 i = 0; i < value_len;) {\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\n            unchecked{ i++; }\n        }\n        // final_polynomial\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\n        // query_proofs\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        for (uint256 i = 0; i < value_len;) {\n            result_offset = skip_query_proof_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\n    internal pure returns (bool success, uint256 result_offset) {\n        success = true;\n        // fri_roots\n        uint256 value_len;\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        if( value_len != fri_params.step_list.length ){\n            success = false;\n            return(success, result_offset);\n        }\n        fri_params.fri_roots = new uint256[](value_len);\n        for (uint256 i = 0; i < value_len;) {\n            fri_params.fri_roots[i] = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(result_offset));\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\n            unchecked{ i++; }\n        }\n        // final_polynomial\n        fri_params.fri_final_poly_offset = result_offset;\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n\n        if( value_len > (( 1 << (field.log2(fri_params.max_degree + 1) - fri_params.r + 1) ) ) ){\n            success = false;\n            return(success, result_offset);\n        }\n\n        fri_params.final_polynomial = new uint256[](value_len);\n        for (uint256 i = 0; i < value_len;) {\n            fri_params.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, result_offset);\n            result_offset = basic_marshalling.skip_uint256_be(result_offset);\n            unchecked{ i++; }\n        }\n\n        // query_proofs\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        fri_params.fri_cur_query_offset = result_offset;\n        if( value_len != fri_params.lambda ) {\n            success = false;\n            return(success, result_offset);\n        }\n\n        for (uint256 i = 0; i < value_len;) {\n            (success, result_offset) = parse_query_proof_be(fri_params, blob, result_offset);\n            if(!success) return(success, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n    function skip_query_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset){\n        uint256 value_len;\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        for(uint256 i = 0; i < value_len;){\n            result_offset = skip_initial_proof_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        for(uint256 i = 0; i < value_len;){\n            result_offset = skip_round_proof_be(blob, result_offset);\n            unchecked{ i++; }\n        }\n    }\n\n    function parse_query_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\n    internal pure returns (bool success, uint256 result_offset){\n        success = true;\n        uint256 value_len;\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        if( value_len != fri_params.batches_sizes.length ){\n            success = false;\n            return( success, result_offset);\n        }\n\n        for(uint256 i = 0; i < value_len;){\n            (success, result_offset) = parse_initial_proof_be(fri_params, i, blob, result_offset);\n            if( !success ) return(success, result_offset );\n            unchecked{ i++; }\n        }\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        if( value_len != fri_params.step_list.length){\n            success = false;\n            return( success, result_offset);\n        }\n        for(uint256 i = 0; i < value_len;){\n            (success, result_offset) = parse_round_proof_be(fri_params, i, blob, result_offset);\n            if( !success ) return(success, result_offset );\n            unchecked{ i++; }\n        }\n    }\n\n    function skip_initial_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns(uint256 result_offset){\n        // p;\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\n        // polynomials num\n        result_offset = basic_marshalling.skip_length(result_offset);\n        // coset_size\n        result_offset = basic_marshalling.skip_length(result_offset);\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\n    }\n\n    function parse_initial_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\n    internal pure returns(bool success, uint256 result_offset){\n        success = true;\n        // p;\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\n        // polynomials num\n        uint256 len;\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        if( len != fri_params.batches_sizes[i] ) {\n            success = false;\n            return(success, result_offset);\n        }\n        // coset_size\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\n        if( len != (1 << fri_params.step_list[0]) ) {\n            success = false;\n            return(success, result_offset);\n        }\n        // values\n        len = basic_marshalling.get_length(blob, result_offset);\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\n        if(len != fri_params.batches_sizes[i] * (1 << fri_params.step_list[0])){\n            success = false;\n            return(success, result_offset);\n        }\n    }\n\n    function skip_round_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns(uint256 result_offset){\n        // p;\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\n        // y;\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\n    }\n\n    function parse_round_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\n    internal pure returns(bool success, uint256 result_offset){\n        success = true;\n        // p;\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\n        // y;\n        if( i < fri_params.step_list.length - 1){\n            if( basic_marshalling.get_length(blob, result_offset) != (1 << fri_params.step_list[i+1]) ){\n                success = false;\n                return(success, result_offset);\n            }\n        }else{\n            if( basic_marshalling.get_length(blob, result_offset) != 2 ){\n                success = false;\n                return( success, result_offset);\n            }\n        }\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\n    }\n\n    // Use this hack only for lpc test(!)\n    // Call this function only after fri_params is completely initialized by parse* functions.\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \n    internal pure returns(uint256[] memory roots){\n        roots = new uint256[](fri_params.batches_num);\n        uint256 offset = fri_params.fri_cur_query_offset;\n        offset = basic_marshalling.skip_length(offset);\n        for( uint256 i = 0; i < fri_params.batches_num;){\n            roots[i] = merkle_verifier.get_merkle_root_from_proof(blob, offset);\n            offset = skip_initial_proof_be(blob, offset);\n            unchecked{ i++; }\n        }\n    }\n\n    // if x_index is index of x, then paired_index is index of -x\n    function get_paired_index(uint256 x_index, uint256 domain_size)\n    internal pure returns(uint256 result ){\n        unchecked{ result = (x_index + (domain_size >> 1)) & (domain_size - 1); }\n    }\n\n    // calculate indices for coset S = {s\\in D| s^(2^fri_step) == x_next}\n    function get_folded_index(uint256 x_index, uint256 fri_step, uint256 domain_size_mod) \n    internal pure returns(uint256 result){\n        unchecked{result = x_index & (domain_size_mod >> fri_step);}\n    }\n  \n    function calculate_s(\n        types.fri_params_type memory fri_params,\n        types.fri_state_type memory local_vars) internal pure{\n\n        fri_params.s[0] = local_vars.x;\n        if( local_vars.coset_size > 1){\n            uint256 base_index = local_vars.domain_size >> 2; \n            uint256 prev_half_size = 1;\n            uint256 i = 1;\n            uint256 j;\n            local_vars.newind = fri_params.D_omegas.length - 1;\n            while( i < local_vars.coset_size ){\n                for( j = 0; j < prev_half_size;) {\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\n                    unchecked{ j++; }\n                }\n                unchecked{\n                    base_index >>=1;\n                    prev_half_size <<=1;\n                    local_vars.newind--;\n                }\n            }\n        }\n    }\n\n    function prepare_initial_leaf_data(\n        bytes calldata blob,\n        uint256 offset,\n        uint256 k,                                              // current batch index\n        types.fri_params_type memory fri_params,\n        types.fri_state_type memory local_vars\n    ) internal pure {\n        uint256 base_index;\n        uint256 prev_half_size;\n        uint256 i;\n        uint256 j;\n\n        local_vars.indices_size = 1 << (fri_params.step_list[0] - 1);\n        \n        fri_params.s_indices[0] = local_vars.x_index;\n        fri_params.s[0] = local_vars.x;\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[0], local_vars.domain_size_mod);\n\n        // Fill s and s_indices\n        if( local_vars.indices_size > 1){\n            unchecked{\n                base_index = local_vars.domain_size >> 2; \n                prev_half_size = 1;\n                i = 1;\n                local_vars.newind = fri_params.D_omegas.length - 1;\n            }\n            while( i < local_vars.indices_size ){\n                for( j = 0; j < prev_half_size;) {\n                    unchecked{\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\n                    }\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\n                    unchecked{ j++; }\n                }\n                unchecked{\n                    base_index >>=1;\n                    prev_half_size <<=1;\n                    local_vars.newind--;\n                }\n            }\n        }\n\n        // Fill correct_order_idx\n        for ( i = 0; i < local_vars.indices_size;) {\n            for(j = 0; j < local_vars.indices_size;){\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\n                    local_vars.newind = j;\n                    break;\n                }\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\n                    local_vars.newind = j;\n                    break;\n                }\n                unchecked{ j++; }\n            }\n            fri_params.correct_order_idx[i] = local_vars.newind;\n            unchecked{ i++; }\n        }\n\n        uint256 first_offset = 0x20;\n        uint256 y_offset;\n\n        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\n        offset = basic_marshalling.skip_length(offset);             // Skip polynomial number\n        offset = basic_marshalling.skip_length(offset);             // Skip coset size\n        offset = basic_marshalling.skip_length(offset);             // Skip y length\n        for (local_vars.p_ind = 0; local_vars.p_ind < fri_params.batches_sizes[k];) {\n            for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\n                local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\n                // Check leaf size\n                // Prepare y-s\n                unchecked{ y_offset = offset + ( local_vars.newind << 6 ); }\n\n                // push y\n                if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\n                    assembly{\n                        mstore(\n                            add(mload(local_vars),first_offset), \n                            calldataload(add(blob.offset, y_offset))\n                        )\n                        mstore(\n                            add(mload(local_vars),add(first_offset, 0x20)), \n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\n                        )\n                    }\n                } else {\n                    assembly{\n                        mstore(\n                            add(mload(local_vars),first_offset), \n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\n                        )\n                        mstore(\n                            add(mload(local_vars),add(first_offset, 0x20)), \n                            calldataload(add(blob.offset, y_offset))\n                        )\n                    }\n                }\n                unchecked{ \n                    local_vars.y_ind++; \n                    first_offset += 0x40;\n                }\n            }\n            unchecked{ offset += (1<<(fri_params.step_list[0]+5)); local_vars.p_ind++; }\n        }\n    }\n\n    // For round proofs\n    //     Reorder local_vars.values and push to local_vars.b\n    function prepare_leaf_data(\n        bytes calldata blob,\n        uint256 offset,                                         // round proof offset\n        types.fri_params_type memory fri_params,\n        types.fri_state_type memory local_vars\n    ) internal pure {\n        uint256 base_index;\n        uint256 prev_half_size;\n        uint256 i;\n        uint256 j;\n\n        local_vars.indices_size = 1 << (fri_params.step_list[local_vars.step] - 1);\n        \n        fri_params.s_indices[0] = local_vars.x_index;\n        fri_params.s[0] = local_vars.x;\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[local_vars.step], local_vars.domain_size_mod);\n\n        // Fill s and s_indices\n        if( local_vars.indices_size > 1){\n            unchecked{\n                base_index = local_vars.domain_size >> 2; \n                prev_half_size = 1;\n                i = 1;\n                local_vars.newind = fri_params.D_omegas.length - 1;\n            }\n            while( i < local_vars.indices_size ){\n                for( j = 0; j < prev_half_size;) {\n                    unchecked{\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\n                    }\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\n                    unchecked{ j++; }\n                }\n                unchecked{\n                    base_index >>=1;\n                    prev_half_size <<=1;\n                    local_vars.newind--;\n                }\n            }\n        }\n\n        // Fill correct_order_idx\n        for ( i = 0; i < local_vars.indices_size;) {\n            for(j = 0; j < local_vars.indices_size;){\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\n                    local_vars.newind = j;\n                    break;\n                }\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\n                    local_vars.newind = j;\n                    break;\n                }\n                unchecked{ j++; }\n            }\n            fri_params.correct_order_idx[i] = local_vars.newind;\n            unchecked{ i++; }\n        }\n\n        uint256 y;\n        offset = 0x20;\n        for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\n            local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\n            // Check leaf size\n            // Prepare y-s\n\n            // push y\n            if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\n                y = local_vars.values[local_vars.newind<<1];\n                assembly{\n                    mstore(\n                        add(mload(local_vars), offset), y\n                    )\n                }\n                y = local_vars.values[(local_vars.newind<<1)+1];\n                assembly{\n                    mstore(\n                        add(mload(local_vars),add(offset, 0x20)), y\n                    )\n                }\n            } else {\n                y = local_vars.values[(local_vars.newind<<1)+1];\n                assembly{\n                    mstore(\n                        add(mload(local_vars), offset), y\n                    )\n                }\n                y = local_vars.values[local_vars.newind<<1];\n                assembly{\n                    mstore(\n                        add(mload(local_vars),add(offset, 0x20)), y\n                    )\n                }\n            }\n            unchecked{ \n                local_vars.y_ind++; \n                offset += 0x40;\n            }\n        }\n    }\n\n    function clear_values( uint256[] memory values )\n    internal pure{\n        for( uint256 i = 0; i < values.length;){\n            values[i] = 0;\n            unchecked{ i++; }\n        }\n    }\n\n    function load_values( bytes calldata blob, uint256 offset, types.fri_state_type memory local_vars )\n    internal pure{\n        uint256 len;\n        (len, offset) = basic_marshalling.get_skip_length(blob, offset);\n        for( uint256 i = 0; i < len;){\n            local_vars.values[i] = basic_marshalling.get_uint256_be(blob, offset);\n            offset = basic_marshalling.skip_uint256_be(offset);\n            unchecked{i++;}\n        }\n    }\n\n    function verify_proof_be(\n        bytes calldata blob, \n        uint256[] memory roots,\n        types.transcript_data memory tr_state,\n        types.fri_params_type memory fri_params\n    ) internal view returns (bool result) {\n        types.fri_state_type memory local_vars;\n\n        // TODO strange bug. If we we exchange two next lines, then it will not work.\n        local_vars.alphas = new uint256[](fri_params.r);\n        local_vars.b = new bytes(0x40 * fri_params.max_batch * fri_params.max_coset);\n\n        uint256 offset;\n        uint256 ind;\n        uint256 k;\n        uint256 i;\n\n        offset = basic_marshalling.skip_length(fri_params.fri_proof_offset);\n        offset = basic_marshalling.skip_length(offset);\n        for( ind = 0; ind < fri_params.step_list.length;){\n            transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, offset);\n            for( uint256 round = 0; round < fri_params.step_list[ind];){\n                local_vars.alphas[local_vars.cur] = transcript.get_field_challenge(tr_state, fri_params.modulus);\n                unchecked{ round++; local_vars.cur++;}\n            }\n            offset = basic_marshalling.skip_octet_vector_32_be(offset);\n            unchecked{ind++;}\n        }\n\n        for( local_vars.query_id = 0; local_vars.query_id < fri_params.lambda;){\n            // It'll be init_vars function next\n            unchecked{ local_vars.domain_size = 1 << (fri_params.D_omegas.length + 1); }\n            unchecked{ local_vars.domain_size_mod = local_vars.domain_size - 1; }\n            local_vars.x_index = transcript.get_integral_challenge_be(tr_state, 8) & local_vars.domain_size_mod;\n            local_vars.x = field.expmod_static(\n                fri_params.D_omegas[0],\n                local_vars.x_index,\n                fri_params.modulus\n            );\n\n            // Check initial proofs\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\n            for( k = 0; k < fri_params.batches_num;){\n                // Check merkle local_vars.roots\n                local_vars.root = merkle_verifier.get_merkle_root_from_proof(blob, offset);\n                if( local_vars.root != roots[k] ){\n                    return false;\n                }\n                prepare_initial_leaf_data(blob, offset, k, fri_params, local_vars);\n                local_vars.b_length = (fri_params.batches_sizes[k] << (fri_params.step_list[0] +5));\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\n                    blob, offset, local_vars.b, local_vars.b_length\n                )) {\n                    return false;\n                }\n                offset = skip_initial_proof_be(blob, offset);\n                // Check merkle proofs\n                unchecked{k++;}\n            }\n\n            // Construct ys for the first round\n            local_vars.coset_size = 1 << fri_params.step_list[0];\n            local_vars.values = new uint256[](1 << fri_params.max_step);\n            local_vars.tmp_values = new uint256[](1 << fri_params.max_step);\n\n            for( ind = 0; ind < fri_params.different_points;){                \n                offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\n                offset = basic_marshalling.skip_length(offset);\n                offset = basic_marshalling.skip_length(offset);\n                offset = basic_marshalling.skip_length(offset);\n                clear_values(local_vars.tmp_values);\n                local_vars.cur = 0;\n                for( k = 0; k < fri_params.batches_num;){\n                    for( i = 0; i < fri_params.batches_sizes[k];){\n                        polynomial.multiply_poly_on_coeff(local_vars.tmp_values,fri_params.theta, fri_params.modulus);\n                        if( fri_params.eval_map[local_vars.cur] == ind ){\n                            for( uint256 j = 0; j < local_vars.coset_size;){\n                                local_vars.tmp_values[j] = addmod(\n                                    local_vars.tmp_values[j], \n                                    basic_marshalling.get_uint256_be(blob, offset),\n                                    fri_params.modulus\n                                );\n                                offset = basic_marshalling.skip_uint256_be(offset);\n                                unchecked{ j++; }\n                            }\n                        } else {\n                            offset += (local_vars.coset_size << 5);\n                        }\n                        unchecked{ i++; local_vars.cur++;} \n                    }\n                    offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\n                    offset = basic_marshalling.skip_length(offset);\n                    offset = basic_marshalling.skip_length(offset);\n                    offset = basic_marshalling.skip_length(offset);\n                    unchecked{ k++; }\n                }\n\n                for( uint256 j = 0; j < local_vars.coset_size; j++){\n                    if( j & 1 == 0 )\n                        { local_vars.s = fri_params.s[j>>1];}\n                    else\n                        { local_vars.s = fri_params.modulus - fri_params.s[j>>1];}\n                    local_vars.tmp_values[j] = addmod(\n                        mulmod( local_vars.tmp_values[j], fri_params.factors[ind], fri_params.modulus),\n                        fri_params.modulus - polynomial.evaluate(fri_params.combined_U[ind], local_vars.s, fri_params.modulus),\n                        fri_params.modulus\n                    );\n                    // TODO Denominators for all s can be precomputed. It doesn't depend on polynomial.\n                    local_vars.tmp_values[j] = mulmod(\n                        local_vars.tmp_values[j],\n                        field.inverse_static(\n                            polynomial.evaluate(fri_params.denominators[ind], local_vars.s, fri_params.modulus),\n                            fri_params.modulus\n                        ),\n                        fri_params.modulus\n                    );\n                    local_vars.values[j] = addmod(local_vars.values[j], local_vars.tmp_values[j], fri_params.modulus);\n                }\n                unchecked{ind++;}\n            }\n\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\n            for( k = 0; k < fri_params.batches_num; ){\n                offset = skip_initial_proof_be(blob, offset);\n                unchecked{k++;}\n            }\n\n            // Round proofs check\n            local_vars.cur = 0;\n            offset = basic_marshalling.skip_length(offset);\n\n            for( local_vars.step = 0; local_vars.step < fri_params.step_list.length;){\n                // Merkle check;\n                local_vars.fri_root = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(offset) + 0x8);\n                if( local_vars.fri_root != fri_params.fri_roots[local_vars.step]) {\n                    return false;\n                }\n\n                local_vars.coset_size = 1 << fri_params.step_list[local_vars.step];\n                prepare_leaf_data(blob, offset, fri_params, local_vars);\n                local_vars.b_length = (1 << (fri_params.step_list[local_vars.step] + 5));\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\n                    blob, offset, local_vars.b, local_vars.b_length\n                )) {\n                    return false;\n                }\n\n                // Colinear check;\n                local_vars.factor = 1;\n                for( local_vars.round = 0; local_vars.round < fri_params.step_list[local_vars.step];){\n                    local_vars.coset_size >>= 1;\n                    calculate_s(fri_params, local_vars);\n                    local_vars.domain_size >>= 1;\n                    local_vars.domain_size_mod >>= 1;\n                    local_vars.x_index &= local_vars.domain_size_mod;\n                    local_vars.x = mulmod(local_vars.x, local_vars.x, fri_params.modulus);\n                    if( local_vars.round == 0){\n                        for( uint256 j = 0; j < local_vars.coset_size;){\n                            local_vars.f0 = local_vars.values[j<<1];\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\n                            local_vars.values[j] = addmod(local_vars.f0, local_vars.f1, fri_params.modulus);\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\n                            local_vars.values[j] = addmod(\n                                local_vars.values[j], \n                                mulmod(\n                                    local_vars.alphas[local_vars.cur],\n                                    addmod(local_vars.f0, fri_params.modulus-local_vars.f1, fri_params.modulus), \n                                    fri_params.modulus\n                                ),\n                                fri_params.modulus\n                            );\n                            local_vars.values[j] = mulmod(\n                                local_vars.values[j], \n                                fri_params.s[j],\n                                fri_params.modulus\n                            );\n                            unchecked{ j++; }\n                        }\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\n                    } else {\n                        for( uint256 j = 0; j < local_vars.coset_size;){\n                            local_vars.f0 = local_vars.values[j<<1];\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\n                            local_vars.values[j] = addmod(local_vars.f0, fri_params.modulus - local_vars.f1, fri_params.modulus);\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\n                            local_vars.values[j] = addmod(\n                                local_vars.values[j], \n                                mulmod(\n                                    local_vars.alphas[local_vars.cur],\n                                    addmod(local_vars.f0, local_vars.f1, fri_params.modulus), \n                                    fri_params.modulus\n                                ),\n                                fri_params.modulus\n                            );\n                            unchecked{ j++; }\n                        }\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\n                    }\n                    unchecked{local_vars.round++; local_vars.cur++;}\n                }\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\n                local_vars.interpolant = local_vars.values[0];\n\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\n                load_values(blob, offset, local_vars);\n                if( local_vars.interpolant != mulmod(local_vars.factor, local_vars.values[0], fri_params.modulus) ){\n                    return false;\n                }\n                offset = basic_marshalling.skip_vector_of_uint256_be(blob, offset);\n                unchecked{local_vars.step++;}\n            }\n\n            // Final polynomial check. Final polynomial degree is already checked while parsing process\n            if( polynomial.evaluate(fri_params.final_polynomial, local_vars.x, fri_params.modulus) != local_vars.values[0]){\n                return false;\n            }\n            if( polynomial.evaluate(fri_params.final_polynomial, fri_params.modulus-local_vars.x, fri_params.modulus) != local_vars.values[1]){\n                return false;\n            }\n            \n            fri_params.fri_cur_query_offset = skip_query_proof_be(blob, fri_params.fri_cur_query_offset);\n            unchecked{local_vars.query_id++;}\n        }\n        return true;\n    }\n}"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_lpc_verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n// Copyright (c) 2022-2023 Elena Tatuzova <e.tatuzova@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\nimport \"./batched_fri_verifier.sol\";\nimport \"../algebra/polynomial.sol\";\nimport \"../basic_marshalling.sol\";\n\nlibrary batched_lpc_verifier {\n\n    uint256 constant m = 2;\n\n    function skip_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        uint256 i;\n        uint256 len;\n        // z\n        \n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        for( i = 0; i < len; ){\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\n            unchecked{i++;}\n        }\n        // fri_proof\n        result_offset = batched_fri_verifier.skip_proof_be(blob, result_offset);\n    }\n\n    // Check proof data carefully.\n    // Load necessary offsets to fri params\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\n    internal pure returns (bool success, uint256 result_offset) {\n        success = true;\n        uint256 len;\n        // z\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\n        if( len != fri_params.batches_sizes.length ){\n            success = false;\n            return (success, result_offset);\n        }\n        for( uint256 i = 0; i < len; ){\n            if( fri_params.batches_sizes[i] == 0 ){\n                fri_params.batches_sizes[i] = basic_marshalling.get_length(blob, result_offset);\n            } else {\n                if( basic_marshalling.get_length(blob, result_offset) != fri_params.batches_sizes[i]){\n                    success = false;\n                    return (success, result_offset);\n                }\n            }\n            fri_params.poly_num += fri_params.batches_sizes[i];\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\n            unchecked{i++;}\n        }\n        // fri_proof\n        fri_params.fri_proof_offset = result_offset;\n        (success, result_offset) = batched_fri_verifier.parse_proof_be(fri_params, blob, result_offset);\n    }\n\n    // Input is proof_map.eval_proof_combined_value_offset\n    function get_variable_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \n    internal pure returns (uint256 z_i_j){\n        uint256 vv_offset = basic_marshalling.skip_length(offset);\n\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\n            blob, vv_offset, i, j\n        );\n    }\n\n    function get_permutation_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \n    internal pure returns (uint256 z_i_j){\n        uint256 p_offset = basic_marshalling.skip_length(offset);\n        \n        p_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, p_offset);\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\n            blob, p_offset, i, j\n        );\n    }\n\n    function get_quotient_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \n    internal pure returns (uint256 z_i_j){\n        uint256 q_offset = basic_marshalling.skip_length(offset);\n        \n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\n            blob, q_offset, i, j\n        );\n    }\n\n    // TODO add starting offsets of eval arrays to some kind of proof map\n    function get_fixed_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \n    internal pure returns (uint256 z_i_j){\n        uint256 fv_offset = basic_marshalling.skip_length(offset);\n        \n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\n            blob, fv_offset, i, j\n        );\n    }\n\n    function eval_points_eq(uint256[] memory p1, uint256[] memory p2 )\n    internal pure returns(bool eq){\n        eq = true;\n        if (p1.length != p2.length) return false;\n        for(uint256 i = 0; i < p1.length;){\n            if(p1[i] != p2[i]) return false;\n            unchecked{i++;}\n        }\n    }\n\n    // Use this hack only for lpc test(!)\n    // Call this function only after fri_params is completely initialized by parse* functions.\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \n    internal pure returns (uint256[] memory roots){\n        return batched_fri_verifier.extract_merkle_roots(blob, fri_params);\n    }\n\n    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z, uint256 modulus)\n    internal pure returns(uint256[2] memory U){\n//        require( xi.length == 2 );\n        U[0] = addmod(mulmod(z[0], xi[1], modulus),modulus - mulmod(z[1], xi[0], modulus), modulus);\n        U[1] = addmod(z[1], modulus - z[0], modulus);\n    }\n\n//  coeffs for zs on each degree can be precomputed if necessary\n    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z, uint256 modulus)\n    internal pure returns(uint256[3] memory U){\n//        require( xi.length == 3 );\n        z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);\n        z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);\n        z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);\n\n        U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);\n        U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);\n        U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);\n\n        U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);\n        U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);\n        U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);\n\n        U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);\n    }\n\n    function verify_proof_be(\n        bytes calldata blob,\n        uint256 offset, \n        uint256[] memory roots,\n        uint256[][][] memory evaluation_points,\n        types.transcript_data memory tr_state, \n        types.fri_params_type memory fri_params)\n    internal view returns (bool result) {\n        uint256 ind;\n\n        // Push all merkle roots to transcript\n        for( ind = 0; ind < fri_params.batches_num;){\n            transcript.update_transcript_b32(tr_state, bytes32(roots[ind]));\n            unchecked{ind++;}\n        }\n        fri_params.theta = transcript.get_field_challenge(tr_state, fri_params.modulus);\n        fri_params.eval_map = new uint256[](fri_params.poly_num);\n        fri_params.unique_eval_points = new uint256[][](fri_params.poly_num);\n\n        uint256 cur = 0;\n        fri_params.different_points = 0;\n        bool found = false;\n        uint256[] memory point;\n        uint256 k;\n        uint256 i;        \n\n        // Prepare evaluation map;\n        for( k = 0; k < fri_params.batches_num;){\n            for( i = 0; i < fri_params.batches_sizes[k]; ){\n                if( evaluation_points[k].length == 1 && i > 0){\n                    fri_params.eval_map[cur] = fri_params.eval_map[cur - 1];\n                } else {\n                    point = evaluation_points[k][i];\n                    // find this point\n                    found = false;\n                    for( ind = 0; ind < fri_params.different_points;){\n                        if( eval_points_eq(point, fri_params.unique_eval_points[ind]) ){\n                            found = true;\n                            fri_params.eval_map[cur] = ind;\n                            break;\n                        }\n                        unchecked{ind++;}\n                    }\n                    if(!found) {\n                        fri_params.unique_eval_points[fri_params.different_points] = point;\n                        fri_params.eval_map[cur] = fri_params.different_points;\n                        unchecked{\n                            fri_params.different_points++;\n                        }\n                    }   \n                }\n                unchecked{i++;cur++;}\n            }\n            unchecked{k++;}\n        }\n\n        fri_params.denominators = new uint256[][](fri_params.different_points);\n        fri_params.factors = new uint256[](fri_params.different_points);\n\n        // Prepare denominators\n        for( ind = 0; ind < fri_params.different_points;){\n            fri_params.denominators[ind] = new uint256[](fri_params.unique_eval_points[ind].length + 1);\n            if( fri_params.unique_eval_points[ind].length == 1 ){\n                fri_params.factors[ind] = 1;\n                fri_params.denominators[ind][0] = fri_params.modulus - fri_params.unique_eval_points[ind][0];\n                fri_params.denominators[ind][1] = 1;\n            } else \n            if( fri_params.unique_eval_points[ind].length == 2 ){\n                // xi1 - xi0\n                fri_params.factors[ind] = \n                    addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus);\n                fri_params.denominators[ind][2] = 1;\n\n                fri_params.denominators[ind][1] = \n                    fri_params.modulus - addmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\n\n                fri_params.denominators[ind][0] = \n                    mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\n            } else \n            if( fri_params.unique_eval_points[ind].length == 3 ){\n                fri_params.factors[ind] = fri_params.modulus - \n                    mulmod(\n                        mulmod(\n                            addmod(fri_params.unique_eval_points[ind][0], fri_params.modulus - fri_params.unique_eval_points[ind][1], fri_params.modulus),\n                            addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][2], fri_params.modulus),\n                            fri_params.modulus\n                        ),\n                        addmod(fri_params.unique_eval_points[ind][2], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus),\n                        fri_params.modulus\n                    );\n                fri_params.denominators[ind][3] = 1;\n                fri_params.denominators[ind][2] =\n                    fri_params.modulus - addmod(\n                        fri_params.unique_eval_points[ind][0], \n                        addmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \n                        fri_params.modulus\n                    );\n                fri_params.denominators[ind][1] = \n                    addmod(\n                        mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus),\n                        addmod(\n                            mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][2], fri_params.modulus),\n                            mulmod(fri_params.unique_eval_points[ind][1], fri_params.unique_eval_points[ind][2], fri_params.modulus),\n                            fri_params.modulus\n                        ), \n                        fri_params.modulus\n                    );\n                fri_params.denominators[ind][0] = \n                    fri_params.modulus - mulmod(\n                        fri_params.unique_eval_points[ind][0], \n                        mulmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \n                        fri_params.modulus\n                    );\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\n                fri_params.denominators[ind][3] = mulmod(fri_params.denominators[ind][3], fri_params.factors[ind], fri_params.modulus);\n            } else {\n                return false;\n            }\n            unchecked{ind++;}\n        }\n\n        // Prepare combined U\n        fri_params.combined_U = new uint256[][](fri_params.different_points);\n        for( ind = 0; ind < fri_params.different_points;){\n            point = fri_params.unique_eval_points[ind];\n            fri_params.combined_U[ind] = new uint256[](fri_params.unique_eval_points[ind].length);\n            cur = 0;\n            fri_params.z_offset = basic_marshalling.skip_length(offset);\n            for( k = 0; k < fri_params.batches_num;){\n                fri_params.z_offset = basic_marshalling.skip_length(fri_params.z_offset);\n                for( i = 0; i < fri_params.batches_sizes[k];){                    \n                    polynomial.multiply_poly_on_coeff(\n                        fri_params.combined_U[ind], \n                        fri_params.theta, \n                        fri_params.modulus\n                    );\n                    if( fri_params.eval_map[cur] == ind ){\n                        if( point.length == 1 ){\n                            fri_params.combined_U[ind][0] = addmod(\n                                fri_params.combined_U[ind][0],\n                                basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0), \n                                fri_params.modulus\n                            );\n                        } else \n                        if( point.length == 2 ){\n                            uint256[2] memory tmp;\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\n                            tmp = calculate_2points_interpolation(\n                                point, tmp, fri_params.modulus\n                            );\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\n                        } else \n                        if( point.length == 3){\n                            uint256[3] memory tmp;\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\n                            tmp[2] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 2);\n                            tmp = calculate_3points_interpolation(\n                                point, tmp, fri_params.modulus\n                            );\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\n                            fri_params.combined_U[ind][2] = addmod(fri_params.combined_U[ind][2], tmp[2], fri_params.modulus);\n                        } else {\n                            return false;\n                        }\n                    } \n                    fri_params.z_offset = basic_marshalling.skip_vector_of_uint256_be(blob, fri_params.z_offset);\n                    unchecked{i++;cur++;}\n                }\n                unchecked{k++;}\n            }\n            unchecked{ind++;}\n        }\n\n\n        if (!batched_fri_verifier.verify_proof_be(blob, roots, tr_state, fri_params)) {\n            return false;\n        }\n        \n        return true;\n   }\n} "
    },
    "@nilfoundation/evm-placeholder-verification/contracts/containers/merkle_verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\n\nlibrary merkle_verifier {\n    // Merkle proof has the following structure:\n    // [0:8] - leaf index\n    // [8:16] - root length (which is always 32 bytes in current implementation)\n    // [16:48] - root\n    // [48:56] - merkle tree depth\n    //\n    // Depth number of layers with co-path elements follows then.\n    // Each layer has following structure (actually indexes begin from a certain offset):\n    // [0:8] - number of co-path elements on the layer\n    //  (layer_size = arity-1 actually, which (arity) is always 2 in current implementation)\n    //\n    // layer_size number of co-path elements for every layer in merkle proof follows then.\n    // Each element has following structure (actually indexes begin from a certain offset):\n    // [0:8] - co-path element position on the layer\n    // [8:16] - co-path element hash value length (which is always 32 bytes in current implementation)\n    // [16:48] - co-path element hash value\n    uint256 constant ROOT_OFFSET = 16;\n    uint256 constant DEPTH_OFFSET = 48;\n    uint256 constant LAYERS_OFFSET = 56;\n    // only one co-element on each layer as arity is always 2\n    // 8 + (number of co-path elements on the layer)\n    // 8 + (co-path element position on the layer)\n    // 8 + (co-path element hash value length)\n    // 32 (co-path element hash value)\n    uint256 constant LAYER_POSITION_OFFSET = 8;\n    uint256 constant LAYER_COPATH_HASH_OFFSET = 24;\n    uint256 constant LAYER_OCTETS = 56;\n\n    uint256 constant LENGTH_OCTETS = 8;\n    // 256 - 8 * LENGTH_OCTETS\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\n\n    function skip_merkle_proof_be(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\n        assembly {\n            result_offset := add(\n                result_offset,\n                mul(\n                    LAYER_OCTETS,\n                    shr(\n                        LENGTH_RESTORING_SHIFT,\n                        calldataload(\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\n                        )\n                    )\n                )\n            )\n        }\n    }\n\n    function skip_merkle_proof_be_check(bytes calldata blob, uint256 offset)\n    internal pure returns (uint256 result_offset) {\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\n        require(result_offset < blob.length);\n        assembly {\n            result_offset := add(\n                result_offset,\n                mul(\n                    LAYER_OCTETS,\n                    shr(\n                        LENGTH_RESTORING_SHIFT,\n                        calldataload(\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\n                        )\n                    )\n                )\n            )\n        }\n        require(result_offset <= blob.length, \"skip_merkle_proof_be\");\n    }\n\n    function parse_verify_merkle_proof_not_pre_hash_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\n    internal pure returns (bool result) {\n//        uint256 x = 0;\n//        uint256 depth;\n        assembly {\n            let depth := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, add(offset, DEPTH_OFFSET))))\n\n            // save leaf hash data to required position\n            let pos := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(\n                    add(\n                        blob.offset,\n                        add(add(offset, LAYERS_OFFSET), LAYER_POSITION_OFFSET)\n                    )\n                )\n            )\n//            x := add(x, pos)\n//            x := mul(x, 10)\n            switch pos\n            case 0 {\n                mstore(0x20, verified_data)\n            }\n            case 1 {\n                mstore(0x00, verified_data)\n            }\n\n            let layer_offst := add(offset, LAYERS_OFFSET)\n            let next_pos\n            for {\n                let cur_layer_i := 0\n            } lt(cur_layer_i, sub(depth, 1)) {\n                cur_layer_i := add(cur_layer_i, 1)\n            } {\n                pos := shr(\n                    LENGTH_RESTORING_SHIFT,\n                    calldataload(\n                        add(\n                            blob.offset,\n                            add(layer_offst, LAYER_POSITION_OFFSET)\n                        )\n                    )\n                )\n                next_pos := shr(\n                    LENGTH_RESTORING_SHIFT,\n                    calldataload(\n                        add(\n                            blob.offset,\n                            add(\n                                add(layer_offst, LAYER_POSITION_OFFSET),\n                                LAYER_OCTETS\n                            )\n                        )\n                    )\n                )\n//                x := add(x, pos)\n//                x := mul(x, 10)\n                switch pos\n                case 0 {\n                    mstore(\n                        0x00,\n                        calldataload(\n                            add(\n                                blob.offset,\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\n                            )\n                        )\n                    )\n                    switch next_pos\n                    case 0 {\n                        mstore(0x20, keccak256(0, 0x40))\n                    }\n                    case 1 {\n                        mstore(0, keccak256(0, 0x40))\n                    }\n                }\n                case 1 {\n                    mstore(\n                        0x20,\n                        calldataload(\n                            add(\n                                blob.offset,\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\n                            )\n                        )\n                    )\n                    switch next_pos\n                    case 0 {\n                        mstore(0x20, keccak256(0, 0x40))\n                    }\n                    case 1 {\n                        mstore(0, keccak256(0, 0x40))\n                    }\n                }\n                layer_offst := add(layer_offst, LAYER_OCTETS)\n            }\n\n            pos := shr(\n                LENGTH_RESTORING_SHIFT,\n                calldataload(\n                    add(blob.offset, add(layer_offst, LAYER_POSITION_OFFSET))\n                )\n            )\n//            x := add(x, pos)\n//            x := mul(x, 10)\n            switch pos\n            case 0 {\n                mstore(\n                    0x00,\n                    calldataload(\n                        add(\n                            blob.offset,\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\n                        )\n                    )\n                )\n                verified_data := keccak256(0, 0x40)\n            }\n            case 1 {\n                mstore(\n                    0x20,\n                    calldataload(\n                        add(\n                            blob.offset,\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\n                        )\n                    )\n                )\n                verified_data := keccak256(0, 0x40)\n            }\n        }\n\n        bytes32 root;\n        assembly {\n            root := calldataload(add(blob.offset, add(offset, ROOT_OFFSET)))\n        }\n        result = (verified_data == root);\n    }\n    \n    // We store merkle root as an octet vector. At first length==0x20 is stored.\n    // We should skip it.\n    // TODO: this function should return bytes32\n    function get_merkle_root_from_blob(bytes calldata blob, uint256 merkle_root_offset)\n    internal pure returns(uint256 root){\n        assembly {\n            root := calldataload(add(blob.offset, add(merkle_root_offset, 0x8)))\n        }\n    }\n\n    // TODO: This function should return bytes32\n    function get_merkle_root_from_proof(bytes calldata blob, uint256 merkle_proof_offset)\n    internal pure returns(uint256 root){\n        assembly {\n            root := calldataload(add(blob.offset, add(merkle_proof_offset, ROOT_OFFSET)))\n        }\n    }\n\n    function parse_verify_merkle_proof_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\n    internal pure returns (bool result) {\n        assembly {\n            mstore(0, verified_data)\n            verified_data := keccak256(0, 0x20)\n        }\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\n    }\n\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data)\n    internal pure returns (bool result) {\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, keccak256(verified_data));\n    }\n\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data_bytes,\n                                                uint256 verified_data_bytes_len)\n    internal pure returns (bool result) {\n        bytes32 verified_data;\n        assembly {\n            verified_data := keccak256(add(verified_data_bytes, 0x20), verified_data_bytes_len)\n        }\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/cryptography/transcript.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n//---------------------------------------------------------------------------//\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\n\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\n\n/**\n * @title Transcript library\n * @dev Generates Plonk random challenges\n */\nlibrary transcript {\n    function init_transcript(types.transcript_data memory self, bytes memory init_blob)\n    internal pure {\n        self.current_challenge = keccak256(init_blob);\n    }\n\n    function update_transcript(types.transcript_data memory self, bytes memory blob)\n    internal pure {\n        self.current_challenge = keccak256(bytes.concat(self.current_challenge, blob));\n    }\n\n    function update_transcript_b32(types.transcript_data memory self, bytes32 blob)\n    internal pure {\n        self.current_challenge = keccak256(\n            bytes.concat(self.current_challenge, blob)\n        );\n    }\n\n    function update_transcript_b32_by_offset(types.transcript_data memory self, bytes memory blob, uint256 offset)\n    internal pure {\n        require(offset < blob.length, \"update_transcript_b32_by_offset: offset < blob.length\");\n        require(32 <= blob.length - offset, \"update_transcript_b32_by_offset: 32 <= blob.length - offset\");\n\n        bytes32 blob32;\n        assembly {\n            blob32 := mload(add(add(blob, 0x20), offset))\n        }\n        update_transcript_b32(self, blob32);\n    }\n\n    function update_transcript_b32_by_offset_calldata(types.transcript_data memory self, bytes calldata blob,\n                                                      uint256 offset)\n    internal pure {\n        require(offset < blob.length, \"update_transcript_b32_by_offset: offset < blob.length\");\n        require(32 <= blob.length - offset, \"update_transcript_b32_by_offset: 32 <= blob.length - offset\");\n\n        bytes32 blob32;\n        assembly {\n            blob32 := calldataload(add(blob.offset, offset))\n        }\n        update_transcript_b32(self, blob32);\n    }\n\n    function get_integral_challenge_be(types.transcript_data memory self, uint256 length)\n    internal pure returns (uint256 result) {\n        require(length <= 32);\n        self.current_challenge = keccak256(abi.encodePacked(self.current_challenge));\n        return (uint256(self.current_challenge) &\n               (((uint256(1) << (length * 8)) - 1) << (uint256(256) - length * 8))) >> (uint256(256) - length * 8);\n    }\n\n    function get_field_challenge(types.transcript_data memory self, uint256 modulus)\n    internal pure returns (uint256) {\n        self.current_challenge = keccak256(abi.encode(self.current_challenge));\n        return uint256(self.current_challenge) % modulus;\n    }\n\n    function get_field_challenges(types.transcript_data memory self, uint256[] memory challenges, uint256 modulus)\n    internal pure {\n        if (challenges.length > 0) {\n            bytes32 new_challenge = self.current_challenge;\n            for (uint256 i = 0; i < challenges.length;) {\n                new_challenge = keccak256(abi.encode(new_challenge));\n                challenges[i] = uint256(new_challenge) % modulus;\n                unchecked{ i++; }\n            }\n            self.current_challenge = new_challenge;\n        }\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/interfaces/gate_argument.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\n\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\n\ninterface IGateArgument {\n    function evaluate_gates_be(bytes calldata blob,\n        uint256 eval_proof_combined_value_offset,\n        types.gate_argument_params memory gate_params,\n        types.arithmetization_params memory ar_params,\n        int256[][] calldata columns_rotations\n    ) external pure returns (uint256 gates_evaluation);\n}"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/interfaces/verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity ^0.8.0;\n\ninterface IVerifier {\n    function verify(        \n        bytes calldata blob,\n        uint256[] calldata init_params,\n        int256[][] calldata columns_rotations,\n        uint256[] calldata public_input,\n        address gate_argument\n    ) external view returns (bool);\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/placeholder/permutation_argument.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\nimport \"../basic_marshalling.sol\";\nimport \"../cryptography/transcript.sol\";\nimport \"../commitments/batched_lpc_verifier.sol\";\n\nlibrary permutation_argument {\n    uint256 constant ARGUMENT_SIZE = 3;\n\n    uint256 constant EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET = 0xa0;\n\n    uint256 constant LEN_OFFSET = 0x0;\n    uint256 constant OFFSET_OFFSET = 0x20;\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\n    uint256 constant ALPHAS_OFFSET = 0xa0;\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\n    uint256 constant E_OFFSET = 0xe0;\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\n    uint256 constant F_OFFSET = 0x120;\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\n    uint256 constant BETA_OFFSET = 0x1a0;\n    uint256 constant GAMMA_OFFSET = 0x1c0;\n    uint256 constant G_OFFSET = 0x1e0;\n    uint256 constant H_OFFSET = 0x200;\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\n    uint256 constant TMP1_OFFSET = 0x300;\n    uint256 constant TMP2_OFFSET = 0x320;\n    uint256 constant TMP3_OFFSET = 0x340;\n    uint256 constant IDX1_OFFSET = 0x360;\n    uint256 constant IDX2_OFFSET = 0x380;\n    uint256 constant STATUS_OFFSET = 0x3a0;\n\n    function eval_permutations_at_challenge(\n        types.fri_params_type memory fri_params,\n        types.placeholder_state_type memory local_vars,\n        uint256 column_polynomials_values_i\n    ) internal pure {\n        assembly {\n            let modulus := mload(fri_params)\n            mstore(\n                add(local_vars, G_OFFSET),\n                mulmod(\n                    mload(add(local_vars, G_OFFSET)),\n                    // column_polynomials_values[i] + beta * S_id[i].evaluate(challenge) + gamma\n                    addmod(\n                        // column_polynomials_values[i]\n                        column_polynomials_values_i,\n                        // beta * S_id[i].evaluate(challenge) + gamma\n                        addmod(\n                            // beta * S_id[i].evaluate(challenge)\n                            mulmod(\n                                // beta\n                                mload(add(local_vars, BETA_OFFSET)),\n                                // S_id[i].evaluate(challenge)\n                                mload(add(local_vars, S_ID_I_OFFSET)),\n                                modulus\n                            ),\n                            // gamma\n                            mload(add(local_vars, GAMMA_OFFSET)),\n                            modulus\n                        ),\n                        modulus\n                    ),\n                    modulus\n                )\n            )\n            mstore(\n                add(local_vars, H_OFFSET),\n                mulmod(\n                    mload(add(local_vars, H_OFFSET)),\n                    // column_polynomials_values[i] + beta * S_sigma[i].evaluate(challenge) + gamma\n                    addmod(\n                        // column_polynomials_values[i]\n                        column_polynomials_values_i,\n                        // beta * S_sigma[i].evaluate(challenge) + gamma\n                        addmod(\n                            // beta * S_sigma[i].evaluate(challenge)\n                            mulmod(\n                                // beta\n                                mload(add(local_vars, BETA_OFFSET)),\n                                // S_sigma[i].evaluate(challenge)\n                                mload(add(local_vars, S_SIGMA_I_OFFSET)),\n                                modulus\n                            ),\n                            // gamma\n                            mload(add(local_vars, GAMMA_OFFSET)),\n                            modulus\n                        ),\n                        modulus\n                    ),\n                    modulus\n                )\n            )\n        }\n    }\n\n    function verify_eval_be(bytes calldata blob,\n        types.transcript_data memory tr_state,\n        types.placeholder_proof_map memory proof_map,\n        types.fri_params_type memory fri_params,\n        types.placeholder_common_data memory common_data,\n        types.placeholder_state_type memory local_vars,\n        types.arithmetization_params memory ar_params\n    ) internal pure returns (uint256[] memory F) {\n        // 1. Get beta, gamma\n        local_vars.beta = transcript.get_field_challenge(\n            tr_state,\n            fri_params.modulus\n        );\n        local_vars.gamma = transcript.get_field_challenge(\n            tr_state,\n            fri_params.modulus\n        );\n\n        // 2. Add commitment to V_P to transcript\n        transcript.update_transcript_b32_by_offset_calldata(\n            tr_state,\n            blob,\n            proof_map.v_perm_commitment_offset + basic_marshalling.LENGTH_OCTETS\n        );\n\n        // splash\n        local_vars.len = ar_params.permutation_columns;\n\n        //require(\n        //    batched_lpc_verifier.get_z_n_be(blob, proof_map.eval_proof_fixed_values_offset) == ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 2,\n        //    \"Something wrong with number of fixed values polys\"\n        //);\n        local_vars.tmp1 = ar_params.witness_columns;\n        local_vars.tmp2 = ar_params.public_input_columns;\n        local_vars.tmp3 = ar_params.constant_columns;\n\n\n        // 3. Calculate h_perm, g_perm at challenge pointa\n        local_vars.g = 1;\n        local_vars.h = 1;\n        for (\n            local_vars.idx1 = 0;\n            local_vars.idx1 < local_vars.len;\n            local_vars.idx1++\n        ) {\n            for (\n                local_vars.idx2 = 0;\n                local_vars.idx2 < common_data.columns_rotations[local_vars.idx1].length;\n                local_vars.idx2++\n            ) {\n                if (common_data.columns_rotations[local_vars.idx1][local_vars.idx2] == 0 ) {\n                    local_vars.zero_index = local_vars.idx2;\n                }\n            }\n\n            local_vars.S_id_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\n                blob,\n                proof_map.eval_proof_combined_value_offset,\n                local_vars.idx1,\n                0\n            );\n\n            // sigma_i\n            local_vars.S_sigma_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\n                blob,\n                proof_map.eval_proof_combined_value_offset,\n                ar_params.permutation_columns + local_vars.idx1,\n                0\n            );\n\n            if (local_vars.idx1 < local_vars.tmp1) {\n                eval_permutations_at_challenge(\n                    fri_params,\n                    local_vars,\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\n                        blob,\n                        proof_map.eval_proof_combined_value_offset, // witnesses\n                        local_vars.idx1,\n                        local_vars.zero_index\n                    )\n                );\n            } else if (local_vars.idx1 < local_vars.tmp1 + local_vars.tmp2) {\n                eval_permutations_at_challenge(\n                    fri_params,\n                    local_vars,\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\n                        blob,\n                        proof_map.eval_proof_combined_value_offset, // public_input\n                        local_vars.idx1,\n                        local_vars.zero_index\n                    )\n                );\n            } else if ( local_vars.idx1 <  local_vars.tmp1 + local_vars.tmp2 + local_vars.tmp3 ) {\n                eval_permutations_at_challenge(\n                    fri_params,\n                    local_vars,\n                    batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\n                        blob,\n                        proof_map.eval_proof_combined_value_offset, // constant\n                        local_vars.idx1 - local_vars.tmp1 - local_vars.tmp2 + ar_params.permutation_columns + ar_params.permutation_columns,\n                        local_vars.zero_index\n                    )\n                );\n            }\n        }\n\n        local_vars.perm_polynomial_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\n            blob, proof_map.eval_proof_combined_value_offset, 0, 0\n        );\n        local_vars.perm_polynomial_shifted_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\n            blob, proof_map.eval_proof_combined_value_offset, 0, 1\n        );\n\n        local_vars.q_last_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\n            blob, \n            proof_map.eval_proof_combined_value_offset,       // special selector 0\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns,\n            0\n        );\n        local_vars.q_blind_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\n            blob, \n            proof_map.eval_proof_combined_value_offset,       // special selector 1\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 1,\n            0\n        );\n        F = new uint256[](ARGUMENT_SIZE);\n        local_vars.challenge = basic_marshalling.get_uint256_be(\n            blob,\n            proof_map.eval_proof_offset\n        );\n        assembly {\n            let modulus := mload(fri_params)\n\n            // F[0]\n            mstore(\n                add(F, 0x20),\n                mulmod(\n                    calldataload(\n                        add(\n                            blob.offset,\n                            mload(\n                                add(\n                                    proof_map,\n                                    EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET\n                                )\n                            )\n                        )\n                    ),\n                    addmod(\n                        1,\n                        // one - perm_polynomial_value\n                        sub(\n                            modulus,\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\n                        ),\n                        modulus\n                    ),\n                    modulus\n                )\n            )\n        }\n        assembly{\n            let modulus := mload(fri_params)\n            // F[1]\n            mstore(\n                add(F, 0x40),\n                // (one - preprocessed_data.q_last.evaluate(challenge) -\n                //  preprocessed_data.q_blind.evaluate(challenge)) *\n                //  (perm_polynomial_shifted_value * h - perm_polynomial_value * g)\n                mulmod(\n                    // one - preprocessed_data.q_last.evaluate(challenge) -\n                    //  preprocessed_data.q_blind.evaluate(challenge)\n                    addmod(\n                        1,\n                        // -preprocessed_data.q_last.evaluate(challenge) - preprocessed_data.q_blind.evaluate(challenge)\n                        addmod(\n                            // -preprocessed_data.q_last.evaluate(challenge)\n                            sub(\n                                modulus,\n                                mload(add(local_vars, Q_LAST_EVAL_OFFSET))\n                            ),\n                            // -preprocessed_data.q_blind.evaluate(challenge)\n                            sub(\n                                modulus,\n                                mload(add(local_vars, Q_BLIND_EVAL_OFFSET))\n                            ),\n                            modulus\n                        ),\n                        modulus\n                    ),\n                    // perm_polynomial_shifted_value * h - perm_polynomial_value * g\n                    addmod(\n                        // perm_polynomial_shifted_value * h\n                        mulmod(\n                            // perm_polynomial_shifted_value\n                            mload(\n                                add(\n                                    local_vars,\n                                    PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET\n                                )\n                            ),\n                            // h\n                            mload(add(local_vars, H_OFFSET)),\n                            modulus\n                        ),\n                        // - perm_polynomial_value * g\n                        sub(\n                            modulus,\n                            mulmod(\n                                // perm_polynomial_value\n                                mload(\n                                    add(\n                                        local_vars,\n                                        PERM_POLYNOMIAL_VALUE_OFFSET\n                                    )\n                                ),\n                                // g\n                                mload(add(local_vars, G_OFFSET)),\n                                modulus\n                            )\n                        ),\n                        modulus\n                    ),\n                    modulus\n                )\n            )\n        }\n        assembly{\n            let modulus := mload(fri_params)\n            // F[2]\n            mstore(\n                add(F, 0x60),\n                // preprocessed_data.q_last.evaluate(challenge) *\n                //  (perm_polynomial_value.squared() - perm_polynomial_value)\n                mulmod(\n                    // preprocessed_data.q_last.evaluate(challenge)\n                    mload(add(local_vars, Q_LAST_EVAL_OFFSET)),\n                    // perm_polynomial_value.squared() - perm_polynomial_value\n                    addmod(\n                        // perm_polynomial_value.squared()\n                        mulmod(\n                            // perm_polynomial_value\n                            mload(\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\n                            ),\n                            // perm_polynomial_value\n                            mload(\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\n                            ),\n                            modulus\n                        ),\n                        // -perm_polynomial_value\n                        sub(\n                            modulus,\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\n                        ),\n                        modulus\n                    ),\n                    modulus\n                )\n            )\n        }\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/placeholder/proof_map_parser.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\nimport \"../commitments/batched_lpc_verifier.sol\";\nimport \"../basic_marshalling.sol\";\n\nlibrary placeholder_proof_map_parser {\n    /**\n     * Proof structure: https://github.com/NilFoundation/crypto3-zk-marshalling/blob/master/include/nil/crypto3/marshalling/zk/types/placeholder/proof.hpp\n     */\n    function parse_be(bytes calldata blob, uint256 offset)\n    internal pure returns (types.placeholder_proof_map memory proof_map, uint256 proof_size){\n        proof_map.variable_values_commitment_offset = offset;\n        proof_map.v_perm_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.variable_values_commitment_offset);\n        proof_map.T_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.v_perm_commitment_offset);\n        proof_map.fixed_values_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.T_commitment_offset);\n        proof_map.eval_proof_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.fixed_values_commitment_offset);//challenge_offset\n\n        //require(false, logging.uint2decstr(basic_marshalling.get_uint256_be(blob, proof_map.eval_proof_offset)));\n        // TODO: add data structures for lookups\n\n        proof_map.eval_proof_lagrange_0_offset = basic_marshalling.skip_uint256_be_check(blob, proof_map.eval_proof_offset); \n        proof_map.eval_proof_combined_value_offset = basic_marshalling.skip_uint256_be_check(blob, proof_map.eval_proof_lagrange_0_offset);\n        proof_size = batched_lpc_verifier.skip_proof_be(blob, proof_map.eval_proof_combined_value_offset);\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/placeholder/verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"../types.sol\";\nimport \"../cryptography/transcript.sol\";\nimport \"./permutation_argument.sol\";\nimport \"../basic_marshalling.sol\";\nimport \"../algebra/field.sol\";\n\nlibrary ProofVerifier {\n    // TODO: check correctness all this const\n    uint256 constant f_parts = 9;\n\n    uint256 constant OMEGA_OFFSET = 0x20;\n\n    uint256 constant LEN_OFFSET = 0x0;\n    uint256 constant OFFSET_OFFSET = 0x20;\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\n    uint256 constant ALPHAS_OFFSET = 0xa0;\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\n    uint256 constant E_OFFSET = 0xe0;\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\n    uint256 constant F_OFFSET = 0x120;\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\n    uint256 constant BETA_OFFSET = 0x1a0;\n    uint256 constant GAMMA_OFFSET = 0x1c0;\n    uint256 constant G_OFFSET = 0x1e0;\n    uint256 constant H_OFFSET = 0x200;\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\n    uint256 constant STATUS_OFFSET = 0x3a0;\n\n    function verify_proof_be(bytes calldata blob,\n        types.transcript_data memory tr_state,\n        types.placeholder_proof_map memory proof_map,\n        types.fri_params_type memory fri_params,\n        types.placeholder_common_data memory common_data,\n        types.placeholder_state_type memory local_vars,\n        types.arithmetization_params memory ar_params\n    ) external view returns (bool result) {\n        // 8. alphas computations\n        local_vars.alphas = new uint256[](f_parts);\n        transcript.get_field_challenges(tr_state, local_vars.alphas, fri_params.modulus);\n\n        // 9. Evaluation proof check\n        transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, basic_marshalling.skip_length(proof_map.T_commitment_offset));\n        local_vars.challenge = transcript.get_field_challenge(tr_state, fri_params.modulus);\n        if (local_vars.challenge != basic_marshalling.get_uint256_be(blob, proof_map.eval_proof_offset)) {\n            return false;\n        }\n\n        // variable values\n\n        local_vars.inversed_omega = field.inverse_static(common_data.omega, fri_params.modulus);\n        uint256 challenge_omega = field.fmul(local_vars.challenge, common_data.omega, fri_params.modulus);\n        uint256 challenge_inversed_omega = field.fmul(local_vars.challenge, local_vars.inversed_omega, fri_params.modulus);\n\n        // TODO this should be bytes32\n        local_vars.roots = new uint256[](fri_params.batches_num);\n        local_vars.roots[0] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.variable_values_commitment_offset);\n        local_vars.roots[1] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.v_perm_commitment_offset);\n        local_vars.roots[2] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.T_commitment_offset);\n        local_vars.roots[3] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.fixed_values_commitment_offset);\n\n        uint256[] memory challenge_point = new uint256[](1);\n        challenge_point[0] = local_vars.challenge;\n\n        local_vars.evaluation_points = new uint256[][][](fri_params.batches_num);\n        local_vars.evaluation_points[0] = new uint256[][](fri_params.batches_sizes[0]);\n\n        for (uint256 i = 0; i < ar_params.witness_columns + ar_params.public_input_columns;) {\n            local_vars.evaluation_points[0][i] = new uint256[](common_data.columns_rotations[i].length);\n            for (uint256 j = 0; j < common_data.columns_rotations[i].length;) {\n                if(common_data.columns_rotations[i][j] == 0){\n                    local_vars.evaluation_points[0][i][j] = local_vars.challenge;\n                } else if(common_data.columns_rotations[i][j] == 1){\n                    local_vars.evaluation_points[0][i][j] = challenge_omega;\n                } else if(common_data.columns_rotations[i][j] == -1) {\n                    local_vars.evaluation_points[0][i][j] = challenge_inversed_omega;\n                } else {\n                    uint256 omega;\n                    uint256 e;\n\n                    if (common_data.columns_rotations[i][j] < 0) {\n                        omega = local_vars.inversed_omega;\n                        e = uint256(-common_data.columns_rotations[i][j]);\n                    } else {\n                        omega = common_data.omega;\n                        e = uint256(common_data.columns_rotations[i][j]);\n                    }\n                    // TODO check it!!!!\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\n                    assembly{\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\n                            if not(eq(and(e,1), 0)){\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\n                            }\n                            if not(eq(e, 1)){\n                                omega := mulmod(omega,omega, mload(fri_params))\n                            }\n                        }\n                    }\n                    local_vars.evaluation_points[0][i][j] = local_vars.e;\n                }\n            unchecked{j++;}\n            }\n        unchecked{i++;}\n        }\n\n        // For permutation polynomial\n        local_vars.evaluation_points[1] = new uint256[][](1);\n        local_vars.evaluation_points[1][0] = new uint256[](2);\n        local_vars.evaluation_points[1][0][0] = local_vars.challenge;\n        local_vars.evaluation_points[1][0][1] = challenge_omega;\n\n        local_vars.evaluation_points[2] = new uint256[][](1);\n        local_vars.evaluation_points[2][0] = challenge_point;\n\n        local_vars.evaluation_points[3] = new uint256[][](fri_params.batches_sizes[3]);\n        for (uint256 i = 0; i < (ar_params.permutation_columns << 1);) {\n            local_vars.evaluation_points[3][i] = challenge_point;\n            unchecked{i++;}\n        }\n\n        // constant columns and selector columns may be rotated\n        for( uint256 i = 0; i < ar_params.constant_columns + ar_params.selector_columns; ){\n            uint256 eval_point_ind = i + (ar_params.permutation_columns << 1);\n            uint256 rotation_ind = i + (ar_params.witness_columns + ar_params.public_input_columns);\n            local_vars.evaluation_points[3][eval_point_ind] =\n                new uint256[](common_data.columns_rotations[rotation_ind].length);\n            for (uint256 j = 0; j < common_data.columns_rotations[rotation_ind].length;) {\n                if(common_data.columns_rotations[rotation_ind][j] == 0){\n                    local_vars.evaluation_points[3][eval_point_ind][j] = local_vars.challenge;\n                } else if(common_data.columns_rotations[rotation_ind][j] == 1){\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_omega;\n                } else if(common_data.columns_rotations[rotation_ind][j] == -1) {\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_inversed_omega;\n                } else {\n                    uint256 omega;\n                    uint256 e;\n\n                    if (common_data.columns_rotations[rotation_ind][j] < 0) {\n                        omega = local_vars.inversed_omega;\n                        e = uint256(-common_data.columns_rotations[rotation_ind][j]);\n                    } else {\n                        omega = common_data.omega;\n                        e = uint256(common_data.columns_rotations[rotation_ind][j]);\n                    }\n                    // TODO check it!!!!\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\n                    assembly{\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\n                            if not(eq(and(e,1), 0)){\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\n                            }\n                            if not(eq(e, 1)){\n                                omega := mulmod(omega,omega, mload(fri_params))\n                            }\n                        }\n                    }\n                    local_vars.evaluation_points[0][eval_point_ind][j] = local_vars.e;\n                }\n                unchecked{j++;}\n            }\n            unchecked{i++;}\n        }\n\n        //  q_last and q_blind\n        for (uint256 i = (ar_params.permutation_columns << 1) + ar_params.constant_columns + ar_params.selector_columns;\n            i < fri_params.batches_sizes[3];\n        ) {\n            local_vars.evaluation_points[3][i] = challenge_point;\n            unchecked{i++;}\n        }\n\n        if( !batched_lpc_verifier.verify_proof_be(\n            blob,\n            proof_map.eval_proof_combined_value_offset,\n            local_vars.roots,\n            local_vars.evaluation_points,\n            tr_state,\n            fri_params\n        )){\n            return false;\n        }\n\n        // quotient\n        // 10. final check\n        local_vars.F = new uint256[](f_parts);\n        local_vars.F[0] = local_vars.permutation_argument[0];\n        local_vars.F[1] = local_vars.permutation_argument[1];\n        local_vars.F[2] = local_vars.permutation_argument[2];\n        local_vars.F[3] = 0;\n        local_vars.F[4] = 0;\n        local_vars.F[5] = 0;\n        local_vars.F[6] = 0;\n        local_vars.F[7] = 0;\n        local_vars.F[8] = local_vars.gate_argument;\n\n        local_vars.F_consolidated = 0;\n        for (uint256 i = 0; i < f_parts;) {\n            local_vars.F_consolidated = addmod(\n                local_vars.F_consolidated,\n                mulmod(local_vars.alphas[i], local_vars.F[i], fri_params.modulus),\n                fri_params.modulus\n            );\n            unchecked{ i++; }\n        }\n        local_vars.T_consolidated = 0;\n        local_vars.len = fri_params.batches_sizes[2];\n\n        for (uint256 i = 0; i < local_vars.len; i++) {\n            local_vars.zero_index = batched_lpc_verifier.get_quotient_z_i_j_from_proof_be(blob, proof_map.eval_proof_combined_value_offset, i, 0);\n            local_vars.e = field.expmod_static(local_vars.challenge, (fri_params.max_degree + 1) * i, fri_params.modulus);\n            //local_vars.zero_index = field.fmul(local_vars.zero_index, local_vars.e, fri_params.modulus);\n            //local_vars.T_consolidated  = field.fadd(local_vars.T_consolidated, local_vars.zero_index, fri_params.modulus);\n            assembly {\n                mstore(\n                    // local_vars.zero_index\n                    add(local_vars, ZERO_INDEX_OFFSET),\n                    // local_vars.zero_index * local_vars.e\n                    mulmod(\n                        // local_vars.zero_index\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\n                        // local_vars.e\n                        mload(add(local_vars, E_OFFSET)),\n                        // modulus\n                        mload(fri_params)\n                    )\n                )\n                mstore(\n                    // local_vars.T_consolidated\n                    add(local_vars, T_CONSOLIDATED_OFFSET),\n                    // local_vars.T_consolidated + local_vars.zero_index\n                    addmod(\n                        // local_vars.T_consolidated\n                        mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\n                        // local_vars.zero_index\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\n                        // modulus\n                        mload(fri_params)\n                    )\n                )\n            }\n        }\n        local_vars.Z_at_challenge = field.expmod_static(local_vars.challenge, common_data.rows_amount, fri_params.modulus);\n        //local_vars.Z_at_challenge = field.fsub(local_vars.Z_at_challenge, 1, fri_params.modulus);\n        //local_vars.Z_at_challenge = field.fmul(local_vars.Z_at_challenge, local_vars.T_consolidated, fri_params.modulus);\n        assembly {\n            mstore(\n                // local_vars.Z_at_challenge\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\n                // local_vars.Z_at_challenge - 1\n                addmod(\n                    // Z_at_challenge\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\n                    // -1\n                    sub(mload(fri_params), 1),\n                    // modulus\n                    mload(fri_params)\n                )\n            )\n            mstore(\n                // local_vars.Z_at_challenge\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\n                // Z_at_challenge * T_consolidated\n                mulmod(\n                    // Z_at_challenge\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\n                    // T_consolidated\n                    mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\n                    // modulus\n                    mload(fri_params)\n                )\n            )\n        }\n        if (local_vars.F_consolidated != local_vars.Z_at_challenge) {\n            return false;\n        }\n\n        return true;\n    }\n}"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/types.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\n//---------------------------------------------------------------------------//\n// Copyright (c) 2018-2021 Mikhail Komarov <nemo@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\n\npragma solidity >=0.8.4;\n\n/**\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\n * the precompiles add, scalar mul and pairing\n *\n * Notes on optimisations\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\n * inside the contract and not supplied by the user\n */\nlibrary types {\n    uint256 constant PROGRAM_WIDTH = 4;\n    uint256 constant NUM_NU_CHALLENGES = 11;\n\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\n\n    // TODO: add external_coset_generator() method to compute this\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\n\n    struct g1_point {\n        uint256 x;\n        uint256 y;\n    }\n\n    // G2 group element where x \\in Fq2 = x0 * z + x1\n    struct g2_point {\n        uint256 x0;\n        uint256 x1;\n        uint256 y0;\n        uint256 y1;\n    }\n\n    // N>B. Do not re-order these fields! They must appear in the same order as they\n    // appear in the proof data\n    struct proof {\n        g1_point W1;\n        g1_point W2;\n        g1_point W3;\n        g1_point W4;\n        g1_point Z;\n        g1_point T1;\n        g1_point T2;\n        g1_point T3;\n        g1_point T4;\n        uint256 w1;\n        uint256 w2;\n        uint256 w3;\n        uint256 w4;\n        uint256 sigma1;\n        uint256 sigma2;\n        uint256 sigma3;\n        uint256 q_arith;\n        uint256 q_ecc;\n        uint256 q_c;\n        uint256 linearization_polynomial;\n        uint256 grand_product_at_z_omega;\n        uint256 w1_omega;\n        uint256 w2_omega;\n        uint256 w3_omega;\n        uint256 w4_omega;\n        g1_point PI_Z;\n        g1_point PI_Z_OMEGA;\n        g1_point recursive_P1;\n        g1_point recursive_P2;\n        uint256 quotient_polynomial_eval;\n    }\n\n    struct challenge_transcript {\n        uint256 alpha_base;\n        uint256 alpha;\n        uint256 zeta;\n        uint256 beta;\n        uint256 gamma;\n        uint256 u;\n        uint256 v0;\n        uint256 v1;\n        uint256 v2;\n        uint256 v3;\n        uint256 v4;\n        uint256 v5;\n        uint256 v6;\n        uint256 v7;\n        uint256 v8;\n        uint256 v9;\n        uint256 v10;\n    }\n\n    struct verification_key {\n        uint256 circuit_size;\n        uint256 num_inputs;\n        uint256 work_root;\n        uint256 domain_inverse;\n        uint256 work_root_inverse;\n        g1_point Q1;\n        g1_point Q2;\n        g1_point Q3;\n        g1_point Q4;\n        g1_point Q5;\n        g1_point QM;\n        g1_point QC;\n        g1_point QARITH;\n        g1_point QECC;\n        g1_point QRANGE;\n        g1_point QLOGIC;\n        g1_point SIGMA1;\n        g1_point SIGMA2;\n        g1_point SIGMA3;\n        g1_point SIGMA4;\n        bool contains_recursive_proof;\n        uint256 recursive_proof_indices;\n        g2_point g2_x;\n\n        // zeta challenge raised to the power of the circuit size.\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\n        uint256 zeta_pow_n;\n    }\n    \n    struct transcript_data {\n        bytes32 current_challenge;\n    }\n\n    struct fri_params_type {\n        // 0x0\n        uint256 modulus;\n        // 0x20\n        uint256 r;\n        // 0x40\n        uint256 max_degree;\n        // 0x60\n        uint256 lambda;\n        // 0x80\n        uint256 omega;\n        // 0xa0\n        uint256[] D_omegas;\n        // 0xc0\n        uint256[] correct_order_idx;       // Ordered indices to pack ys to check merkle proof\n        // 0xe0\n        uint256[] step_list;\n        // 0x100\n        uint256[] q;\n\n        // 0x120\n        uint256[] s_indices;\n        uint256[] s;                    // Coset indices\n        uint256 max_step;       // variable for memory  initializing\n        uint256 max_batch;      // variable for memory  initializing\n\n        // These are local variables for FRI. But it's useful to allocate memory once\n        uint256[]    tmp_arr;\n        uint256[][]  evaluation_points;\n        uint256      z_offset;\n\n        // New fields\n        uint256       max_coset;\n        uint256       batches_num;\n        uint256[]     batches_sizes;\n        uint256       fri_proof_offset;         // fri_roots offset equals to fri_proof_offset + 0x20\n        uint256       fri_final_poly_offset;\n        uint256       fri_cur_query_offset;     // It'll be changed during verification process.\n                                                // It's set at the begining of the first query proof after parse functions running.\n        uint256       theta;\n        uint256       poly_num;\n        uint256[][]   combined_U;                // U polynomials for different evaluation points\n        uint256[][]   denominators;              // V polynomials for different evaluation points\n        uint256[]     factors;\n        uint256[]     eval_map;\n        uint256[][]   unique_eval_points;\n        uint256       different_points;\n        uint256[]     ys;\n        uint256[]     final_polynomial;         // It's loaded once while parsing fri proof\n        uint256[]     fri_roots;                // It should be bytes32\n    }\n\n    struct fri_state_type {\n        bytes   b;\n        //0x0\n        uint256 x_index;\n        //0x20\n        uint256 x;\n        //0x40\n        uint256 domain_size;\n        //0x60\n        uint256 domain_size_mod;\n        //0x80\n        uint256 newind;\n        //0xa0\n        uint256 p_ind;\n        //0xc0\n        uint256 y_ind;\n        //0xe0\n        uint256 indices_size;\n        //0x100\n        uint256 b_length;\n        //0x120\n        uint256 query_id;\n        //0x140\n        uint256[]     alphas;\n        uint256[] values;\n        uint256[] tmp_values;\n        uint256 coset_size;\n        uint256 offset;\n        uint256 root;\n        uint256 fri_root;\n        uint256 s;\n        uint256 step;\n        uint256 round;\n        uint256[] point;\n        uint256 cur;\n        uint256 interpolant;\n        uint256 f0;\n        uint256 f1;\n        uint256 factor;\n    }\n\n    struct placeholder_proof_map {\n        // 0x0\n        uint256 variable_values_commitment_offset;\n        // 0x20\n        uint256 v_perm_commitment_offset;\n        // 0x40\n        uint256 T_commitment_offset;\n        // 0x60\n        uint256 fixed_values_commitment_offset;\n        // 0x80\n        uint256 eval_proof_offset;\n        // 0xa0\n        uint256 eval_proof_lagrange_0_offset;\n        // 0xc0\n        uint256 eval_proof_combined_value_offset;\n    }\n\n    struct placeholder_common_data {\n        uint256 rows_amount;\n        // 0x20\n        uint256 omega;\n        int256[][] columns_rotations; \n    }\n\n    struct placeholder_state_type {\n        // 0x0\n        uint256 len;\n        // 0x20\n        uint256 offset;\n        // 0x40\n        uint256 zero_index;\n        // 0x60\n        uint256[] permutation_argument;\n        // 0x80\n        uint256 gate_argument;\n        // 0xa0\n        uint256[] alphas;\n        // 0xc0\n        uint256 challenge;\n        // 0xe0\n        uint256 e;\n        // 0x100\n        uint256[][][] evaluation_points;\n        // 0x120\n        uint256[] F;\n        // 0x140\n        uint256 F_consolidated;\n        // 0x160\n        uint256 T_consolidated;\n        // 0x180\n        uint256 Z_at_challenge;\n        // 0x1a0\n        uint256 beta;\n        // 0x1c0\n        uint256 gamma;\n        // 0x1e0\n        uint256 g;\n        // 0x200\n        uint256 h;\n        // 0x220\n        uint256 perm_polynomial_value;\n        // 0x240\n        uint256 perm_polynomial_shifted_value;\n        // 0x260\n        uint256 q_blind_eval;\n        // 0x280\n        uint256 q_last_eval;\n        // 0x2a0\n        uint256 S_id_i;\n        // 0x2c0\n        uint256 S_sigma_i;\n        // 0x2e0\n        uint256[] roots;\n        // 0x300\n        uint256 tmp1;\n        // 0x320\n        uint256 tmp2;\n        // 0x340\n        uint256 tmp3;\n        // 0x360\n        uint256 idx1;\n        // 0x380\n        uint256 idx2;\n        // 0x3a0\n        uint256 inversed_omega;\n    }\n\n    struct arithmetization_params{\n        uint256 witness_columns;\n        uint256 public_input_columns;\n        uint256 constant_columns;\n        uint256 selector_columns;\n        uint256 lookup_table_size;\n\n        // computed from other params\n        uint256 permutation_columns;\n    }\n\n    // parameters are sent to gate argument\n    struct gate_argument_params {\n        // 0x0\n        uint256 modulus;\n        // 0x20\n        uint256 theta;\n    }\n}\n"
    },
    "@nilfoundation/evm-placeholder-verification/contracts/verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0.\n//---------------------------------------------------------------------------//\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//---------------------------------------------------------------------------//\npragma solidity >=0.8.4;\n\nimport \"./types.sol\";\nimport \"./cryptography/transcript.sol\";\nimport \"./algebra/field.sol\";\n\nimport \"./placeholder/proof_map_parser.sol\";\nimport \"./placeholder/permutation_argument.sol\";\nimport \"./commitments/batched_lpc_verifier.sol\";\n\nimport \"./placeholder/verifier.sol\";\nimport \"./interfaces/verifier.sol\";\nimport \"./interfaces/gate_argument.sol\";\n\ncontract PlaceholderVerifier is IVerifier {\n    struct verifier_state {\n        uint256 proofs_num;\n        uint256 proof_offset;\n        uint256 proof_size;\n        uint256 ind;\n\n        types.fri_params_type           fri_params;\n        types.placeholder_proof_map     proof_map;\n        types.transcript_data           tr_state;\n        types.placeholder_common_data   common_data;\n        types.arithmetization_params    arithmetization_params;\n    }\n\n    function init_vars(\n        verifier_state memory vars, \n        uint256[] memory init_params, \n        int256[][] memory columns_rotations\n    ) internal pure {\n        uint256 idx;\n        uint256 max_coset;\n        uint256 i;\n\n        vars.fri_params.modulus = init_params[idx++];\n        vars.fri_params.r = init_params[idx++];\n        vars.fri_params.max_degree = init_params[idx++];\n        vars.fri_params.lambda = init_params[idx++];\n\n        vars.common_data.rows_amount = init_params[idx++];\n        vars.common_data.omega = init_params[idx++];\n        vars.common_data.columns_rotations = columns_rotations;\n\n        vars.fri_params.D_omegas = new uint256[](init_params[idx++]);\n        for (i = 0; i < vars.fri_params.D_omegas.length;) {\n            vars.fri_params.D_omegas[i] = init_params[idx];\n        unchecked{ i++; idx++;}\n        }\n\n        vars.fri_params.max_step = 0;\n        vars.fri_params.step_list = new uint256[](init_params[idx++]);\n        for (i = 0; i < vars.fri_params.step_list.length;) {\n            vars.fri_params.step_list[i] = init_params[idx];\n            if(vars.fri_params.step_list[i] > vars.fri_params.max_step)\n                vars.fri_params.max_step = vars.fri_params.step_list[i];\n            unchecked{ i++; idx++;}\n        }\n\n        unchecked{\n            idx++; // arithmetization_params length;\n            vars.arithmetization_params.witness_columns = init_params[idx++];\n            vars.arithmetization_params.public_input_columns = init_params[idx++];\n            vars.arithmetization_params.constant_columns = init_params[idx++];\n            vars.arithmetization_params.selector_columns = init_params[idx++];\n            vars.arithmetization_params.permutation_columns = vars.arithmetization_params.witness_columns \n                + vars.arithmetization_params.public_input_columns \n                + vars.arithmetization_params.constant_columns;\n        }\n\n        unchecked{ max_coset = 1 << (vars.fri_params.max_step - 1);}\n\n        vars.fri_params.max_coset = max_coset;\n        vars.fri_params.s_indices = new uint256[](max_coset);\n        vars.fri_params.correct_order_idx = new uint256[](max_coset);\n        vars.fri_params.tmp_arr = new uint256[](max_coset << 1);\n        vars.fri_params.s = new uint256[](max_coset);\n        vars.fri_params.batches_num = 4;\n        vars.fri_params.batches_sizes = new uint256[](vars.fri_params.batches_num);\n        vars.fri_params.batches_sizes[0] = vars.arithmetization_params.witness_columns + vars.arithmetization_params.public_input_columns;        \n        vars.fri_params.batches_sizes[1] = 1;\n            // TODO We don't know T_polynomials size. \n            // We'll extract it from proof in parse_be function \n            //      and verify fri_proof.query_proof[i].initial_proof[2].values have \n        vars.fri_params.batches_sizes[2] = 0; \n        vars.fri_params.batches_sizes[3] = vars.arithmetization_params.permutation_columns \n            + vars.arithmetization_params.permutation_columns\n            + vars.arithmetization_params.constant_columns \n            + vars.arithmetization_params.selector_columns + 2;\n    }\n\n    function check_public_input(verifier_state memory vars, uint256[] calldata public_input, bytes calldata blob) internal view {\n        uint256 xi = basic_marshalling.get_uint256_be(blob, vars.proof_map.eval_proof_offset);\n        uint256 result = 0;\n        uint256 Omega = 1;\n\n        for(uint256 i = 0; i < public_input.length;){\n            if( public_input[i] != 0){\n                uint256 L = mulmod(\n                    Omega,\n                    field.inverse_static(\n                        addmod(xi, vars.fri_params.modulus - Omega, vars.fri_params.modulus),\n                        vars.fri_params.modulus\n                    ),\n                    vars.fri_params.modulus\n                );\n                    \n                result = addmod(\n                    result, \n                    mulmod(\n                        public_input[i],\n                        L,\n                        vars.fri_params.modulus\n                    ), \n                    vars.fri_params.modulus\n                );\n            }\n            Omega = mulmod(Omega, vars.common_data.omega, vars.fri_params.modulus);\n            unchecked{i++;}\n        }\n        result = mulmod(\n            result, \n            addmod(field.pow_small(xi, vars.common_data.rows_amount, vars.fri_params.modulus), vars.fri_params.modulus - 1, vars.fri_params.modulus), \n            vars.fri_params.modulus\n        );\n        result = mulmod(result, field.inverse_static(vars.common_data.rows_amount, vars.fri_params.modulus), vars.fri_params.modulus);\n\n        // Input is proof_map.eval_proof_combined_value_offset\n        require( result == batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\n            blob, \n            vars.proof_map.eval_proof_combined_value_offset, \n            vars.arithmetization_params.witness_columns, \n            0\n        ));\n    }\n\n    function verify(\n        bytes calldata blob, \n        uint256[] calldata init_params,\n        int256[][] calldata columns_rotations, \n        uint256[] calldata public_input,\n        address gate_argument\n    ) public view returns (bool result) {\n        verifier_state memory vars;\n        init_vars(vars, init_params, columns_rotations);\n        transcript.init_transcript(vars.tr_state, hex\"\");\n        \n        (vars.proof_map, vars.proof_size) = placeholder_proof_map_parser.parse_be(blob, 0);\n        if(vars.proof_size != blob.length) return false;\n        (result, )= batched_lpc_verifier.parse_proof_be(vars.fri_params, blob, vars.proof_map.eval_proof_combined_value_offset);\n        if( !result ) return false;\n\n        types.placeholder_state_type memory local_vars;\n\n        // 3. append witness commitments to transcript\n        transcript.update_transcript_b32_by_offset_calldata(vars.tr_state, blob, basic_marshalling.skip_length(vars.proof_map.variable_values_commitment_offset));\n\n        // 2. check public input\n        //if(public_input.length > 0) check_public_input(vars, public_input, blob);\n\n        // 4. prepare evaluations of the polynomials that are copy-constrained\n        // 5. permutation argument\n        local_vars.permutation_argument = permutation_argument.verify_eval_be(blob, vars.tr_state,\n            vars.proof_map, vars.fri_params,\n            vars.common_data, local_vars, vars.arithmetization_params);\n\n        // 7. gate argument specific for circuit\n        types.gate_argument_params memory gate_params;\n        gate_params.modulus = vars.fri_params.modulus;\n        gate_params.theta = transcript.get_field_challenge(vars.tr_state, vars.fri_params.modulus);\n\n        IGateArgument gate_argument_component = IGateArgument(gate_argument);\n        local_vars.gate_argument = gate_argument_component.evaluate_gates_be(\n            blob, \n            vars.proof_map.eval_proof_combined_value_offset,  \n            gate_params,\n            vars.arithmetization_params,\n            vars.common_data.columns_rotations\n        );\n\n        if (!ProofVerifier.verify_proof_be(\n            blob, \n            vars.tr_state,\n            vars.proof_map, \n            vars.fri_params, vars.common_data, local_vars,\n            vars.arithmetization_params))\n            return false;\n        return true;\n    }\n}"
    },
    "contracts/Verifier.sol": {
      "content": "import \"@nilfoundation/evm-placeholder-verification/contracts/verifier.sol\";\n\ncontract Verifier is PlaceholderVerifier {\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}