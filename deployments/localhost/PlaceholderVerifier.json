{
  "address": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "blob",
          "type": "bytes"
        },
        {
          "internalType": "uint256[]",
          "name": "init_params",
          "type": "uint256[]"
        },
        {
          "internalType": "int256[][]",
          "name": "columns_rotations",
          "type": "int256[][]"
        },
        {
          "internalType": "uint256[]",
          "name": "public_input",
          "type": "uint256[]"
        },
        {
          "internalType": "address",
          "name": "gate_argument",
          "type": "address"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf62be6c00a7db56bb14529fdbc02b3828095567445a1b773a763d96682faca88",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0",
    "transactionIndex": 0,
    "gasUsed": "2303068",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x10ec64d2158d61d9037bda766ff61bb0c5ff34fdb7daba379b9ad3a76e26a05b",
    "transactionHash": "0xf62be6c00a7db56bb14529fdbc02b3828095567445a1b773a763d96682faca88",
    "logs": [],
    "blockNumber": 3,
    "cumulativeGasUsed": "2303068",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "07ba7a0caa89b8f722031ca835c75c0d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"blob\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"init_params\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[][]\",\"name\":\"columns_rotations\",\"type\":\"int256[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"public_input\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"gate_argument\",\"type\":\"address\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@nilfoundation/evm-placeholder-verification/contracts/verifier.sol\":\"PlaceholderVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@nilfoundation/evm-placeholder-verification/contracts/algebra/field.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary field {\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(uint256 base, uint256 exponent, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        result = 1;\\n        assembly {\\n            for {let count := 1}\\n            lt(count, add(exponent, 0x01))\\n            {count := shl(1, count)} {\\n                if and(exponent, count) {\\n                    result := mulmod(result, base, modulus)\\n                }\\n                base := mulmod(base, base, modulus)\\n            }\\n        }\\n    }\\n\\n    /// @dev Modular inverse of a (mod p) using euclid.\\n    /// 'a' and 'p' must be co-prime.\\n    /// @param a The number.\\n    /// @param p The mmodulus.\\n    /// @return x such that ax = 1 (mod p)\\n    function invmod(uint256 a, uint256 p)\\n    internal pure returns (uint256) {\\n        require(a != 0 && a != p && p != 0);\\n        if (a > p)\\n            a = a % p;\\n        int256 t1;\\n        int256 t2 = 1;\\n        uint256 r1 = p;\\n        uint256 r2 = a;\\n        uint256 q;\\n        while (r2 != 0) {\\n            q = r1 / r2;\\n            (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\\n        }\\n        if (t1 < 0)\\n            return (p - uint256(- t1));\\n        return uint256(t1);\\n    }\\n\\n    function fadd(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fsub(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, sub(modulus, b), modulus)\\n        }\\n    }\\n\\n    function fmul(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fdiv(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        uint256 b_inv = invmod(b, modulus);\\n        assembly {\\n            result := mulmod(a, b_inv, modulus)\\n        }\\n    }\\n\\n    // See https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\\n    function log2(uint256 x)\\n    internal pure returns (uint256 y){\\n        assembly {\\n            let arg := x\\n            x := sub(x, 1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(m, 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n            mstore(add(m, 0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n            mstore(add(m, 0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n            mstore(add(m, 0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n            mstore(add(m, 0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n            mstore(add(m, 0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n            mstore(add(m, 0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n            mstore(add(m, 0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n            mstore(0x40, add(m, 0x100))\\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m, sub(255, a))), shift)\\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n        }\\n    }\\n\\n    function expmod_static(uint256 base, uint256 exponent, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), base) // Base.\\n            mstore(add(p, 0x80), exponent) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function inverse_static(uint256 val, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        //        return expmod_static(val, modulus - 2, modulus); // code below similar to this call\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), val) // Base.\\n            mstore(add(p, 0x80), sub(modulus, 0x02)) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function double(uint256 val, uint256 modulus) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(2, val, modulus)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b080c1ab40776cc82b25e6b40f00e033085fd3c9d06f735775076232d66ec76\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/algebra/polynomial.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"./field.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\n/**\\n * @title Turbo Plonk polynomial evaluation\\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\\n *\\n * Expected to be inherited by `TurboPlonk.sol`\\n */\\nlibrary polynomial {\\n    uint256 constant LENGTH_OCTETS = 8;\\n\\n    function multiply_poly_on_coeff(uint256[] memory coeffs, uint256 mul, uint256 modulus)\\n    internal pure{\\n        for(uint256 i = 0; i < coeffs.length; i++){\\n            coeffs[i] = mulmod(coeffs[i], mul, modulus);\\n        }\\n    }\\n\\n    /*\\n      Computes the evaluation of a polynomial f(x) = sum(a_i * x^i) on the given point.\\n      The coefficients of the polynomial are given in\\n        a_0 = coefsStart[0], ..., a_{n-1} = coefsStart[n - 1]\\n      where n = nCoeffs = friLastLayerDegBound. Note that coefsStart is not actually an array but\\n      a direct pointer.\\n      The function requires that n is divisible by 8.\\n    */\\n    function evaluate(uint256[] memory coeffs, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        assembly {\\n            let cur_coefs := add(coeffs, mul(mload(coeffs), 0x20))\\n            for { } gt(cur_coefs, coeffs) {} {\\n                result := addmod(mulmod(result, point, modulus),\\n                                mload(cur_coefs), // (i - 1) * 32\\n                                modulus)\\n                cur_coefs := sub(cur_coefs, 0x20)\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function evaluate_by_ptr(bytes calldata blob, uint256 offset, uint256 len, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        for (uint256 i = len; i > 0;) {\\n            assembly {\\n                result := addmod(mulmod(result, point, modulus),\\n                                 calldataload(add(add(blob.offset, offset), shl(0x05, sub(i, 0x01)))), // (i - 1) * 32\\n                                 modulus)\\n            }\\n            unchecked{ i--; }\\n        }\\n//        assembly {\\n//            let i := sub(add(blob.offset, add(offset, mul(len, 0x20))), 0x20)\\n//            let coeff := sub(add(blob.offset, offset), 0x20)\\n//            for { } gt(coefsPtr, coeff) {} {\\n//                result := addmod(mulmod(result, point, modulus), calldataload(coefsPtr), modulus)\\n//                coefsPtr := sub(coefsPtr, 0x20)\\n//            }\\n//        }\\n        return result;\\n    }\\n\\n    function add_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        if (a.length < b.length) {\\n            result = new uint256[](b.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(b, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        } else {\\n            result = new uint256[](a.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(a, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        }\\n    }\\n\\n    function mul_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        result = new uint256[](a.length + b.length - 1);\\n        for (uint256 i = 0; i < b.length;) {\\n            for (uint256 j = 0; j < a.length;) {\\n                assembly {\\n                    mstore(add(add(result, 0x20), mul(add(j, i), 0x20)),\\n                           addmod(mload(add(add(result, 0x20), mul(add(j, i), 0x20))),\\n                                   mulmod(mload(add(add(a, 0x20), mul(j, 0x20))),\\n                                          mload(add(add(b, 0x20), mul(i, 0x20))), modulus),\\n                                   modulus)\\n                    )\\n                }\\n                unchecked{ j++; }\\n            }\\n            unchecked{ i++; }\\n        }\\n        return result;\\n    }\\n\\n    function lagrange_interpolation(\\n        uint256[] memory xs,\\n        uint256[] memory fxs,\\n        uint256 modulus\\n    ) internal pure returns (uint256[] memory result) {\\n        require(xs.length == fxs.length);\\n        uint256 len = fxs.length;\\n        for (uint256 i = 0; i < len;) {\\n            uint256[] memory thisPoly = new uint256[](1);\\n            thisPoly[0] = 1;\\n            for (uint256 j = 0; j < len;) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                uint256 denominator = field.fsub(xs[i], xs[j], modulus);\\n                uint256[] memory thisTerm = new uint256[](2);\\n                thisTerm[0] = field.fdiv(modulus - xs[j], denominator, modulus);\\n                thisTerm[1] = field.fdiv(uint256(1), denominator, modulus);\\n                thisPoly = mul_poly(thisPoly, thisTerm, modulus);\\n                unchecked{ j++; }\\n            }\\n            if (fxs.length + 1 >= i) {\\n                uint256[] memory multiple = new uint256[](1);\\n                multiple[0] = fxs[i];\\n                thisPoly = mul_poly(thisPoly, multiple, modulus);\\n            }\\n            result = add_poly(result, thisPoly, modulus);\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points_neg_x(uint256 x, uint256 dblXInv, uint256 fX, uint256 fMinusX,\\n                                                    uint256 evalPoint, uint256 modulus\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(\\n                mulmod(\\n                    mulmod(\\n                        addmod(fX, sub(modulus, fMinusX), modulus),\\n                        dblXInv,\\n                        modulus\\n                    ),\\n                    addmod(evalPoint, sub(modulus, x), modulus),\\n                    modulus\\n                ),\\n                fX,\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256 result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                mload(add(fx, 0x40)),\\n                sub(modulus, mload(add(fx, 0x20))),\\n                modulus\\n            )\\n            let x3_minus_x1 := addmod(\\n                eval_point,\\n                sub(modulus, mload(add(x, 0x20))),\\n                modulus\\n            )\\n            result := addmod(\\n                mulmod(\\n                    mulmod(y2_minus_y1, x2_minus_x1_inv, modulus),\\n                    x3_minus_x1,\\n                    modulus\\n                ),\\n                mload(add(fx, 0x20)),\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256) {\\n        if (x.length == 1 && fx.length == 1) {\\n            return fx[0];\\n        }\\n        if (x.length == 2) {\\n            return interpolate_evaluate_by_2_points(x, fx, eval_point, modulus);\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n        return 0;\\n    }\\n\\n    function interpolate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n        assembly {\\n            let y2_minus_y1 := addmod(mload(add(fx, 0x40)), sub(modulus, mload(add(fx, 0x20))), modulus)\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(modulus, mulmod(a, mload(add(x, 0x20)), modulus))\\n            let b := addmod(mload(add(fx, 0x20)), a_mul_x1_neg, modulus)\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && fx.length == 1) {\\n            result = new uint256[](1);\\n            result[0] = fx[0];\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(x, fx, modulus);\\n            return result;\\n        } else {\\n            require(false, \\\"unsupported number of points for interpolation\\\");\\n        }\\n    }\\n\\n    function interpolate_by_2_points(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(basic_marshalling.get_length(blob, fx_offset) == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                calldataload(\\n                    add(blob.offset, add(add(fx_offset, LENGTH_OCTETS), 0x20))\\n                ),\\n                sub(\\n                    modulus,\\n                    calldataload(\\n                        add(blob.offset, add(fx_offset, LENGTH_OCTETS))\\n                    )\\n                ),\\n                modulus\\n            )\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(\\n                modulus,\\n                mulmod(a, mload(add(x, 0x20)), modulus)\\n            )\\n            let b := addmod(\\n                calldataload(add(blob.offset, add(fx_offset, LENGTH_OCTETS))),\\n                a_mul_x1_neg,\\n                modulus\\n            )\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && basic_marshalling.get_length(blob, fx_offset) == 1) {\\n            result = new uint256[](1);\\n            result[0] = basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0);\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(blob, x, fx_offset, modulus);\\n            return result;\\n        } else if (x.length == 3) {\\n            uint256 y0 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0), field.fmul(field.fsub(x[0], x[1],modulus), field.fsub(x[0], x[2],modulus), modulus), modulus);\\n            uint256 y1 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 1), field.fmul(field.fsub(x[1], x[0],modulus), field.fsub(x[1], x[2],modulus), modulus), modulus);\\n            uint256 y2 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 2), field.fmul(field.fsub(x[2], x[0],modulus), field.fsub(x[2], x[1],modulus), modulus), modulus);\\n\\n            result = new uint256[](3);\\n            assembly {\\n                let x1 := mulmod(y0, mulmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus), modulus)\\n                let x2 := mulmod(y1, mulmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus), modulus)\\n                let x3 := mulmod(y2, mulmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus), modulus)\\n                mstore(add(result, 0x20), addmod(addmod(x1, x2, modulus), x3, modulus))\\n\\n                x1 := mulmod(y0, sub(modulus, addmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus)), modulus)\\n                x2 := mulmod(y1, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus)), modulus)\\n                x3 := mulmod(y2, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus)), modulus)\\n                mstore(add(result, 0x40), addmod(addmod(x1, x2, modulus), x3, modulus))\\n                mstore(add(result, 0x60), addmod(addmod(y0, y1, modulus), y2, modulus))\\n            }\\n            return result;\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x6d1a3ab64f2c88e343188f0fec990332e21f8062edf88a6ecf5ead6113d23329\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nlibrary basic_marshalling {\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n    uint256 constant LENGTH_OCTETS_ADD_32 = 40;\\n\\n    //================================================================================================================\\n    // Bounds non-checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n    }\\n\\n    function get_octet_vector_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(add(add(blob.offset, offset), LENGTH_OCTETS))\\n        }\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_uint256_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n    }\\n\\n    function skip_vector_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_v_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n    \\n    function skip_vv_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_v_of_vectors_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n\\n    function skip_length(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n    }\\n\\n    function get_skip_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_i_uint256_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20))))\\n        }\\n    }\\n\\n    function get_i_bytes32_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        assembly {\\n            result_ptr := add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_true(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n        unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector(blob, offset, j);\\n    }\\n\\n    function get_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n\\n    //================================================================================================================\\n    // Bounds checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be_check(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset < blob.length);\\n    }\\n\\n    function get_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        require(offset + LENGTH_OCTETS <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result_ptr := add(\\n                blob.offset,\\n                add(add(offset, LENGTH_OCTETS), mul(i, 0x20))\\n            )\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result){\\n        require(offset + 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4b8bda89ed07c52d7f8d59c4ed34475322d8478d087136eee6bc46efa43d964d\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_fri_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../containers/merkle_verifier.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\nlibrary batched_fri_verifier {\\n    uint256 constant FRI_PARAMS_COEFFS_OFFSET = 0x280;\\n\\n    uint256 constant S1_OFFSET = 0x00;                                      \\n    uint256 constant X_OFFSET = 0x20;                                      \\n    uint256 constant ALPHA_OFFSET = 0x40;                                   // alpha challenge\\n    uint256 constant COEFFS_OFFSET = 0x60;\\n    uint256 constant Y_OFFSET = 0x80;\\n    uint256 constant COLINEAR_OFFSET = 0xa0;                                // colinear_value_offset\\n    uint256 constant C1_OFFSET = 0xc0;                                      // coefficient1_offset\\n    uint256 constant C2_OFFSET = 0xe0;                                      // coefficient2_offset\\n    uint256 constant INTERPOLANT_OFFSET = 0x100;\\n    uint256 constant PREV_COEFFS_LEN_OFFSET = 0x120;\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = skip_query_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.step_list.length ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        fri_params.fri_roots = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.fri_roots[i] = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(result_offset));\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        fri_params.fri_final_poly_offset = result_offset;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n\\n        if( value_len > (( 1 << (field.log2(fri_params.max_degree + 1) - fri_params.r + 1) ) ) ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        fri_params.final_polynomial = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, result_offset);\\n            result_offset = basic_marshalling.skip_uint256_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        fri_params.fri_cur_query_offset = result_offset;\\n        if( value_len != fri_params.lambda ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        for (uint256 i = 0; i < value_len;) {\\n            (success, result_offset) = parse_query_proof_be(fri_params, blob, result_offset);\\n            if(!success) return(success, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_query_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_initial_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_round_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_query_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset){\\n        success = true;\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_initial_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( value_len != fri_params.step_list.length){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_round_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_initial_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        // coset_size\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_initial_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        uint256 len;\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != fri_params.batches_sizes[i] ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // coset_size\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != (1 << fri_params.step_list[0]) ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // values\\n        len = basic_marshalling.get_length(blob, result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        if(len != fri_params.batches_sizes[i] * (1 << fri_params.step_list[0])){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n    }\\n\\n    function skip_round_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_round_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        if( i < fri_params.step_list.length - 1){\\n            if( basic_marshalling.get_length(blob, result_offset) != (1 << fri_params.step_list[i+1]) ){\\n                success = false;\\n                return(success, result_offset);\\n            }\\n        }else{\\n            if( basic_marshalling.get_length(blob, result_offset) != 2 ){\\n                success = false;\\n                return( success, result_offset);\\n            }\\n        }\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns(uint256[] memory roots){\\n        roots = new uint256[](fri_params.batches_num);\\n        uint256 offset = fri_params.fri_cur_query_offset;\\n        offset = basic_marshalling.skip_length(offset);\\n        for( uint256 i = 0; i < fri_params.batches_num;){\\n            roots[i] = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n            offset = skip_initial_proof_be(blob, offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    // if x_index is index of x, then paired_index is index of -x\\n    function get_paired_index(uint256 x_index, uint256 domain_size)\\n    internal pure returns(uint256 result ){\\n        unchecked{ result = (x_index + (domain_size >> 1)) & (domain_size - 1); }\\n    }\\n\\n    // calculate indices for coset S = {s\\\\in D| s^(2^fri_step) == x_next}\\n    function get_folded_index(uint256 x_index, uint256 fri_step, uint256 domain_size_mod) \\n    internal pure returns(uint256 result){\\n        unchecked{result = x_index & (domain_size_mod >> fri_step);}\\n    }\\n  \\n    function calculate_s(\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars) internal pure{\\n\\n        fri_params.s[0] = local_vars.x;\\n        if( local_vars.coset_size > 1){\\n            uint256 base_index = local_vars.domain_size >> 2; \\n            uint256 prev_half_size = 1;\\n            uint256 i = 1;\\n            uint256 j;\\n            local_vars.newind = fri_params.D_omegas.length - 1;\\n            while( i < local_vars.coset_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n    }\\n\\n    function prepare_initial_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,\\n        uint256 k,                                              // current batch index\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[0] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[0], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 first_offset = 0x20;\\n        uint256 y_offset;\\n\\n        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        offset = basic_marshalling.skip_length(offset);             // Skip polynomial number\\n        offset = basic_marshalling.skip_length(offset);             // Skip coset size\\n        offset = basic_marshalling.skip_length(offset);             // Skip y length\\n        for (local_vars.p_ind = 0; local_vars.p_ind < fri_params.batches_sizes[k];) {\\n            for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n                local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n                // Check leaf size\\n                // Prepare y-s\\n                unchecked{ y_offset = offset + ( local_vars.newind << 6 ); }\\n\\n                // push y\\n                if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                    }\\n                } else {\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                    }\\n                }\\n                unchecked{ \\n                    local_vars.y_ind++; \\n                    first_offset += 0x40;\\n                }\\n            }\\n            unchecked{ offset += (1<<(fri_params.step_list[0]+5)); local_vars.p_ind++; }\\n        }\\n    }\\n\\n    // For round proofs\\n    //     Reorder local_vars.values and push to local_vars.b\\n    function prepare_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,                                         // round proof offset\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[local_vars.step] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[local_vars.step], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 y;\\n        offset = 0x20;\\n        for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n            local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n            // Check leaf size\\n            // Prepare y-s\\n\\n            // push y\\n            if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            } else {\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            }\\n            unchecked{ \\n                local_vars.y_ind++; \\n                offset += 0x40;\\n            }\\n        }\\n    }\\n\\n    function clear_values( uint256[] memory values )\\n    internal pure{\\n        for( uint256 i = 0; i < values.length;){\\n            values[i] = 0;\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function load_values( bytes calldata blob, uint256 offset, types.fri_state_type memory local_vars )\\n    internal pure{\\n        uint256 len;\\n        (len, offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( uint256 i = 0; i < len;){\\n            local_vars.values[i] = basic_marshalling.get_uint256_be(blob, offset);\\n            offset = basic_marshalling.skip_uint256_be(offset);\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob, \\n        uint256[] memory roots,\\n        types.transcript_data memory tr_state,\\n        types.fri_params_type memory fri_params\\n    ) internal view returns (bool result) {\\n        types.fri_state_type memory local_vars;\\n\\n        // TODO strange bug. If we we exchange two next lines, then it will not work.\\n        local_vars.alphas = new uint256[](fri_params.r);\\n        local_vars.b = new bytes(0x40 * fri_params.max_batch * fri_params.max_coset);\\n\\n        uint256 offset;\\n        uint256 ind;\\n        uint256 k;\\n        uint256 i;\\n\\n        offset = basic_marshalling.skip_length(fri_params.fri_proof_offset);\\n        offset = basic_marshalling.skip_length(offset);\\n        for( ind = 0; ind < fri_params.step_list.length;){\\n            transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, offset);\\n            for( uint256 round = 0; round < fri_params.step_list[ind];){\\n                local_vars.alphas[local_vars.cur] = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n                unchecked{ round++; local_vars.cur++;}\\n            }\\n            offset = basic_marshalling.skip_octet_vector_32_be(offset);\\n            unchecked{ind++;}\\n        }\\n\\n        for( local_vars.query_id = 0; local_vars.query_id < fri_params.lambda;){\\n            // It'll be init_vars function next\\n            unchecked{ local_vars.domain_size = 1 << (fri_params.D_omegas.length + 1); }\\n            unchecked{ local_vars.domain_size_mod = local_vars.domain_size - 1; }\\n            local_vars.x_index = transcript.get_integral_challenge_be(tr_state, 8) & local_vars.domain_size_mod;\\n            local_vars.x = field.expmod_static(\\n                fri_params.D_omegas[0],\\n                local_vars.x_index,\\n                fri_params.modulus\\n            );\\n\\n            // Check initial proofs\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                // Check merkle local_vars.roots\\n                local_vars.root = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n                if( local_vars.root != roots[k] ){\\n                    return false;\\n                }\\n                prepare_initial_leaf_data(blob, offset, k, fri_params, local_vars);\\n                local_vars.b_length = (fri_params.batches_sizes[k] << (fri_params.step_list[0] +5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n                offset = skip_initial_proof_be(blob, offset);\\n                // Check merkle proofs\\n                unchecked{k++;}\\n            }\\n\\n            // Construct ys for the first round\\n            local_vars.coset_size = 1 << fri_params.step_list[0];\\n            local_vars.values = new uint256[](1 << fri_params.max_step);\\n            local_vars.tmp_values = new uint256[](1 << fri_params.max_step);\\n\\n            for( ind = 0; ind < fri_params.different_points;){                \\n                offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                clear_values(local_vars.tmp_values);\\n                local_vars.cur = 0;\\n                for( k = 0; k < fri_params.batches_num;){\\n                    for( i = 0; i < fri_params.batches_sizes[k];){\\n                        polynomial.multiply_poly_on_coeff(local_vars.tmp_values,fri_params.theta, fri_params.modulus);\\n                        if( fri_params.eval_map[local_vars.cur] == ind ){\\n                            for( uint256 j = 0; j < local_vars.coset_size;){\\n                                local_vars.tmp_values[j] = addmod(\\n                                    local_vars.tmp_values[j], \\n                                    basic_marshalling.get_uint256_be(blob, offset),\\n                                    fri_params.modulus\\n                                );\\n                                offset = basic_marshalling.skip_uint256_be(offset);\\n                                unchecked{ j++; }\\n                            }\\n                        } else {\\n                            offset += (local_vars.coset_size << 5);\\n                        }\\n                        unchecked{ i++; local_vars.cur++;} \\n                    }\\n                    offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    unchecked{ k++; }\\n                }\\n\\n                for( uint256 j = 0; j < local_vars.coset_size; j++){\\n                    if( j & 1 == 0 )\\n                        { local_vars.s = fri_params.s[j>>1];}\\n                    else\\n                        { local_vars.s = fri_params.modulus - fri_params.s[j>>1];}\\n                    local_vars.tmp_values[j] = addmod(\\n                        mulmod( local_vars.tmp_values[j], fri_params.factors[ind], fri_params.modulus),\\n                        fri_params.modulus - polynomial.evaluate(fri_params.combined_U[ind], local_vars.s, fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                    // TODO Denominators for all s can be precomputed. It doesn't depend on polynomial.\\n                    local_vars.tmp_values[j] = mulmod(\\n                        local_vars.tmp_values[j],\\n                        field.inverse_static(\\n                            polynomial.evaluate(fri_params.denominators[ind], local_vars.s, fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        fri_params.modulus\\n                    );\\n                    local_vars.values[j] = addmod(local_vars.values[j], local_vars.tmp_values[j], fri_params.modulus);\\n                }\\n                unchecked{ind++;}\\n            }\\n\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num; ){\\n                offset = skip_initial_proof_be(blob, offset);\\n                unchecked{k++;}\\n            }\\n\\n            // Round proofs check\\n            local_vars.cur = 0;\\n            offset = basic_marshalling.skip_length(offset);\\n\\n            for( local_vars.step = 0; local_vars.step < fri_params.step_list.length;){\\n                // Merkle check;\\n                local_vars.fri_root = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(offset) + 0x8);\\n                if( local_vars.fri_root != fri_params.fri_roots[local_vars.step]) {\\n                    return false;\\n                }\\n\\n                local_vars.coset_size = 1 << fri_params.step_list[local_vars.step];\\n                prepare_leaf_data(blob, offset, fri_params, local_vars);\\n                local_vars.b_length = (1 << (fri_params.step_list[local_vars.step] + 5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n\\n                // Colinear check;\\n                local_vars.factor = 1;\\n                for( local_vars.round = 0; local_vars.round < fri_params.step_list[local_vars.step];){\\n                    local_vars.coset_size >>= 1;\\n                    calculate_s(fri_params, local_vars);\\n                    local_vars.domain_size >>= 1;\\n                    local_vars.domain_size_mod >>= 1;\\n                    local_vars.x_index &= local_vars.domain_size_mod;\\n                    local_vars.x = mulmod(local_vars.x, local_vars.x, fri_params.modulus);\\n                    if( local_vars.round == 0){\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, fri_params.modulus-local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            local_vars.values[j] = mulmod(\\n                                local_vars.values[j], \\n                                fri_params.s[j],\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    } else {\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, fri_params.modulus - local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    }\\n                    unchecked{local_vars.round++; local_vars.cur++;}\\n                }\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.interpolant = local_vars.values[0];\\n\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                load_values(blob, offset, local_vars);\\n                if( local_vars.interpolant != mulmod(local_vars.factor, local_vars.values[0], fri_params.modulus) ){\\n                    return false;\\n                }\\n                offset = basic_marshalling.skip_vector_of_uint256_be(blob, offset);\\n                unchecked{local_vars.step++;}\\n            }\\n\\n            // Final polynomial check. Final polynomial degree is already checked while parsing process\\n            if( polynomial.evaluate(fri_params.final_polynomial, local_vars.x, fri_params.modulus) != local_vars.values[0]){\\n                return false;\\n            }\\n            if( polynomial.evaluate(fri_params.final_polynomial, fri_params.modulus-local_vars.x, fri_params.modulus) != local_vars.values[1]){\\n                return false;\\n            }\\n            \\n            fri_params.fri_cur_query_offset = skip_query_proof_be(blob, fri_params.fri_cur_query_offset);\\n            unchecked{local_vars.query_id++;}\\n        }\\n        return true;\\n    }\\n}\",\"keccak256\":\"0xfd95c69c0d5359a10aaad33b60b1480a4e941b54d2749630149cdc56d08c901f\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_lpc_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022-2023 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"./batched_fri_verifier.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\nlibrary batched_lpc_verifier {\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 i;\\n        uint256 len;\\n        // z\\n        \\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( i = 0; i < len; ){\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        result_offset = batched_fri_verifier.skip_proof_be(blob, result_offset);\\n    }\\n\\n    // Check proof data carefully.\\n    // Load necessary offsets to fri params\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        uint256 len;\\n        // z\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return (success, result_offset);\\n        }\\n        for( uint256 i = 0; i < len; ){\\n            if( fri_params.batches_sizes[i] == 0 ){\\n                fri_params.batches_sizes[i] = basic_marshalling.get_length(blob, result_offset);\\n            } else {\\n                if( basic_marshalling.get_length(blob, result_offset) != fri_params.batches_sizes[i]){\\n                    success = false;\\n                    return (success, result_offset);\\n                }\\n            }\\n            fri_params.poly_num += fri_params.batches_sizes[i];\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        fri_params.fri_proof_offset = result_offset;\\n        (success, result_offset) = batched_fri_verifier.parse_proof_be(fri_params, blob, result_offset);\\n    }\\n\\n    // Input is proof_map.eval_proof_combined_value_offset\\n    function get_variable_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 vv_offset = basic_marshalling.skip_length(offset);\\n\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, vv_offset, i, j\\n        );\\n    }\\n\\n    function get_permutation_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 p_offset = basic_marshalling.skip_length(offset);\\n        \\n        p_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, p_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, p_offset, i, j\\n        );\\n    }\\n\\n    function get_quotient_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 q_offset = basic_marshalling.skip_length(offset);\\n        \\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, q_offset, i, j\\n        );\\n    }\\n\\n    // TODO add starting offsets of eval arrays to some kind of proof map\\n    function get_fixed_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 fv_offset = basic_marshalling.skip_length(offset);\\n        \\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, fv_offset, i, j\\n        );\\n    }\\n\\n    function eval_points_eq(uint256[] memory p1, uint256[] memory p2 )\\n    internal pure returns(bool eq){\\n        eq = true;\\n        if (p1.length != p2.length) return false;\\n        for(uint256 i = 0; i < p1.length;){\\n            if(p1[i] != p2[i]) return false;\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns (uint256[] memory roots){\\n        return batched_fri_verifier.extract_merkle_roots(blob, fri_params);\\n    }\\n\\n    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z, uint256 modulus)\\n    internal pure returns(uint256[2] memory U){\\n//        require( xi.length == 2 );\\n        U[0] = addmod(mulmod(z[0], xi[1], modulus),modulus - mulmod(z[1], xi[0], modulus), modulus);\\n        U[1] = addmod(z[1], modulus - z[0], modulus);\\n    }\\n\\n//  coeffs for zs on each degree can be precomputed if necessary\\n    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z, uint256 modulus)\\n    internal pure returns(uint256[3] memory U){\\n//        require( xi.length == 3 );\\n        z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);\\n        z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);\\n        z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);\\n\\n        U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob,\\n        uint256 offset, \\n        uint256[] memory roots,\\n        uint256[][][] memory evaluation_points,\\n        types.transcript_data memory tr_state, \\n        types.fri_params_type memory fri_params)\\n    internal view returns (bool result) {\\n        uint256 ind;\\n\\n        // Push all merkle roots to transcript\\n        for( ind = 0; ind < fri_params.batches_num;){\\n            transcript.update_transcript_b32(tr_state, bytes32(roots[ind]));\\n            unchecked{ind++;}\\n        }\\n        fri_params.theta = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n        fri_params.eval_map = new uint256[](fri_params.poly_num);\\n        fri_params.unique_eval_points = new uint256[][](fri_params.poly_num);\\n\\n        uint256 cur = 0;\\n        fri_params.different_points = 0;\\n        bool found = false;\\n        uint256[] memory point;\\n        uint256 k;\\n        uint256 i;        \\n\\n        // Prepare evaluation map;\\n        for( k = 0; k < fri_params.batches_num;){\\n            for( i = 0; i < fri_params.batches_sizes[k]; ){\\n                if( evaluation_points[k].length == 1 && i > 0){\\n                    fri_params.eval_map[cur] = fri_params.eval_map[cur - 1];\\n                } else {\\n                    point = evaluation_points[k][i];\\n                    // find this point\\n                    found = false;\\n                    for( ind = 0; ind < fri_params.different_points;){\\n                        if( eval_points_eq(point, fri_params.unique_eval_points[ind]) ){\\n                            found = true;\\n                            fri_params.eval_map[cur] = ind;\\n                            break;\\n                        }\\n                        unchecked{ind++;}\\n                    }\\n                    if(!found) {\\n                        fri_params.unique_eval_points[fri_params.different_points] = point;\\n                        fri_params.eval_map[cur] = fri_params.different_points;\\n                        unchecked{\\n                            fri_params.different_points++;\\n                        }\\n                    }   \\n                }\\n                unchecked{i++;cur++;}\\n            }\\n            unchecked{k++;}\\n        }\\n\\n        fri_params.denominators = new uint256[][](fri_params.different_points);\\n        fri_params.factors = new uint256[](fri_params.different_points);\\n\\n        // Prepare denominators\\n        for( ind = 0; ind < fri_params.different_points;){\\n            fri_params.denominators[ind] = new uint256[](fri_params.unique_eval_points[ind].length + 1);\\n            if( fri_params.unique_eval_points[ind].length == 1 ){\\n                fri_params.factors[ind] = 1;\\n                fri_params.denominators[ind][0] = fri_params.modulus - fri_params.unique_eval_points[ind][0];\\n                fri_params.denominators[ind][1] = 1;\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 2 ){\\n                // xi1 - xi0\\n                fri_params.factors[ind] = \\n                    addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus);\\n                fri_params.denominators[ind][2] = 1;\\n\\n                fri_params.denominators[ind][1] = \\n                    fri_params.modulus - addmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n\\n                fri_params.denominators[ind][0] = \\n                    mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 3 ){\\n                fri_params.factors[ind] = fri_params.modulus - \\n                    mulmod(\\n                        mulmod(\\n                            addmod(fri_params.unique_eval_points[ind][0], fri_params.modulus - fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                            addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        addmod(fri_params.unique_eval_points[ind][2], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][3] = 1;\\n                fri_params.denominators[ind][2] =\\n                    fri_params.modulus - addmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        addmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][1] = \\n                    addmod(\\n                        mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                        addmod(\\n                            mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            mulmod(fri_params.unique_eval_points[ind][1], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = \\n                    fri_params.modulus - mulmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        mulmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][3] = mulmod(fri_params.denominators[ind][3], fri_params.factors[ind], fri_params.modulus);\\n            } else {\\n                return false;\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n        // Prepare combined U\\n        fri_params.combined_U = new uint256[][](fri_params.different_points);\\n        for( ind = 0; ind < fri_params.different_points;){\\n            point = fri_params.unique_eval_points[ind];\\n            fri_params.combined_U[ind] = new uint256[](fri_params.unique_eval_points[ind].length);\\n            cur = 0;\\n            fri_params.z_offset = basic_marshalling.skip_length(offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                fri_params.z_offset = basic_marshalling.skip_length(fri_params.z_offset);\\n                for( i = 0; i < fri_params.batches_sizes[k];){                    \\n                    polynomial.multiply_poly_on_coeff(\\n                        fri_params.combined_U[ind], \\n                        fri_params.theta, \\n                        fri_params.modulus\\n                    );\\n                    if( fri_params.eval_map[cur] == ind ){\\n                        if( point.length == 1 ){\\n                            fri_params.combined_U[ind][0] = addmod(\\n                                fri_params.combined_U[ind][0],\\n                                basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0), \\n                                fri_params.modulus\\n                            );\\n                        } else \\n                        if( point.length == 2 ){\\n                            uint256[2] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp = calculate_2points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                        } else \\n                        if( point.length == 3){\\n                            uint256[3] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp[2] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 2);\\n                            tmp = calculate_3points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                            fri_params.combined_U[ind][2] = addmod(fri_params.combined_U[ind][2], tmp[2], fri_params.modulus);\\n                        } else {\\n                            return false;\\n                        }\\n                    } \\n                    fri_params.z_offset = basic_marshalling.skip_vector_of_uint256_be(blob, fri_params.z_offset);\\n                    unchecked{i++;cur++;}\\n                }\\n                unchecked{k++;}\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n\\n        if (!batched_fri_verifier.verify_proof_be(blob, roots, tr_state, fri_params)) {\\n            return false;\\n        }\\n        \\n        return true;\\n   }\\n} \",\"keccak256\":\"0xea655e8f167a8588e485b7e69c3635fd6799a37d74651b7c381d8df4b47dc6bf\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/containers/merkle_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\nlibrary merkle_verifier {\\n    // Merkle proof has the following structure:\\n    // [0:8] - leaf index\\n    // [8:16] - root length (which is always 32 bytes in current implementation)\\n    // [16:48] - root\\n    // [48:56] - merkle tree depth\\n    //\\n    // Depth number of layers with co-path elements follows then.\\n    // Each layer has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - number of co-path elements on the layer\\n    //  (layer_size = arity-1 actually, which (arity) is always 2 in current implementation)\\n    //\\n    // layer_size number of co-path elements for every layer in merkle proof follows then.\\n    // Each element has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - co-path element position on the layer\\n    // [8:16] - co-path element hash value length (which is always 32 bytes in current implementation)\\n    // [16:48] - co-path element hash value\\n    uint256 constant ROOT_OFFSET = 16;\\n    uint256 constant DEPTH_OFFSET = 48;\\n    uint256 constant LAYERS_OFFSET = 56;\\n    // only one co-element on each layer as arity is always 2\\n    // 8 + (number of co-path elements on the layer)\\n    // 8 + (co-path element position on the layer)\\n    // 8 + (co-path element hash value length)\\n    // 32 (co-path element hash value)\\n    uint256 constant LAYER_POSITION_OFFSET = 8;\\n    uint256 constant LAYER_COPATH_HASH_OFFSET = 24;\\n    uint256 constant LAYER_OCTETS = 56;\\n\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n\\n    function skip_merkle_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_merkle_proof_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        require(result_offset < blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length, \\\"skip_merkle_proof_be\\\");\\n    }\\n\\n    function parse_verify_merkle_proof_not_pre_hash_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n//        uint256 x = 0;\\n//        uint256 depth;\\n        assembly {\\n            let depth := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, add(offset, DEPTH_OFFSET))))\\n\\n            // save leaf hash data to required position\\n            let pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(\\n                        blob.offset,\\n                        add(add(offset, LAYERS_OFFSET), LAYER_POSITION_OFFSET)\\n                    )\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(0x20, verified_data)\\n            }\\n            case 1 {\\n                mstore(0x00, verified_data)\\n            }\\n\\n            let layer_offst := add(offset, LAYERS_OFFSET)\\n            let next_pos\\n            for {\\n                let cur_layer_i := 0\\n            } lt(cur_layer_i, sub(depth, 1)) {\\n                cur_layer_i := add(cur_layer_i, 1)\\n            } {\\n                pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_POSITION_OFFSET)\\n                        )\\n                    )\\n                )\\n                next_pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(\\n                                add(layer_offst, LAYER_POSITION_OFFSET),\\n                                LAYER_OCTETS\\n                            )\\n                        )\\n                    )\\n                )\\n//                x := add(x, pos)\\n//                x := mul(x, 10)\\n                switch pos\\n                case 0 {\\n                    mstore(\\n                        0x00,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                case 1 {\\n                    mstore(\\n                        0x20,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                layer_offst := add(layer_offst, LAYER_OCTETS)\\n            }\\n\\n            pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(blob.offset, add(layer_offst, LAYER_POSITION_OFFSET))\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(\\n                    0x00,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n            case 1 {\\n                mstore(\\n                    0x20,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n        }\\n\\n        bytes32 root;\\n        assembly {\\n            root := calldataload(add(blob.offset, add(offset, ROOT_OFFSET)))\\n        }\\n        result = (verified_data == root);\\n    }\\n    \\n    // We store merkle root as an octet vector. At first length==0x20 is stored.\\n    // We should skip it.\\n    // TODO: this function should return bytes32\\n    function get_merkle_root_from_blob(bytes calldata blob, uint256 merkle_root_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_root_offset, 0x8)))\\n        }\\n    }\\n\\n    // TODO: This function should return bytes32\\n    function get_merkle_root_from_proof(bytes calldata blob, uint256 merkle_proof_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_proof_offset, ROOT_OFFSET)))\\n        }\\n    }\\n\\n    function parse_verify_merkle_proof_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n        assembly {\\n            mstore(0, verified_data)\\n            verified_data := keccak256(0, 0x20)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data)\\n    internal pure returns (bool result) {\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, keccak256(verified_data));\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data_bytes,\\n                                                uint256 verified_data_bytes_len)\\n    internal pure returns (bool result) {\\n        bytes32 verified_data;\\n        assembly {\\n            verified_data := keccak256(add(verified_data_bytes, 0x20), verified_data_bytes_len)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n}\\n\",\"keccak256\":\"0x9495b7b9501fb77dc4e0c8e3a5af3544cb6fac48cc2deb2ec5030c991766b7f4\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/cryptography/transcript.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\n/**\\n * @title Transcript library\\n * @dev Generates Plonk random challenges\\n */\\nlibrary transcript {\\n    function init_transcript(types.transcript_data memory self, bytes memory init_blob)\\n    internal pure {\\n        self.current_challenge = keccak256(init_blob);\\n    }\\n\\n    function update_transcript(types.transcript_data memory self, bytes memory blob)\\n    internal pure {\\n        self.current_challenge = keccak256(bytes.concat(self.current_challenge, blob));\\n    }\\n\\n    function update_transcript_b32(types.transcript_data memory self, bytes32 blob)\\n    internal pure {\\n        self.current_challenge = keccak256(\\n            bytes.concat(self.current_challenge, blob)\\n        );\\n    }\\n\\n    function update_transcript_b32_by_offset(types.transcript_data memory self, bytes memory blob, uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := mload(add(add(blob, 0x20), offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function update_transcript_b32_by_offset_calldata(types.transcript_data memory self, bytes calldata blob,\\n                                                      uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := calldataload(add(blob.offset, offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function get_integral_challenge_be(types.transcript_data memory self, uint256 length)\\n    internal pure returns (uint256 result) {\\n        require(length <= 32);\\n        self.current_challenge = keccak256(abi.encodePacked(self.current_challenge));\\n        return (uint256(self.current_challenge) &\\n               (((uint256(1) << (length * 8)) - 1) << (uint256(256) - length * 8))) >> (uint256(256) - length * 8);\\n    }\\n\\n    function get_field_challenge(types.transcript_data memory self, uint256 modulus)\\n    internal pure returns (uint256) {\\n        self.current_challenge = keccak256(abi.encode(self.current_challenge));\\n        return uint256(self.current_challenge) % modulus;\\n    }\\n\\n    function get_field_challenges(types.transcript_data memory self, uint256[] memory challenges, uint256 modulus)\\n    internal pure {\\n        if (challenges.length > 0) {\\n            bytes32 new_challenge = self.current_challenge;\\n            for (uint256 i = 0; i < challenges.length;) {\\n                new_challenge = keccak256(abi.encode(new_challenge));\\n                challenges[i] = uint256(new_challenge) % modulus;\\n                unchecked{ i++; }\\n            }\\n            self.current_challenge = new_challenge;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe87be40233a78f3c08f5af77e7f0fe2e948eaaada4e84db08c94cf2cc1b60b78\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/interfaces/gate_argument.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\ninterface IGateArgument {\\n    function evaluate_gates_be(bytes calldata blob,\\n        uint256 eval_proof_combined_value_offset,\\n        types.gate_argument_params memory gate_params,\\n        types.arithmetization_params memory ar_params,\\n        int256[][] calldata columns_rotations\\n    ) external pure returns (uint256 gates_evaluation);\\n}\",\"keccak256\":\"0x86cef27f52fe03a046cd54fef8ffacd404568746a8acf9bb7b12d96b1250c2e1\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/interfaces/verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity ^0.8.0;\\n\\ninterface IVerifier {\\n    function verify(        \\n        bytes calldata blob,\\n        uint256[] calldata init_params,\\n        int256[][] calldata columns_rotations,\\n        uint256[] calldata public_input,\\n        address gate_argument\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6590affc453ea67b4c7e46acd0512c2b63873b2dd22ec67fdf34f61259772c4\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/permutation_argument.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"../commitments/batched_lpc_verifier.sol\\\";\\n\\nlibrary permutation_argument {\\n    uint256 constant ARGUMENT_SIZE = 3;\\n\\n    uint256 constant EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET = 0xa0;\\n\\n    uint256 constant LEN_OFFSET = 0x0;\\n    uint256 constant OFFSET_OFFSET = 0x20;\\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\\n    uint256 constant ALPHAS_OFFSET = 0xa0;\\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\\n    uint256 constant E_OFFSET = 0xe0;\\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\\n    uint256 constant F_OFFSET = 0x120;\\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\\n    uint256 constant BETA_OFFSET = 0x1a0;\\n    uint256 constant GAMMA_OFFSET = 0x1c0;\\n    uint256 constant G_OFFSET = 0x1e0;\\n    uint256 constant H_OFFSET = 0x200;\\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\\n    uint256 constant TMP1_OFFSET = 0x300;\\n    uint256 constant TMP2_OFFSET = 0x320;\\n    uint256 constant TMP3_OFFSET = 0x340;\\n    uint256 constant IDX1_OFFSET = 0x360;\\n    uint256 constant IDX2_OFFSET = 0x380;\\n    uint256 constant STATUS_OFFSET = 0x3a0;\\n\\n    function eval_permutations_at_challenge(\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_state_type memory local_vars,\\n        uint256 column_polynomials_values_i\\n    ) internal pure {\\n        assembly {\\n            let modulus := mload(fri_params)\\n            mstore(\\n                add(local_vars, G_OFFSET),\\n                mulmod(\\n                    mload(add(local_vars, G_OFFSET)),\\n                    // column_polynomials_values[i] + beta * S_id[i].evaluate(challenge) + gamma\\n                    addmod(\\n                        // column_polynomials_values[i]\\n                        column_polynomials_values_i,\\n                        // beta * S_id[i].evaluate(challenge) + gamma\\n                        addmod(\\n                            // beta * S_id[i].evaluate(challenge)\\n                            mulmod(\\n                                // beta\\n                                mload(add(local_vars, BETA_OFFSET)),\\n                                // S_id[i].evaluate(challenge)\\n                                mload(add(local_vars, S_ID_I_OFFSET)),\\n                                modulus\\n                            ),\\n                            // gamma\\n                            mload(add(local_vars, GAMMA_OFFSET)),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n            mstore(\\n                add(local_vars, H_OFFSET),\\n                mulmod(\\n                    mload(add(local_vars, H_OFFSET)),\\n                    // column_polynomials_values[i] + beta * S_sigma[i].evaluate(challenge) + gamma\\n                    addmod(\\n                        // column_polynomials_values[i]\\n                        column_polynomials_values_i,\\n                        // beta * S_sigma[i].evaluate(challenge) + gamma\\n                        addmod(\\n                            // beta * S_sigma[i].evaluate(challenge)\\n                            mulmod(\\n                                // beta\\n                                mload(add(local_vars, BETA_OFFSET)),\\n                                // S_sigma[i].evaluate(challenge)\\n                                mload(add(local_vars, S_SIGMA_I_OFFSET)),\\n                                modulus\\n                            ),\\n                            // gamma\\n                            mload(add(local_vars, GAMMA_OFFSET)),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n    }\\n\\n    function verify_eval_be(bytes calldata blob,\\n        types.transcript_data memory tr_state,\\n        types.placeholder_proof_map memory proof_map,\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_common_data memory common_data,\\n        types.placeholder_state_type memory local_vars,\\n        types.arithmetization_params memory ar_params\\n    ) internal pure returns (uint256[] memory F) {\\n        // 1. Get beta, gamma\\n        local_vars.beta = transcript.get_field_challenge(\\n            tr_state,\\n            fri_params.modulus\\n        );\\n        local_vars.gamma = transcript.get_field_challenge(\\n            tr_state,\\n            fri_params.modulus\\n        );\\n\\n        // 2. Add commitment to V_P to transcript\\n        transcript.update_transcript_b32_by_offset_calldata(\\n            tr_state,\\n            blob,\\n            proof_map.v_perm_commitment_offset + basic_marshalling.LENGTH_OCTETS\\n        );\\n\\n        // splash\\n        local_vars.len = ar_params.permutation_columns;\\n\\n        //require(\\n        //    batched_lpc_verifier.get_z_n_be(blob, proof_map.eval_proof_fixed_values_offset) == ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 2,\\n        //    \\\"Something wrong with number of fixed values polys\\\"\\n        //);\\n        local_vars.tmp1 = ar_params.witness_columns;\\n        local_vars.tmp2 = ar_params.public_input_columns;\\n        local_vars.tmp3 = ar_params.constant_columns;\\n\\n\\n        // 3. Calculate h_perm, g_perm at challenge pointa\\n        local_vars.g = 1;\\n        local_vars.h = 1;\\n        for (\\n            local_vars.idx1 = 0;\\n            local_vars.idx1 < local_vars.len;\\n            local_vars.idx1++\\n        ) {\\n            for (\\n                local_vars.idx2 = 0;\\n                local_vars.idx2 < common_data.columns_rotations[local_vars.idx1].length;\\n                local_vars.idx2++\\n            ) {\\n                if (common_data.columns_rotations[local_vars.idx1][local_vars.idx2] == 0 ) {\\n                    local_vars.zero_index = local_vars.idx2;\\n                }\\n            }\\n\\n            local_vars.S_id_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                blob,\\n                proof_map.eval_proof_combined_value_offset,\\n                local_vars.idx1,\\n                0\\n            );\\n\\n            // sigma_i\\n            local_vars.S_sigma_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                blob,\\n                proof_map.eval_proof_combined_value_offset,\\n                ar_params.permutation_columns + local_vars.idx1,\\n                0\\n            );\\n\\n            if (local_vars.idx1 < local_vars.tmp1) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // witnesses\\n                        local_vars.idx1,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            } else if (local_vars.idx1 < local_vars.tmp1 + local_vars.tmp2) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // public_input\\n                        local_vars.idx1,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            } else if ( local_vars.idx1 <  local_vars.tmp1 + local_vars.tmp2 + local_vars.tmp3 ) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // constant\\n                        local_vars.idx1 - local_vars.tmp1 - local_vars.tmp2 + ar_params.permutation_columns + ar_params.permutation_columns,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            }\\n        }\\n\\n        local_vars.perm_polynomial_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\\n            blob, proof_map.eval_proof_combined_value_offset, 0, 0\\n        );\\n        local_vars.perm_polynomial_shifted_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\\n            blob, proof_map.eval_proof_combined_value_offset, 0, 1\\n        );\\n\\n        local_vars.q_last_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n            blob, \\n            proof_map.eval_proof_combined_value_offset,       // special selector 0\\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns,\\n            0\\n        );\\n        local_vars.q_blind_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n            blob, \\n            proof_map.eval_proof_combined_value_offset,       // special selector 1\\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 1,\\n            0\\n        );\\n        F = new uint256[](ARGUMENT_SIZE);\\n        local_vars.challenge = basic_marshalling.get_uint256_be(\\n            blob,\\n            proof_map.eval_proof_offset\\n        );\\n        assembly {\\n            let modulus := mload(fri_params)\\n\\n            // F[0]\\n            mstore(\\n                add(F, 0x20),\\n                mulmod(\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            mload(\\n                                add(\\n                                    proof_map,\\n                                    EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET\\n                                )\\n                            )\\n                        )\\n                    ),\\n                    addmod(\\n                        1,\\n                        // one - perm_polynomial_value\\n                        sub(\\n                            modulus,\\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n        assembly{\\n            let modulus := mload(fri_params)\\n            // F[1]\\n            mstore(\\n                add(F, 0x40),\\n                // (one - preprocessed_data.q_last.evaluate(challenge) -\\n                //  preprocessed_data.q_blind.evaluate(challenge)) *\\n                //  (perm_polynomial_shifted_value * h - perm_polynomial_value * g)\\n                mulmod(\\n                    // one - preprocessed_data.q_last.evaluate(challenge) -\\n                    //  preprocessed_data.q_blind.evaluate(challenge)\\n                    addmod(\\n                        1,\\n                        // -preprocessed_data.q_last.evaluate(challenge) - preprocessed_data.q_blind.evaluate(challenge)\\n                        addmod(\\n                            // -preprocessed_data.q_last.evaluate(challenge)\\n                            sub(\\n                                modulus,\\n                                mload(add(local_vars, Q_LAST_EVAL_OFFSET))\\n                            ),\\n                            // -preprocessed_data.q_blind.evaluate(challenge)\\n                            sub(\\n                                modulus,\\n                                mload(add(local_vars, Q_BLIND_EVAL_OFFSET))\\n                            ),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    // perm_polynomial_shifted_value * h - perm_polynomial_value * g\\n                    addmod(\\n                        // perm_polynomial_shifted_value * h\\n                        mulmod(\\n                            // perm_polynomial_shifted_value\\n                            mload(\\n                                add(\\n                                    local_vars,\\n                                    PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET\\n                                )\\n                            ),\\n                            // h\\n                            mload(add(local_vars, H_OFFSET)),\\n                            modulus\\n                        ),\\n                        // - perm_polynomial_value * g\\n                        sub(\\n                            modulus,\\n                            mulmod(\\n                                // perm_polynomial_value\\n                                mload(\\n                                    add(\\n                                        local_vars,\\n                                        PERM_POLYNOMIAL_VALUE_OFFSET\\n                                    )\\n                                ),\\n                                // g\\n                                mload(add(local_vars, G_OFFSET)),\\n                                modulus\\n                            )\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n        assembly{\\n            let modulus := mload(fri_params)\\n            // F[2]\\n            mstore(\\n                add(F, 0x60),\\n                // preprocessed_data.q_last.evaluate(challenge) *\\n                //  (perm_polynomial_value.squared() - perm_polynomial_value)\\n                mulmod(\\n                    // preprocessed_data.q_last.evaluate(challenge)\\n                    mload(add(local_vars, Q_LAST_EVAL_OFFSET)),\\n                    // perm_polynomial_value.squared() - perm_polynomial_value\\n                    addmod(\\n                        // perm_polynomial_value.squared()\\n                        mulmod(\\n                            // perm_polynomial_value\\n                            mload(\\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\\n                            ),\\n                            // perm_polynomial_value\\n                            mload(\\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\\n                            ),\\n                            modulus\\n                        ),\\n                        // -perm_polynomial_value\\n                        sub(\\n                            modulus,\\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6185fabfe7b4cc9a00779f319f2d83fd6abaf31cc9dbf11ebdf232809034a051\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/proof_map_parser.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../commitments/batched_lpc_verifier.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\nlibrary placeholder_proof_map_parser {\\n    /**\\n     * Proof structure: https://github.com/NilFoundation/crypto3-zk-marshalling/blob/master/include/nil/crypto3/marshalling/zk/types/placeholder/proof.hpp\\n     */\\n    function parse_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (types.placeholder_proof_map memory proof_map, uint256 proof_size){\\n        proof_map.variable_values_commitment_offset = offset;\\n        proof_map.v_perm_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.variable_values_commitment_offset);\\n        proof_map.T_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.v_perm_commitment_offset);\\n        proof_map.fixed_values_commitment_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.T_commitment_offset);\\n        proof_map.eval_proof_offset = basic_marshalling.skip_octet_vector_32_be_check(blob, proof_map.fixed_values_commitment_offset);//challenge_offset\\n\\n        //require(false, logging.uint2decstr(basic_marshalling.get_uint256_be(blob, proof_map.eval_proof_offset)));\\n        // TODO: add data structures for lookups\\n\\n        proof_map.eval_proof_lagrange_0_offset = basic_marshalling.skip_uint256_be_check(blob, proof_map.eval_proof_offset); \\n        proof_map.eval_proof_combined_value_offset = basic_marshalling.skip_uint256_be_check(blob, proof_map.eval_proof_lagrange_0_offset);\\n        proof_size = batched_lpc_verifier.skip_proof_be(blob, proof_map.eval_proof_combined_value_offset);\\n    }\\n}\\n\",\"keccak256\":\"0x1b1496a05308963761199429aeeac7723175810e23b0b9a6dc21a3b9e17bced4\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"./permutation_argument.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\nimport \\\"../algebra/field.sol\\\";\\n\\nlibrary ProofVerifier {\\n    // TODO: check correctness all this const\\n    uint256 constant f_parts = 9;\\n\\n    uint256 constant OMEGA_OFFSET = 0x20;\\n\\n    uint256 constant LEN_OFFSET = 0x0;\\n    uint256 constant OFFSET_OFFSET = 0x20;\\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\\n    uint256 constant ALPHAS_OFFSET = 0xa0;\\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\\n    uint256 constant E_OFFSET = 0xe0;\\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\\n    uint256 constant F_OFFSET = 0x120;\\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\\n    uint256 constant BETA_OFFSET = 0x1a0;\\n    uint256 constant GAMMA_OFFSET = 0x1c0;\\n    uint256 constant G_OFFSET = 0x1e0;\\n    uint256 constant H_OFFSET = 0x200;\\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\\n    uint256 constant STATUS_OFFSET = 0x3a0;\\n\\n    function verify_proof_be(bytes calldata blob,\\n        types.transcript_data memory tr_state,\\n        types.placeholder_proof_map memory proof_map,\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_common_data memory common_data,\\n        types.placeholder_state_type memory local_vars,\\n        types.arithmetization_params memory ar_params\\n    ) external view returns (bool result) {\\n        // 8. alphas computations\\n        local_vars.alphas = new uint256[](f_parts);\\n        transcript.get_field_challenges(tr_state, local_vars.alphas, fri_params.modulus);\\n\\n        // 9. Evaluation proof check\\n        transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, basic_marshalling.skip_length(proof_map.T_commitment_offset));\\n        local_vars.challenge = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n        if (local_vars.challenge != basic_marshalling.get_uint256_be(blob, proof_map.eval_proof_offset)) {\\n            return false;\\n        }\\n\\n        // variable values\\n\\n        local_vars.inversed_omega = field.inverse_static(common_data.omega, fri_params.modulus);\\n        uint256 challenge_omega = field.fmul(local_vars.challenge, common_data.omega, fri_params.modulus);\\n        uint256 challenge_inversed_omega = field.fmul(local_vars.challenge, local_vars.inversed_omega, fri_params.modulus);\\n\\n        // TODO this should be bytes32\\n        local_vars.roots = new uint256[](fri_params.batches_num);\\n        local_vars.roots[0] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.variable_values_commitment_offset);\\n        local_vars.roots[1] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.v_perm_commitment_offset);\\n        local_vars.roots[2] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.T_commitment_offset);\\n        local_vars.roots[3] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.fixed_values_commitment_offset);\\n\\n        uint256[] memory challenge_point = new uint256[](1);\\n        challenge_point[0] = local_vars.challenge;\\n\\n        local_vars.evaluation_points = new uint256[][][](fri_params.batches_num);\\n        local_vars.evaluation_points[0] = new uint256[][](fri_params.batches_sizes[0]);\\n\\n        for (uint256 i = 0; i < ar_params.witness_columns + ar_params.public_input_columns;) {\\n            local_vars.evaluation_points[0][i] = new uint256[](common_data.columns_rotations[i].length);\\n            for (uint256 j = 0; j < common_data.columns_rotations[i].length;) {\\n                if(common_data.columns_rotations[i][j] == 0){\\n                    local_vars.evaluation_points[0][i][j] = local_vars.challenge;\\n                } else if(common_data.columns_rotations[i][j] == 1){\\n                    local_vars.evaluation_points[0][i][j] = challenge_omega;\\n                } else if(common_data.columns_rotations[i][j] == -1) {\\n                    local_vars.evaluation_points[0][i][j] = challenge_inversed_omega;\\n                } else {\\n                    uint256 omega;\\n                    uint256 e;\\n\\n                    if (common_data.columns_rotations[i][j] < 0) {\\n                        omega = local_vars.inversed_omega;\\n                        e = uint256(-common_data.columns_rotations[i][j]);\\n                    } else {\\n                        omega = common_data.omega;\\n                        e = uint256(common_data.columns_rotations[i][j]);\\n                    }\\n                    // TODO check it!!!!\\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\\n                    assembly{\\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\\n                            if not(eq(and(e,1), 0)){\\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\\n                            }\\n                            if not(eq(e, 1)){\\n                                omega := mulmod(omega,omega, mload(fri_params))\\n                            }\\n                        }\\n                    }\\n                    local_vars.evaluation_points[0][i][j] = local_vars.e;\\n                }\\n            unchecked{j++;}\\n            }\\n        unchecked{i++;}\\n        }\\n\\n        // For permutation polynomial\\n        local_vars.evaluation_points[1] = new uint256[][](1);\\n        local_vars.evaluation_points[1][0] = new uint256[](2);\\n        local_vars.evaluation_points[1][0][0] = local_vars.challenge;\\n        local_vars.evaluation_points[1][0][1] = challenge_omega;\\n\\n        local_vars.evaluation_points[2] = new uint256[][](1);\\n        local_vars.evaluation_points[2][0] = challenge_point;\\n\\n        local_vars.evaluation_points[3] = new uint256[][](fri_params.batches_sizes[3]);\\n        for (uint256 i = 0; i < (ar_params.permutation_columns << 1);) {\\n            local_vars.evaluation_points[3][i] = challenge_point;\\n            unchecked{i++;}\\n        }\\n\\n        // constant columns and selector columns may be rotated\\n        for( uint256 i = 0; i < ar_params.constant_columns + ar_params.selector_columns; ){\\n            uint256 eval_point_ind = i + (ar_params.permutation_columns << 1);\\n            uint256 rotation_ind = i + (ar_params.witness_columns + ar_params.public_input_columns);\\n            local_vars.evaluation_points[3][eval_point_ind] =\\n                new uint256[](common_data.columns_rotations[rotation_ind].length);\\n            for (uint256 j = 0; j < common_data.columns_rotations[rotation_ind].length;) {\\n                if(common_data.columns_rotations[rotation_ind][j] == 0){\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = local_vars.challenge;\\n                } else if(common_data.columns_rotations[rotation_ind][j] == 1){\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_omega;\\n                } else if(common_data.columns_rotations[rotation_ind][j] == -1) {\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_inversed_omega;\\n                } else {\\n                    uint256 omega;\\n                    uint256 e;\\n\\n                    if (common_data.columns_rotations[rotation_ind][j] < 0) {\\n                        omega = local_vars.inversed_omega;\\n                        e = uint256(-common_data.columns_rotations[rotation_ind][j]);\\n                    } else {\\n                        omega = common_data.omega;\\n                        e = uint256(common_data.columns_rotations[rotation_ind][j]);\\n                    }\\n                    // TODO check it!!!!\\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\\n                    assembly{\\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\\n                            if not(eq(and(e,1), 0)){\\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\\n                            }\\n                            if not(eq(e, 1)){\\n                                omega := mulmod(omega,omega, mload(fri_params))\\n                            }\\n                        }\\n                    }\\n                    local_vars.evaluation_points[0][eval_point_ind][j] = local_vars.e;\\n                }\\n                unchecked{j++;}\\n            }\\n            unchecked{i++;}\\n        }\\n\\n        //  q_last and q_blind\\n        for (uint256 i = (ar_params.permutation_columns << 1) + ar_params.constant_columns + ar_params.selector_columns;\\n            i < fri_params.batches_sizes[3];\\n        ) {\\n            local_vars.evaluation_points[3][i] = challenge_point;\\n            unchecked{i++;}\\n        }\\n\\n        if( !batched_lpc_verifier.verify_proof_be(\\n            blob,\\n            proof_map.eval_proof_combined_value_offset,\\n            local_vars.roots,\\n            local_vars.evaluation_points,\\n            tr_state,\\n            fri_params\\n        )){\\n            return false;\\n        }\\n\\n        // quotient\\n        // 10. final check\\n        local_vars.F = new uint256[](f_parts);\\n        local_vars.F[0] = local_vars.permutation_argument[0];\\n        local_vars.F[1] = local_vars.permutation_argument[1];\\n        local_vars.F[2] = local_vars.permutation_argument[2];\\n        local_vars.F[3] = 0;\\n        local_vars.F[4] = 0;\\n        local_vars.F[5] = 0;\\n        local_vars.F[6] = 0;\\n        local_vars.F[7] = 0;\\n        local_vars.F[8] = local_vars.gate_argument;\\n\\n        local_vars.F_consolidated = 0;\\n        for (uint256 i = 0; i < f_parts;) {\\n            local_vars.F_consolidated = addmod(\\n                local_vars.F_consolidated,\\n                mulmod(local_vars.alphas[i], local_vars.F[i], fri_params.modulus),\\n                fri_params.modulus\\n            );\\n            unchecked{ i++; }\\n        }\\n        local_vars.T_consolidated = 0;\\n        local_vars.len = fri_params.batches_sizes[2];\\n\\n        for (uint256 i = 0; i < local_vars.len; i++) {\\n            local_vars.zero_index = batched_lpc_verifier.get_quotient_z_i_j_from_proof_be(blob, proof_map.eval_proof_combined_value_offset, i, 0);\\n            local_vars.e = field.expmod_static(local_vars.challenge, (fri_params.max_degree + 1) * i, fri_params.modulus);\\n            //local_vars.zero_index = field.fmul(local_vars.zero_index, local_vars.e, fri_params.modulus);\\n            //local_vars.T_consolidated  = field.fadd(local_vars.T_consolidated, local_vars.zero_index, fri_params.modulus);\\n            assembly {\\n                mstore(\\n                    // local_vars.zero_index\\n                    add(local_vars, ZERO_INDEX_OFFSET),\\n                    // local_vars.zero_index * local_vars.e\\n                    mulmod(\\n                        // local_vars.zero_index\\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\\n                        // local_vars.e\\n                        mload(add(local_vars, E_OFFSET)),\\n                        // modulus\\n                        mload(fri_params)\\n                    )\\n                )\\n                mstore(\\n                    // local_vars.T_consolidated\\n                    add(local_vars, T_CONSOLIDATED_OFFSET),\\n                    // local_vars.T_consolidated + local_vars.zero_index\\n                    addmod(\\n                        // local_vars.T_consolidated\\n                        mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\\n                        // local_vars.zero_index\\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\\n                        // modulus\\n                        mload(fri_params)\\n                    )\\n                )\\n            }\\n        }\\n        local_vars.Z_at_challenge = field.expmod_static(local_vars.challenge, common_data.rows_amount, fri_params.modulus);\\n        //local_vars.Z_at_challenge = field.fsub(local_vars.Z_at_challenge, 1, fri_params.modulus);\\n        //local_vars.Z_at_challenge = field.fmul(local_vars.Z_at_challenge, local_vars.T_consolidated, fri_params.modulus);\\n        assembly {\\n            mstore(\\n                // local_vars.Z_at_challenge\\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\\n                // local_vars.Z_at_challenge - 1\\n                addmod(\\n                    // Z_at_challenge\\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\\n                    // -1\\n                    sub(mload(fri_params), 1),\\n                    // modulus\\n                    mload(fri_params)\\n                )\\n            )\\n            mstore(\\n                // local_vars.Z_at_challenge\\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\\n                // Z_at_challenge * T_consolidated\\n                mulmod(\\n                    // Z_at_challenge\\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\\n                    // T_consolidated\\n                    mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\\n                    // modulus\\n                    mload(fri_params)\\n                )\\n            )\\n        }\\n        if (local_vars.F_consolidated != local_vars.Z_at_challenge) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\",\"keccak256\":\"0xf0fc4c3e4d87dcb736d3aabb8a4d26d1a4f550d537cf0e2b0df4da1761f67647\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2018-2021 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct g1_point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct g2_point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct proof {\\n        g1_point W1;\\n        g1_point W2;\\n        g1_point W3;\\n        g1_point W4;\\n        g1_point Z;\\n        g1_point T1;\\n        g1_point T2;\\n        g1_point T3;\\n        g1_point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        g1_point PI_Z;\\n        g1_point PI_Z_OMEGA;\\n        g1_point recursive_P1;\\n        g1_point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct challenge_transcript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct verification_key {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        g1_point Q1;\\n        g1_point Q2;\\n        g1_point Q3;\\n        g1_point Q4;\\n        g1_point Q5;\\n        g1_point QM;\\n        g1_point QC;\\n        g1_point QARITH;\\n        g1_point QECC;\\n        g1_point QRANGE;\\n        g1_point QLOGIC;\\n        g1_point SIGMA1;\\n        g1_point SIGMA2;\\n        g1_point SIGMA3;\\n        g1_point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        g2_point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n    \\n    struct transcript_data {\\n        bytes32 current_challenge;\\n    }\\n\\n    struct fri_params_type {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 r;\\n        // 0x40\\n        uint256 max_degree;\\n        // 0x60\\n        uint256 lambda;\\n        // 0x80\\n        uint256 omega;\\n        // 0xa0\\n        uint256[] D_omegas;\\n        // 0xc0\\n        uint256[] correct_order_idx;       // Ordered indices to pack ys to check merkle proof\\n        // 0xe0\\n        uint256[] step_list;\\n        // 0x100\\n        uint256[] q;\\n\\n        // 0x120\\n        uint256[] s_indices;\\n        uint256[] s;                    // Coset indices\\n        uint256 max_step;       // variable for memory  initializing\\n        uint256 max_batch;      // variable for memory  initializing\\n\\n        // These are local variables for FRI. But it's useful to allocate memory once\\n        uint256[]    tmp_arr;\\n        uint256[][]  evaluation_points;\\n        uint256      z_offset;\\n\\n        // New fields\\n        uint256       max_coset;\\n        uint256       batches_num;\\n        uint256[]     batches_sizes;\\n        uint256       fri_proof_offset;         // fri_roots offset equals to fri_proof_offset + 0x20\\n        uint256       fri_final_poly_offset;\\n        uint256       fri_cur_query_offset;     // It'll be changed during verification process.\\n                                                // It's set at the begining of the first query proof after parse functions running.\\n        uint256       theta;\\n        uint256       poly_num;\\n        uint256[][]   combined_U;                // U polynomials for different evaluation points\\n        uint256[][]   denominators;              // V polynomials for different evaluation points\\n        uint256[]     factors;\\n        uint256[]     eval_map;\\n        uint256[][]   unique_eval_points;\\n        uint256       different_points;\\n        uint256[]     ys;\\n        uint256[]     final_polynomial;         // It's loaded once while parsing fri proof\\n        uint256[]     fri_roots;                // It should be bytes32\\n    }\\n\\n    struct fri_state_type {\\n        bytes   b;\\n        //0x0\\n        uint256 x_index;\\n        //0x20\\n        uint256 x;\\n        //0x40\\n        uint256 domain_size;\\n        //0x60\\n        uint256 domain_size_mod;\\n        //0x80\\n        uint256 newind;\\n        //0xa0\\n        uint256 p_ind;\\n        //0xc0\\n        uint256 y_ind;\\n        //0xe0\\n        uint256 indices_size;\\n        //0x100\\n        uint256 b_length;\\n        //0x120\\n        uint256 query_id;\\n        //0x140\\n        uint256[]     alphas;\\n        uint256[] values;\\n        uint256[] tmp_values;\\n        uint256 coset_size;\\n        uint256 offset;\\n        uint256 root;\\n        uint256 fri_root;\\n        uint256 s;\\n        uint256 step;\\n        uint256 round;\\n        uint256[] point;\\n        uint256 cur;\\n        uint256 interpolant;\\n        uint256 f0;\\n        uint256 f1;\\n        uint256 factor;\\n    }\\n\\n    struct placeholder_proof_map {\\n        // 0x0\\n        uint256 variable_values_commitment_offset;\\n        // 0x20\\n        uint256 v_perm_commitment_offset;\\n        // 0x40\\n        uint256 T_commitment_offset;\\n        // 0x60\\n        uint256 fixed_values_commitment_offset;\\n        // 0x80\\n        uint256 eval_proof_offset;\\n        // 0xa0\\n        uint256 eval_proof_lagrange_0_offset;\\n        // 0xc0\\n        uint256 eval_proof_combined_value_offset;\\n    }\\n\\n    struct placeholder_common_data {\\n        uint256 rows_amount;\\n        // 0x20\\n        uint256 omega;\\n        int256[][] columns_rotations; \\n    }\\n\\n    struct placeholder_state_type {\\n        // 0x0\\n        uint256 len;\\n        // 0x20\\n        uint256 offset;\\n        // 0x40\\n        uint256 zero_index;\\n        // 0x60\\n        uint256[] permutation_argument;\\n        // 0x80\\n        uint256 gate_argument;\\n        // 0xa0\\n        uint256[] alphas;\\n        // 0xc0\\n        uint256 challenge;\\n        // 0xe0\\n        uint256 e;\\n        // 0x100\\n        uint256[][][] evaluation_points;\\n        // 0x120\\n        uint256[] F;\\n        // 0x140\\n        uint256 F_consolidated;\\n        // 0x160\\n        uint256 T_consolidated;\\n        // 0x180\\n        uint256 Z_at_challenge;\\n        // 0x1a0\\n        uint256 beta;\\n        // 0x1c0\\n        uint256 gamma;\\n        // 0x1e0\\n        uint256 g;\\n        // 0x200\\n        uint256 h;\\n        // 0x220\\n        uint256 perm_polynomial_value;\\n        // 0x240\\n        uint256 perm_polynomial_shifted_value;\\n        // 0x260\\n        uint256 q_blind_eval;\\n        // 0x280\\n        uint256 q_last_eval;\\n        // 0x2a0\\n        uint256 S_id_i;\\n        // 0x2c0\\n        uint256 S_sigma_i;\\n        // 0x2e0\\n        uint256[] roots;\\n        // 0x300\\n        uint256 tmp1;\\n        // 0x320\\n        uint256 tmp2;\\n        // 0x340\\n        uint256 tmp3;\\n        // 0x360\\n        uint256 idx1;\\n        // 0x380\\n        uint256 idx2;\\n        // 0x3a0\\n        uint256 inversed_omega;\\n    }\\n\\n    struct arithmetization_params{\\n        uint256 witness_columns;\\n        uint256 public_input_columns;\\n        uint256 constant_columns;\\n        uint256 selector_columns;\\n        uint256 lookup_table_size;\\n\\n        // computed from other params\\n        uint256 permutation_columns;\\n    }\\n\\n    // parameters are sent to gate argument\\n    struct gate_argument_params {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 theta;\\n    }\\n}\\n\",\"keccak256\":\"0xcb25373de1222759842e237744b85bdbec1c00abd6bf7e3627269ad7d91b5c31\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"./types.sol\\\";\\nimport \\\"./cryptography/transcript.sol\\\";\\nimport \\\"./algebra/field.sol\\\";\\n\\nimport \\\"./placeholder/proof_map_parser.sol\\\";\\nimport \\\"./placeholder/permutation_argument.sol\\\";\\nimport \\\"./commitments/batched_lpc_verifier.sol\\\";\\n\\nimport \\\"./placeholder/verifier.sol\\\";\\nimport \\\"./interfaces/verifier.sol\\\";\\nimport \\\"./interfaces/gate_argument.sol\\\";\\n\\ncontract PlaceholderVerifier is IVerifier {\\n    struct verifier_state {\\n        uint256 proofs_num;\\n        uint256 proof_offset;\\n        uint256 proof_size;\\n        uint256 ind;\\n\\n        types.fri_params_type           fri_params;\\n        types.placeholder_proof_map     proof_map;\\n        types.transcript_data           tr_state;\\n        types.placeholder_common_data   common_data;\\n        types.arithmetization_params    arithmetization_params;\\n    }\\n\\n    function init_vars(\\n        verifier_state memory vars, \\n        uint256[] memory init_params, \\n        int256[][] memory columns_rotations\\n    ) internal pure {\\n        uint256 idx;\\n        uint256 max_coset;\\n        uint256 i;\\n\\n        vars.fri_params.modulus = init_params[idx++];\\n        vars.fri_params.r = init_params[idx++];\\n        vars.fri_params.max_degree = init_params[idx++];\\n        vars.fri_params.lambda = init_params[idx++];\\n\\n        vars.common_data.rows_amount = init_params[idx++];\\n        vars.common_data.omega = init_params[idx++];\\n        vars.common_data.columns_rotations = columns_rotations;\\n\\n        vars.fri_params.D_omegas = new uint256[](init_params[idx++]);\\n        for (i = 0; i < vars.fri_params.D_omegas.length;) {\\n            vars.fri_params.D_omegas[i] = init_params[idx];\\n        unchecked{ i++; idx++;}\\n        }\\n\\n        vars.fri_params.max_step = 0;\\n        vars.fri_params.step_list = new uint256[](init_params[idx++]);\\n        for (i = 0; i < vars.fri_params.step_list.length;) {\\n            vars.fri_params.step_list[i] = init_params[idx];\\n            if(vars.fri_params.step_list[i] > vars.fri_params.max_step)\\n                vars.fri_params.max_step = vars.fri_params.step_list[i];\\n            unchecked{ i++; idx++;}\\n        }\\n\\n        unchecked{\\n            idx++; // arithmetization_params length;\\n            vars.arithmetization_params.witness_columns = init_params[idx++];\\n            vars.arithmetization_params.public_input_columns = init_params[idx++];\\n            vars.arithmetization_params.constant_columns = init_params[idx++];\\n            vars.arithmetization_params.selector_columns = init_params[idx++];\\n            vars.arithmetization_params.permutation_columns = vars.arithmetization_params.witness_columns \\n                + vars.arithmetization_params.public_input_columns \\n                + vars.arithmetization_params.constant_columns;\\n        }\\n\\n        unchecked{ max_coset = 1 << (vars.fri_params.max_step - 1);}\\n\\n        vars.fri_params.max_coset = max_coset;\\n        vars.fri_params.s_indices = new uint256[](max_coset);\\n        vars.fri_params.correct_order_idx = new uint256[](max_coset);\\n        vars.fri_params.tmp_arr = new uint256[](max_coset << 1);\\n        vars.fri_params.s = new uint256[](max_coset);\\n        vars.fri_params.batches_num = 4;\\n        vars.fri_params.batches_sizes = new uint256[](vars.fri_params.batches_num);\\n        vars.fri_params.batches_sizes[0] = vars.arithmetization_params.witness_columns + vars.arithmetization_params.public_input_columns;        \\n        vars.fri_params.batches_sizes[1] = 1;\\n            // TODO We don't know T_polynomials size. \\n            // We'll extract it from proof in parse_be function \\n            //      and verify fri_proof.query_proof[i].initial_proof[2].values have \\n        vars.fri_params.batches_sizes[2] = 0; \\n        vars.fri_params.batches_sizes[3] = vars.arithmetization_params.permutation_columns \\n            + vars.arithmetization_params.permutation_columns\\n            + vars.arithmetization_params.constant_columns \\n            + vars.arithmetization_params.selector_columns + 2;\\n    }\\n\\n    function check_public_input(verifier_state memory vars, uint256[] calldata public_input, bytes calldata blob) internal view {\\n        uint256 xi = basic_marshalling.get_uint256_be(blob, vars.proof_map.eval_proof_offset);\\n        uint256 result = 0;\\n        uint256 Omega = 1;\\n\\n        for(uint256 i = 0; i < public_input.length;){\\n            if( public_input[i] != 0){\\n                uint256 L = mulmod(\\n                    Omega,\\n                    field.inverse_static(\\n                        addmod(xi, vars.fri_params.modulus - Omega, vars.fri_params.modulus),\\n                        vars.fri_params.modulus\\n                    ),\\n                    vars.fri_params.modulus\\n                );\\n                    \\n                result = addmod(\\n                    result, \\n                    mulmod(\\n                        public_input[i],\\n                        L,\\n                        vars.fri_params.modulus\\n                    ), \\n                    vars.fri_params.modulus\\n                );\\n            }\\n            Omega = mulmod(Omega, vars.common_data.omega, vars.fri_params.modulus);\\n            unchecked{i++;}\\n        }\\n        result = mulmod(\\n            result, \\n            addmod(field.pow_small(xi, vars.common_data.rows_amount, vars.fri_params.modulus), vars.fri_params.modulus - 1, vars.fri_params.modulus), \\n            vars.fri_params.modulus\\n        );\\n        result = mulmod(result, field.inverse_static(vars.common_data.rows_amount, vars.fri_params.modulus), vars.fri_params.modulus);\\n\\n        // Input is proof_map.eval_proof_combined_value_offset\\n        require( result == batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n            blob, \\n            vars.proof_map.eval_proof_combined_value_offset, \\n            vars.arithmetization_params.witness_columns, \\n            0\\n        ));\\n    }\\n\\n    function verify(\\n        bytes calldata blob, \\n        uint256[] calldata init_params,\\n        int256[][] calldata columns_rotations, \\n        uint256[] calldata public_input,\\n        address gate_argument\\n    ) public view returns (bool result) {\\n        verifier_state memory vars;\\n        init_vars(vars, init_params, columns_rotations);\\n        transcript.init_transcript(vars.tr_state, hex\\\"\\\");\\n        \\n        (vars.proof_map, vars.proof_size) = placeholder_proof_map_parser.parse_be(blob, 0);\\n        if(vars.proof_size != blob.length) return false;\\n        (result, )= batched_lpc_verifier.parse_proof_be(vars.fri_params, blob, vars.proof_map.eval_proof_combined_value_offset);\\n        if( !result ) return false;\\n\\n        types.placeholder_state_type memory local_vars;\\n\\n        // 3. append witness commitments to transcript\\n        transcript.update_transcript_b32_by_offset_calldata(vars.tr_state, blob, basic_marshalling.skip_length(vars.proof_map.variable_values_commitment_offset));\\n\\n        // 2. check public input\\n        //if(public_input.length > 0) check_public_input(vars, public_input, blob);\\n\\n        // 4. prepare evaluations of the polynomials that are copy-constrained\\n        // 5. permutation argument\\n        local_vars.permutation_argument = permutation_argument.verify_eval_be(blob, vars.tr_state,\\n            vars.proof_map, vars.fri_params,\\n            vars.common_data, local_vars, vars.arithmetization_params);\\n\\n        // 7. gate argument specific for circuit\\n        types.gate_argument_params memory gate_params;\\n        gate_params.modulus = vars.fri_params.modulus;\\n        gate_params.theta = transcript.get_field_challenge(vars.tr_state, vars.fri_params.modulus);\\n\\n        IGateArgument gate_argument_component = IGateArgument(gate_argument);\\n        local_vars.gate_argument = gate_argument_component.evaluate_gates_be(\\n            blob, \\n            vars.proof_map.eval_proof_combined_value_offset,  \\n            gate_params,\\n            vars.arithmetization_params,\\n            vars.common_data.columns_rotations\\n        );\\n\\n        if (!ProofVerifier.verify_proof_be(\\n            blob, \\n            vars.tr_state,\\n            vars.proof_map, \\n            vars.fri_params, vars.common_data, local_vars,\\n            vars.arithmetization_params))\\n            return false;\\n        return true;\\n    }\\n}\",\"keccak256\":\"0x9213152f828ca85d4d1c94d15e45b05e7940a224d60f994970fe479e43966776\",\"license\":\"Apache-2.0.\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506128b0806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c284622914610030575b600080fd5b61004361003e366004611dc2565b610057565b604051901515815260200160405180910390f35b6000610061611b76565b6100aa818a8a808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506100a592508b91508c9050611f29565b6103f7565b60c08101516040805160208101909152600090527fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47090526100ed8b8b6000610abb565b6040830181905260a08301919091528a1461010c5760009150506103ea565b61012481608001518c8c8460a0015160c00151610b8d565b509150816101365760009150506103ea565b610218604051806103c001604052806000815260200160008152602001600081526020016060815260200160008152602001606081526020016000815260200160008152602001606081526020016060815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6102398260c001518d8d6102348660a001516000015160080190565b610cbb565b61025e8c8c8460c001518560a0015186608001518760e0015187896101000151610dec565b6060820152604080518082019091526000808252602082015260808301805151825260c0840151905151610292919061121a565b8160200181815250506000859050806001600160a01b0316638009b83a8f8f8760a0015160c00151868961010001518a60e00151604001516040518763ffffffff1660e01b81526004016102eb9695949392919061201c565b602060405180830381865afa158015610308573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c9190612115565b83608001818152505073e7f1725E7734CE288F8367e1Bb143E90bb3F05126371f212b38f8f8760c001518860a0015189608001518a60e001518a8c61010001516040518963ffffffff1660e01b815260040161038f9897969594939291906126cd565b602060405180830381865af41580156103ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d091906127b4565b6103e15760009450505050506103ea565b60019450505050505b9998505050505050505050565b600080808481610406816127ec565b94508151811061041857610418612805565b60209081029190910101516080870151528483610434816127ec565b94508151811061044657610446612805565b602002602001015186608001516020018181525050848380610467906127ec565b94508151811061047957610479612805565b60209081029190910101516080870151604001528483610498816127ec565b9450815181106104aa576104aa612805565b602090810291909101015160808701516060015284836104c9816127ec565b9450815181106104db576104db612805565b602090810291909101015160e08701515284836104f7816127ec565b94508151811061050957610509612805565b60209081029190910181015160e08801805190920152516040018490528483610531816127ec565b94508151811061054357610543612805565b60200260200101516001600160401b0381111561056257610562611ec0565b60405190808252806020026020018201604052801561058b578160200160208202803683370190505b50608087015160a001525060005b856080015160a00151518110156105f5578483815181106105bc576105bc612805565b6020026020010151866080015160a0015182815181106105de576105de612805565b602090810291909101015260019283019201610599565b6080860151600061016090910152848361060e816127ec565b94508151811061062057610620612805565b60200260200101516001600160401b0381111561063f5761063f611ec0565b604051908082528060200260200182016040528015610668578160200160208202803683370190505b50608087015160e001525060005b856080015160e00151518110156107365784838151811061069957610699612805565b6020026020010151866080015160e0015182815181106106bb576106bb612805565b60200260200101818152505085608001516101600151866080015160e0015182815181106106eb576106eb612805565b6020026020010151111561072a57856080015160e00151818151811061071357610713612805565b602002602001015186608001516101600181815250505b60019283019201610676565b845160028401938691600190910190811061075357610753612805565b602090810291909101015161010087015152845160018401938691811061077c5761077c612805565b602002602001015186610100015160200181815250508483806001019450815181106107aa576107aa612805565b60209081029190910101516101008701516040015284516001840193869181106107d6576107d6612805565b60209081029190910181015161010088018051606001919091525160408101519181015181510190910160a09190910152608086015161016081015160016000199091011b6102009091018190529150816001600160401b0381111561083e5761083e611ec0565b604051908082528060200260200182016040528015610867578160200160208202803683370190505b5060808701516101200152816001600160401b0381111561088a5761088a611ec0565b6040519080825280602002602001820160405280156108b3578160200160208202803683370190505b50608087015160c00152600182901b6001600160401b038111156108d9576108d9611ec0565b604051908082528060200260200182016040528015610902578160200160208202803683370190505b5060808701516101a00152816001600160401b0381111561092557610925611ec0565b60405190808252806020026020018201604052801561094e578160200160208202803683370190505b5060808701805161014001919091528051600461022091820152905101516001600160401b0381111561098357610983611ec0565b6040519080825280602002602001820160405280156109ac578160200160208202803683370190505b5060808701516102400152610100860151602081015190516109ce919061281b565b866080015161024001516000815181106109ea576109ea612805565b602002602001018181525050600186608001516102400151600181518110610a1457610a14612805565b602002602001018181525050600086608001516102400151600281518110610a3e57610a3e612805565b60209081029190910101526101008601516060810151604082015160a090920151909190610a6c908061281b565b610a76919061281b565b610a80919061281b565b610a8b90600261281b565b86608001516102400151600381518110610aa757610aa7612805565b602002602001018181525050505050505050565b610afb6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8181526000610b0b858585611261565b60208301819052610b1f9086908690611261565b60408301819052610b339086908690611261565b60608301819052610b479086908690611261565b60808301819052610b5b9086908690611279565b60a08301819052610b6f9086908690611279565b60c08301819052610b83908690869061128a565b9050935093915050565b6102408401515160019060088301908584013560c01c908114610bb4576000925050610cb2565b60005b81811015610c96578761024001518181518110610bd657610bd6612805565b6020026020010151600003610c14578287013560c01c8861024001518281518110610c0357610c03612805565b602002602001018181525050610c4d565b8761024001518181518110610c2b57610c2b612805565b60209081029190910101518388013560c01c14610c4d57600093505050610cb2565b8761024001518181518110610c6457610c64612805565b6020026020010151886102e001818151610c7e919061281b565b905250610c8c8787856112cd565b9250600101610bb7565b506102608701829052610cab8787878561130e565b9093509150505b94509492505050565b818110610d2d5760405162461bcd60e51b815260206004820152603560248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a604482015274040decccce6cae8407840c4d8dec45cd8cadccee8d605b1b60648201526084015b60405180910390fd5b610d37818361282e565b60201115610dad5760405162461bcd60e51b815260206004820152603b60248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a60448201527f203332203c3d20626c6f622e6c656e677468202d206f666673657400000000006064820152608401610d24565b82810135610de58582815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b5050505050565b6060610dfc87866000015161121a565b6101a08401528451610e0f90889061121a565b836101c0018181525050610e30878a8a60088a60200151610234919061281b565b60a0820151835281516103008401526020820151610320840152604082015161034084015260016101e0840181905261020084015260006103608401525b825161036084015110156110925760006103808401525b836040015183610360015181518110610ea057610ea0612805565b6020026020010151518361038001511015610f2257836040015183610360015181518110610ed057610ed0612805565b602002602001015183610380015181518110610eee57610eee612805565b6020026020010151600003610f095761038083015160408401525b6103808301805190610f1a826127ec565b905250610e85565b610f3989898860c0015186610360015160006116cb565b6102a084015260c086015161036084015160a0840151610f68928c928c92610f61919061281b565b60006116cb565b6102c08401526103008301516103608401511015610fa957610fa48584610f9f8c8c8b60c001518961036001518a60400151611710565b61171c565b611079565b826103200151836103000151610fbf919061281b565b8361036001511015610fea57610fa48584610f9f8c8c8b60c001518961036001518a60400151611710565b826103400151836103200151846103000151611006919061281b565b611010919061281b565b8361036001511015611079576110798584610f9f8c8c8b60c001518860a001518960a001518b61032001518c61030001518d6103600151611051919061282e565b61105b919061282e565b611065919061281b565b61106f919061281b565b8a604001516116cb565b610360830180519061108a826127ec565b905250610e6e565b6110a489898860c00151600080611772565b61022084015260c08601516110c0908a908a9060006001611772565b8361024001818152505061110689898860c00151856060015186604001518760a001518860a001516110f2919061281b565b6110fc919061281b565b610f61919061281b565b8361028001818152505061115789898860c00151856060015186604001518760a001518860a00151611138919061281b565b611142919061281b565b61114c919061281b565b610f6190600161281b565b61026084015260408051600380825260808201909252906020820160608036833701905050608087015190915089013560c0840152845161022084015181908190810360010860a08901518c01350960208301525084518081826101e087015161022088015109830383610200880151610240890151090882836102608801518503610280890151860308600108096040830152508451610220840151819081908082039082908009086102808601510960608301525098975050505050505050565b81516040516000916112329160200190815260200190565b60408051601f198184030181529190528051602090910120808452611258908390612841565b90505b92915050565b602881018281111561127257600080fd5b9392505050565b602081018281111561127257600080fd5b6008810160008483013560c01c5b808210156112b8576112ab8686856112cd565b9250600190910190611298565b6112c386868561177e565b9695505050505050565b60088101828111156112de57600080fd5b8382013560c01c60005b81811015611305576112fb8686856117e3565b92506001016112e8565b50509392505050565b60e08401515160019060088301908584013560c01c908114611334576000925050610cb2565b806001600160401b0381111561134c5761134c611ec0565b604051908082528060200260200182016040528015611375578160200160208202803683370190505b5061040088015260005b818110156113be578287016008013588610400015182815181106113a5576113a5612805565b602090810291909101015260288301925060010161137f565b5050610280860181905260208601516040870151600883019287013560c01c91906115ac906113ee90600161281b565b604080517ff8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd81527ff5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe60208201527ff6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616818301527fc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff60608201527ff7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e60808201527fe39ed557db96902cd38ed14fad815115c786af479b7e8324736353433727170760a08201527fc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d236242260660c08201527f753a6d1b65325d0c552a4d1345224105391a310b29122104190a11030902010060e0820152610100808201909252600160f81b6001600160801b68010000000000000000640100000000620100006010600460026000198c019081041790810417908104178881041790810417908104179081041790810417017e818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff0281900460ff039091015104600160ff1b909211020190565b6115b6919061282e565b6115c190600161281b565b6001901b8111156115d6576000925050610cb2565b806001600160401b038111156115ee576115ee611ec0565b604051908082528060200260200182016040528015611617578160200160208202803683370190505b506103e088015260005b818110156116645782870135886103e00151828151811061164457611644612805565b60200260200101818152505061165a8360200190565b9250600101611621565b5050600881016102a087018190526060870151909186013560c01c908114611690576000925050610cb2565b60005b818110156116c0576116a7888888866117ff565b9094509250836116b8575050610cb2565b600101611693565b505094509492505050565b6000600884016116dc8787836118ac565b90506116e98787836118ac565b90506116f68787836118ac565b905061170587878387876118db565b979650505050505050565b600080600885016116f6565b82518081826101c0860151846102a08801516101a0890151090884086101e0850151096101e08401528081826101c0860151846102c08801516101a0890151090884086102008501510961020084015250505050565b600080600885016116e9565b600881018382013560c01c60005b818110156117a25760288301925060010161178c565b5060088286013560c01c60200283010191508482013560c01c600883019250905060005b81811015611305576117d9868685611919565b92506001016117c6565b60208382013560c01c0281016008018281111561127257600080fd5b6102408401515160019060088301908584013560c01c908114611826576000925050610cb2565b60005b818110156118575761183e8882898987611971565b90945092508361184f575050610cb2565b600101611829565b505060e086015151600882019186013560c01c90811461187b576000925050610cb2565b60005b818110156116c0576118938882898987611a82565b9094509250836118a4575050610cb2565b60010161187e565b600881018382013560c01c60005b818110156113055760088387013560c01c60200284010192506001016118ba565b600060088401935060005b838110156119075760088588013560c01c60200286010194506001016118e6565b506008602083028501870101356112c3565b600881018382013560c01c60005b818110156119445761193a868685611b2d565b9250600101611927565b5050600881019084013560c01c60005b8181101561130557611967868685611b5e565b9250600101611954565b610240850151805160019160408685016030013560c090811c60389081028701928301949289010135901c9190889081106119ae576119ae612805565b602002602001015181146119c6576000925050611a78565b5060e08701518051600883019287013560c01c91906000906119ea576119ea612805565b60200260200101516001901b8114611a06576000925050611a78565b5060e0870151805160088388013560c01c6020810290940101929190600090611a3157611a31612805565b60200260200101516001901b8861024001518881518110611a5457611a54612805565b6020026020010151611a669190612863565b8114611a76576000925050611a78565b505b9550959350505050565b6001600060386030848701013560c01c8102840101905060018760e0015151611aab919061282e565b861015611afb5760e0870151611ac287600161281b565b81518110611ad257611ad2612805565b60209081029190910101516001901b8186013560c01c14611af65760009150611a78565b611b12565b8085013560c01c600214611b125760009150611a78565b60088186013560c01c60200282010190509550959350505050565b60386030828501013560c01c02810160408101906048015b905060088482013560c01c602002820101949350505050565b600060386030838601013560c01c8102830101611b45565b60405180610120016040528060008152602001600081526020016000815260200160008152602001611c956040518061042001604052806000815260200160008152602001600081526020016000815260200160008152602001606081526020016060815260200160608152602001606081526020016060815260200160608152602001600081526020016000815260200160608152602001606081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016000815260200160008152602001600081526020016060815260200160608152602001606081526020016060815260200160608152602001600081526020016060815260200160608152602001606081525090565b8152602001611cda6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152604080516020818101909252600081529101908152602001611d1860405180606001604052806000815260200160008152602001606081525090565b8152602001611d566040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b60008083601f840112611d6d57600080fd5b5081356001600160401b03811115611d8457600080fd5b6020830191508360208260051b8501011115611d9f57600080fd5b9250929050565b80356001600160a01b0381168114611dbd57600080fd5b919050565b600080600080600080600080600060a08a8c031215611de057600080fd5b89356001600160401b0380821115611df757600080fd5b818c0191508c601f830112611e0b57600080fd5b813581811115611e1a57600080fd5b8d6020828501011115611e2c57600080fd5b60209283019b509950908b01359080821115611e4757600080fd5b611e538d838e01611d5b565b909950975060408c0135915080821115611e6c57600080fd5b611e788d838e01611d5b565b909750955060608c0135915080821115611e9157600080fd5b50611e9e8c828d01611d5b565b9094509250611eb1905060808b01611da6565b90509295985092959850929598565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715611efe57611efe611ec0565b604052919050565b60006001600160401b03821115611f1f57611f1f611ec0565b5060051b60200190565b6000611f3c611f3784611f06565b611ed6565b83815260208082019190600586811b860136811115611f5a57600080fd5b865b81811015611fe65780356001600160401b03811115611f7b5760008081fd5b880136601f820112611f8d5760008081fd5b8035611f9b611f3782611f06565b81815290851b82018601908681019036831115611fb85760008081fd5b928701925b82841015611fd657833582529287019290870190611fbd565b8952505050948301948301611f5c565b5092979650505050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000610160808352612031818401898b611ff3565b9050602087818501528651604085015280870151606085015261208c6080850187805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b838203610140850152845180835281830190600581901b840183018388016000805b8481101561210157878403601f19018652825180518086529088019088860190845b818110156120ec5783518352928a0192918a01916001016120d0565b505096880196945050918601916001016120ae565b50919e9d5050505050505050505050505050565b60006020828403121561212757600080fd5b5051919050565b600081518084526020808501945080840160005b8381101561215e57815187529582019590820190600101612142565b509495945050505050565b600081518084526020808501808196508360051b8101915082860160005b858110156121b157828403895261219f84835161212e565b98850198935090840190600101612187565b5091979650505050505050565b6000610420825184526020830151602085015260408301516040850152606083015160608501526080830151608085015260a08301518160a08601526122068286018261212e565b91505060c083015184820360c0860152612220828261212e565b91505060e083015184820360e086015261223a828261212e565b9150506101008084015185830382870152612255838261212e565b925050506101208084015185830382870152612271838261212e565b92505050610140808401518583038287015261228d838261212e565b925050506101608084015181860152506101808084015181860152506101a080840151858303828701526122c1838261212e565b925050506101c080840151858303828701526122dd8382612169565b925050506101e0808401518186015250610200808401518186015250610220808401518186015250610240808401518583038287015261231d838261212e565b610260868101519088015261028080870151908801526102a080870151908801526102c080870151908801526102e0808701519088015261030080870151888303828a0152919450925090506123738382612169565b92505050610320808401518583038287015261238f8382612169565b9250505061034080840151858303828701526123ab838261212e565b9250505061036080840151858303828701526123c7838261212e565b9250505061038080840151858303828701526123e38382612169565b925050506103a08084015181860152506103c0808401518583038287015261240b838261212e565b925050506103e08084015185830382870152612427838261212e565b9250505061040080840151858303828701526112c3838261212e565b600060608301825184526020808401518186015260408401516060604087015282815180855260808801915060808160051b890101945083830192506000805b828110156124d757898703607f19018452845180518089529087019087890190845b818110156124c1578351835292890192918901916001016124a5565b5090985050509385019392850192600101612483565b509498975050505050505050565b600081518084526020808501808196508360051b8101915082860160005b858110156121b157828403895261251b848351612169565b98850198935090840190600101612503565b60006103c082518452602083015160208501526040830151604085015260608301518160608601526125618286018261212e565b9150506080830151608085015260a083015184820360a0860152612585828261212e565b91505060c083015160c085015260e083015160e085015261010080840151858303828701526125b483826124e5565b9250505061012080840151858303828701526125d0838261212e565b6101408681015190880152610160808701519088015261018080870151908801526101a080870151908801526101c080870151908801526101e08087015190880152610200808701519088015261022080870151908801526102408087015190880152610260808701519088015261028080870151908801526102a080870151908801526102c080870151908801526102e080870151888303828a01529194509250905061267e838261212e565b610300868101519088015261032080870151908801526103408087015190880152610360808701519088015261038080870151908801526103a095860151959096019490945250929392505050565b60006102408083526126e28184018b8d611ff3565b905088516020840152875160408401526020880151606084015260408801516080840152606088015160a0840152608088015160c084015260a088015160e084015260c088015161010084015282810361012084015261274281886121be565b90508281036101408401526127578187612443565b905082810361016084015261276c818661252d565b845161018085015260208501516101a085015260408501516101c085015260608501516101e0850152608085015161020085015260a085015161022085015291506103ea9050565b6000602082840312156127c657600080fd5b8151801515811461127257600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016127fe576127fe6127d6565b5060010190565b634e487b7160e01b600052603260045260246000fd5b8082018082111561125b5761125b6127d6565b8181038181111561125b5761125b6127d6565b60008261285e57634e487b7160e01b600052601260045260246000fd5b500690565b808202811582820484141761125b5761125b6127d656fea2646970667358221220b127aa41596d3a4e8e9ce32d6d9ce23694062ce4c78e8bbd45801004a00643ce64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c8063c284622914610030575b600080fd5b61004361003e366004611dc2565b610057565b604051901515815260200160405180910390f35b6000610061611b76565b6100aa818a8a808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506100a592508b91508c9050611f29565b6103f7565b60c08101516040805160208101909152600090527fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a47090526100ed8b8b6000610abb565b6040830181905260a08301919091528a1461010c5760009150506103ea565b61012481608001518c8c8460a0015160c00151610b8d565b509150816101365760009150506103ea565b610218604051806103c001604052806000815260200160008152602001600081526020016060815260200160008152602001606081526020016000815260200160008152602001606081526020016060815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b6102398260c001518d8d6102348660a001516000015160080190565b610cbb565b61025e8c8c8460c001518560a0015186608001518760e0015187896101000151610dec565b6060820152604080518082019091526000808252602082015260808301805151825260c0840151905151610292919061121a565b8160200181815250506000859050806001600160a01b0316638009b83a8f8f8760a0015160c00151868961010001518a60e00151604001516040518763ffffffff1660e01b81526004016102eb9695949392919061201c565b602060405180830381865afa158015610308573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061032c9190612115565b83608001818152505073__$0e7306d99f8cf8edfbb6d44389b6e6fe56$__6371f212b38f8f8760c001518860a0015189608001518a60e001518a8c61010001516040518963ffffffff1660e01b815260040161038f9897969594939291906126cd565b602060405180830381865af41580156103ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103d091906127b4565b6103e15760009450505050506103ea565b60019450505050505b9998505050505050505050565b600080808481610406816127ec565b94508151811061041857610418612805565b60209081029190910101516080870151528483610434816127ec565b94508151811061044657610446612805565b602002602001015186608001516020018181525050848380610467906127ec565b94508151811061047957610479612805565b60209081029190910101516080870151604001528483610498816127ec565b9450815181106104aa576104aa612805565b602090810291909101015160808701516060015284836104c9816127ec565b9450815181106104db576104db612805565b602090810291909101015160e08701515284836104f7816127ec565b94508151811061050957610509612805565b60209081029190910181015160e08801805190920152516040018490528483610531816127ec565b94508151811061054357610543612805565b60200260200101516001600160401b0381111561056257610562611ec0565b60405190808252806020026020018201604052801561058b578160200160208202803683370190505b50608087015160a001525060005b856080015160a00151518110156105f5578483815181106105bc576105bc612805565b6020026020010151866080015160a0015182815181106105de576105de612805565b602090810291909101015260019283019201610599565b6080860151600061016090910152848361060e816127ec565b94508151811061062057610620612805565b60200260200101516001600160401b0381111561063f5761063f611ec0565b604051908082528060200260200182016040528015610668578160200160208202803683370190505b50608087015160e001525060005b856080015160e00151518110156107365784838151811061069957610699612805565b6020026020010151866080015160e0015182815181106106bb576106bb612805565b60200260200101818152505085608001516101600151866080015160e0015182815181106106eb576106eb612805565b6020026020010151111561072a57856080015160e00151818151811061071357610713612805565b602002602001015186608001516101600181815250505b60019283019201610676565b845160028401938691600190910190811061075357610753612805565b602090810291909101015161010087015152845160018401938691811061077c5761077c612805565b602002602001015186610100015160200181815250508483806001019450815181106107aa576107aa612805565b60209081029190910101516101008701516040015284516001840193869181106107d6576107d6612805565b60209081029190910181015161010088018051606001919091525160408101519181015181510190910160a09190910152608086015161016081015160016000199091011b6102009091018190529150816001600160401b0381111561083e5761083e611ec0565b604051908082528060200260200182016040528015610867578160200160208202803683370190505b5060808701516101200152816001600160401b0381111561088a5761088a611ec0565b6040519080825280602002602001820160405280156108b3578160200160208202803683370190505b50608087015160c00152600182901b6001600160401b038111156108d9576108d9611ec0565b604051908082528060200260200182016040528015610902578160200160208202803683370190505b5060808701516101a00152816001600160401b0381111561092557610925611ec0565b60405190808252806020026020018201604052801561094e578160200160208202803683370190505b5060808701805161014001919091528051600461022091820152905101516001600160401b0381111561098357610983611ec0565b6040519080825280602002602001820160405280156109ac578160200160208202803683370190505b5060808701516102400152610100860151602081015190516109ce919061281b565b866080015161024001516000815181106109ea576109ea612805565b602002602001018181525050600186608001516102400151600181518110610a1457610a14612805565b602002602001018181525050600086608001516102400151600281518110610a3e57610a3e612805565b60209081029190910101526101008601516060810151604082015160a090920151909190610a6c908061281b565b610a76919061281b565b610a80919061281b565b610a8b90600261281b565b86608001516102400151600381518110610aa757610aa7612805565b602002602001018181525050505050505050565b610afb6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8181526000610b0b858585611261565b60208301819052610b1f9086908690611261565b60408301819052610b339086908690611261565b60608301819052610b479086908690611261565b60808301819052610b5b9086908690611279565b60a08301819052610b6f9086908690611279565b60c08301819052610b83908690869061128a565b9050935093915050565b6102408401515160019060088301908584013560c01c908114610bb4576000925050610cb2565b60005b81811015610c96578761024001518181518110610bd657610bd6612805565b6020026020010151600003610c14578287013560c01c8861024001518281518110610c0357610c03612805565b602002602001018181525050610c4d565b8761024001518181518110610c2b57610c2b612805565b60209081029190910101518388013560c01c14610c4d57600093505050610cb2565b8761024001518181518110610c6457610c64612805565b6020026020010151886102e001818151610c7e919061281b565b905250610c8c8787856112cd565b9250600101610bb7565b506102608701829052610cab8787878561130e565b9093509150505b94509492505050565b818110610d2d5760405162461bcd60e51b815260206004820152603560248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a604482015274040decccce6cae8407840c4d8dec45cd8cadccee8d605b1b60648201526084015b60405180910390fd5b610d37818361282e565b60201115610dad5760405162461bcd60e51b815260206004820152603b60248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a60448201527f203332203c3d20626c6f622e6c656e677468202d206f666673657400000000006064820152608401610d24565b82810135610de58582815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b5050505050565b6060610dfc87866000015161121a565b6101a08401528451610e0f90889061121a565b836101c0018181525050610e30878a8a60088a60200151610234919061281b565b60a0820151835281516103008401526020820151610320840152604082015161034084015260016101e0840181905261020084015260006103608401525b825161036084015110156110925760006103808401525b836040015183610360015181518110610ea057610ea0612805565b6020026020010151518361038001511015610f2257836040015183610360015181518110610ed057610ed0612805565b602002602001015183610380015181518110610eee57610eee612805565b6020026020010151600003610f095761038083015160408401525b6103808301805190610f1a826127ec565b905250610e85565b610f3989898860c0015186610360015160006116cb565b6102a084015260c086015161036084015160a0840151610f68928c928c92610f61919061281b565b60006116cb565b6102c08401526103008301516103608401511015610fa957610fa48584610f9f8c8c8b60c001518961036001518a60400151611710565b61171c565b611079565b826103200151836103000151610fbf919061281b565b8361036001511015610fea57610fa48584610f9f8c8c8b60c001518961036001518a60400151611710565b826103400151836103200151846103000151611006919061281b565b611010919061281b565b8361036001511015611079576110798584610f9f8c8c8b60c001518860a001518960a001518b61032001518c61030001518d6103600151611051919061282e565b61105b919061282e565b611065919061281b565b61106f919061281b565b8a604001516116cb565b610360830180519061108a826127ec565b905250610e6e565b6110a489898860c00151600080611772565b61022084015260c08601516110c0908a908a9060006001611772565b8361024001818152505061110689898860c00151856060015186604001518760a001518860a001516110f2919061281b565b6110fc919061281b565b610f61919061281b565b8361028001818152505061115789898860c00151856060015186604001518760a001518860a00151611138919061281b565b611142919061281b565b61114c919061281b565b610f6190600161281b565b61026084015260408051600380825260808201909252906020820160608036833701905050608087015190915089013560c0840152845161022084015181908190810360010860a08901518c01350960208301525084518081826101e087015161022088015109830383610200880151610240890151090882836102608801518503610280890151860308600108096040830152508451610220840151819081908082039082908009086102808601510960608301525098975050505050505050565b81516040516000916112329160200190815260200190565b60408051601f198184030181529190528051602090910120808452611258908390612841565b90505b92915050565b602881018281111561127257600080fd5b9392505050565b602081018281111561127257600080fd5b6008810160008483013560c01c5b808210156112b8576112ab8686856112cd565b9250600190910190611298565b6112c386868561177e565b9695505050505050565b60088101828111156112de57600080fd5b8382013560c01c60005b81811015611305576112fb8686856117e3565b92506001016112e8565b50509392505050565b60e08401515160019060088301908584013560c01c908114611334576000925050610cb2565b806001600160401b0381111561134c5761134c611ec0565b604051908082528060200260200182016040528015611375578160200160208202803683370190505b5061040088015260005b818110156113be578287016008013588610400015182815181106113a5576113a5612805565b602090810291909101015260288301925060010161137f565b5050610280860181905260208601516040870151600883019287013560c01c91906115ac906113ee90600161281b565b604080517ff8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd81527ff5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe60208201527ff6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616818301527fc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff60608201527ff7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e60808201527fe39ed557db96902cd38ed14fad815115c786af479b7e8324736353433727170760a08201527fc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d236242260660c08201527f753a6d1b65325d0c552a4d1345224105391a310b29122104190a11030902010060e0820152610100808201909252600160f81b6001600160801b68010000000000000000640100000000620100006010600460026000198c019081041790810417908104178881041790810417908104179081041790810417017e818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff0281900460ff039091015104600160ff1b909211020190565b6115b6919061282e565b6115c190600161281b565b6001901b8111156115d6576000925050610cb2565b806001600160401b038111156115ee576115ee611ec0565b604051908082528060200260200182016040528015611617578160200160208202803683370190505b506103e088015260005b818110156116645782870135886103e00151828151811061164457611644612805565b60200260200101818152505061165a8360200190565b9250600101611621565b5050600881016102a087018190526060870151909186013560c01c908114611690576000925050610cb2565b60005b818110156116c0576116a7888888866117ff565b9094509250836116b8575050610cb2565b600101611693565b505094509492505050565b6000600884016116dc8787836118ac565b90506116e98787836118ac565b90506116f68787836118ac565b905061170587878387876118db565b979650505050505050565b600080600885016116f6565b82518081826101c0860151846102a08801516101a0890151090884086101e0850151096101e08401528081826101c0860151846102c08801516101a0890151090884086102008501510961020084015250505050565b600080600885016116e9565b600881018382013560c01c60005b818110156117a25760288301925060010161178c565b5060088286013560c01c60200283010191508482013560c01c600883019250905060005b81811015611305576117d9868685611919565b92506001016117c6565b60208382013560c01c0281016008018281111561127257600080fd5b6102408401515160019060088301908584013560c01c908114611826576000925050610cb2565b60005b818110156118575761183e8882898987611971565b90945092508361184f575050610cb2565b600101611829565b505060e086015151600882019186013560c01c90811461187b576000925050610cb2565b60005b818110156116c0576118938882898987611a82565b9094509250836118a4575050610cb2565b60010161187e565b600881018382013560c01c60005b818110156113055760088387013560c01c60200284010192506001016118ba565b600060088401935060005b838110156119075760088588013560c01c60200286010194506001016118e6565b506008602083028501870101356112c3565b600881018382013560c01c60005b818110156119445761193a868685611b2d565b9250600101611927565b5050600881019084013560c01c60005b8181101561130557611967868685611b5e565b9250600101611954565b610240850151805160019160408685016030013560c090811c60389081028701928301949289010135901c9190889081106119ae576119ae612805565b602002602001015181146119c6576000925050611a78565b5060e08701518051600883019287013560c01c91906000906119ea576119ea612805565b60200260200101516001901b8114611a06576000925050611a78565b5060e0870151805160088388013560c01c6020810290940101929190600090611a3157611a31612805565b60200260200101516001901b8861024001518881518110611a5457611a54612805565b6020026020010151611a669190612863565b8114611a76576000925050611a78565b505b9550959350505050565b6001600060386030848701013560c01c8102840101905060018760e0015151611aab919061282e565b861015611afb5760e0870151611ac287600161281b565b81518110611ad257611ad2612805565b60209081029190910101516001901b8186013560c01c14611af65760009150611a78565b611b12565b8085013560c01c600214611b125760009150611a78565b60088186013560c01c60200282010190509550959350505050565b60386030828501013560c01c02810160408101906048015b905060088482013560c01c602002820101949350505050565b600060386030838601013560c01c8102830101611b45565b60405180610120016040528060008152602001600081526020016000815260200160008152602001611c956040518061042001604052806000815260200160008152602001600081526020016000815260200160008152602001606081526020016060815260200160608152602001606081526020016060815260200160608152602001600081526020016000815260200160608152602001606081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016000815260200160008152602001600081526020016060815260200160608152602001606081526020016060815260200160608152602001600081526020016060815260200160608152602001606081525090565b8152602001611cda6040518060e00160405280600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b8152604080516020818101909252600081529101908152602001611d1860405180606001604052806000815260200160008152602001606081525090565b8152602001611d566040518060c001604052806000815260200160008152602001600081526020016000815260200160008152602001600081525090565b905290565b60008083601f840112611d6d57600080fd5b5081356001600160401b03811115611d8457600080fd5b6020830191508360208260051b8501011115611d9f57600080fd5b9250929050565b80356001600160a01b0381168114611dbd57600080fd5b919050565b600080600080600080600080600060a08a8c031215611de057600080fd5b89356001600160401b0380821115611df757600080fd5b818c0191508c601f830112611e0b57600080fd5b813581811115611e1a57600080fd5b8d6020828501011115611e2c57600080fd5b60209283019b509950908b01359080821115611e4757600080fd5b611e538d838e01611d5b565b909950975060408c0135915080821115611e6c57600080fd5b611e788d838e01611d5b565b909750955060608c0135915080821115611e9157600080fd5b50611e9e8c828d01611d5b565b9094509250611eb1905060808b01611da6565b90509295985092959850929598565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715611efe57611efe611ec0565b604052919050565b60006001600160401b03821115611f1f57611f1f611ec0565b5060051b60200190565b6000611f3c611f3784611f06565b611ed6565b83815260208082019190600586811b860136811115611f5a57600080fd5b865b81811015611fe65780356001600160401b03811115611f7b5760008081fd5b880136601f820112611f8d5760008081fd5b8035611f9b611f3782611f06565b81815290851b82018601908681019036831115611fb85760008081fd5b928701925b82841015611fd657833582529287019290870190611fbd565b8952505050948301948301611f5c565b5092979650505050505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6000610160808352612031818401898b611ff3565b9050602087818501528651604085015280870151606085015261208c6080850187805182526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a08301525050565b838203610140850152845180835281830190600581901b840183018388016000805b8481101561210157878403601f19018652825180518086529088019088860190845b818110156120ec5783518352928a0192918a01916001016120d0565b505096880196945050918601916001016120ae565b50919e9d5050505050505050505050505050565b60006020828403121561212757600080fd5b5051919050565b600081518084526020808501945080840160005b8381101561215e57815187529582019590820190600101612142565b509495945050505050565b600081518084526020808501808196508360051b8101915082860160005b858110156121b157828403895261219f84835161212e565b98850198935090840190600101612187565b5091979650505050505050565b6000610420825184526020830151602085015260408301516040850152606083015160608501526080830151608085015260a08301518160a08601526122068286018261212e565b91505060c083015184820360c0860152612220828261212e565b91505060e083015184820360e086015261223a828261212e565b9150506101008084015185830382870152612255838261212e565b925050506101208084015185830382870152612271838261212e565b92505050610140808401518583038287015261228d838261212e565b925050506101608084015181860152506101808084015181860152506101a080840151858303828701526122c1838261212e565b925050506101c080840151858303828701526122dd8382612169565b925050506101e0808401518186015250610200808401518186015250610220808401518186015250610240808401518583038287015261231d838261212e565b610260868101519088015261028080870151908801526102a080870151908801526102c080870151908801526102e0808701519088015261030080870151888303828a0152919450925090506123738382612169565b92505050610320808401518583038287015261238f8382612169565b9250505061034080840151858303828701526123ab838261212e565b9250505061036080840151858303828701526123c7838261212e565b9250505061038080840151858303828701526123e38382612169565b925050506103a08084015181860152506103c0808401518583038287015261240b838261212e565b925050506103e08084015185830382870152612427838261212e565b9250505061040080840151858303828701526112c3838261212e565b600060608301825184526020808401518186015260408401516060604087015282815180855260808801915060808160051b890101945083830192506000805b828110156124d757898703607f19018452845180518089529087019087890190845b818110156124c1578351835292890192918901916001016124a5565b5090985050509385019392850192600101612483565b509498975050505050505050565b600081518084526020808501808196508360051b8101915082860160005b858110156121b157828403895261251b848351612169565b98850198935090840190600101612503565b60006103c082518452602083015160208501526040830151604085015260608301518160608601526125618286018261212e565b9150506080830151608085015260a083015184820360a0860152612585828261212e565b91505060c083015160c085015260e083015160e085015261010080840151858303828701526125b483826124e5565b9250505061012080840151858303828701526125d0838261212e565b6101408681015190880152610160808701519088015261018080870151908801526101a080870151908801526101c080870151908801526101e08087015190880152610200808701519088015261022080870151908801526102408087015190880152610260808701519088015261028080870151908801526102a080870151908801526102c080870151908801526102e080870151888303828a01529194509250905061267e838261212e565b610300868101519088015261032080870151908801526103408087015190880152610360808701519088015261038080870151908801526103a095860151959096019490945250929392505050565b60006102408083526126e28184018b8d611ff3565b905088516020840152875160408401526020880151606084015260408801516080840152606088015160a0840152608088015160c084015260a088015160e084015260c088015161010084015282810361012084015261274281886121be565b90508281036101408401526127578187612443565b905082810361016084015261276c818661252d565b845161018085015260208501516101a085015260408501516101c085015260608501516101e0850152608085015161020085015260a085015161022085015291506103ea9050565b6000602082840312156127c657600080fd5b8151801515811461127257600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016127fe576127fe6127d6565b5060010190565b634e487b7160e01b600052603260045260246000fd5b8082018082111561125b5761125b6127d6565b8181038181111561125b5761125b6127d6565b60008261285e57634e487b7160e01b600052601260045260246000fd5b500690565b808202811582820484141761125b5761125b6127d656fea2646970667358221220b127aa41596d3a4e8e9ce32d6d9ce23694062ce4c78e8bbd45801004a00643ce64736f6c63430008130033",
  "libraries": {
    "ProofVerifier": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}