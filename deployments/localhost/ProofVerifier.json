{
  "address": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "blob",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "current_challenge",
              "type": "bytes32"
            }
          ],
          "internalType": "struct types.transcript_data",
          "name": "tr_state",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "variable_values_commitment_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "v_perm_commitment_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "T_commitment_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fixed_values_commitment_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "eval_proof_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "eval_proof_lagrange_0_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "eval_proof_combined_value_offset",
              "type": "uint256"
            }
          ],
          "internalType": "struct types.placeholder_proof_map",
          "name": "proof_map",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "modulus",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "r",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "max_degree",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lambda",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "omega",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "D_omegas",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "correct_order_idx",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "step_list",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "q",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "s_indices",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "s",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "max_step",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "max_batch",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "tmp_arr",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[][]",
              "name": "evaluation_points",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256",
              "name": "z_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "max_coset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "batches_num",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "batches_sizes",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "fri_proof_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fri_final_poly_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "fri_cur_query_offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "theta",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "poly_num",
              "type": "uint256"
            },
            {
              "internalType": "uint256[][]",
              "name": "combined_U",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256[][]",
              "name": "denominators",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256[]",
              "name": "factors",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "eval_map",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[][]",
              "name": "unique_eval_points",
              "type": "uint256[][]"
            },
            {
              "internalType": "uint256",
              "name": "different_points",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "ys",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "final_polynomial",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "fri_roots",
              "type": "uint256[]"
            }
          ],
          "internalType": "struct types.fri_params_type",
          "name": "fri_params",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "rows_amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "omega",
              "type": "uint256"
            },
            {
              "internalType": "int256[][]",
              "name": "columns_rotations",
              "type": "int256[][]"
            }
          ],
          "internalType": "struct types.placeholder_common_data",
          "name": "common_data",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "len",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "offset",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "zero_index",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "permutation_argument",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "gate_argument",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "alphas",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "challenge",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "e",
              "type": "uint256"
            },
            {
              "internalType": "uint256[][][]",
              "name": "evaluation_points",
              "type": "uint256[][][]"
            },
            {
              "internalType": "uint256[]",
              "name": "F",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "F_consolidated",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "T_consolidated",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "Z_at_challenge",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "beta",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gamma",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "g",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "h",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "perm_polynomial_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "perm_polynomial_shifted_value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "q_blind_eval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "q_last_eval",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "S_id_i",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "S_sigma_i",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "roots",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256",
              "name": "tmp1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tmp2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tmp3",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "idx1",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "idx2",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "inversed_omega",
              "type": "uint256"
            }
          ],
          "internalType": "struct types.placeholder_state_type",
          "name": "local_vars",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "witness_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "public_input_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "constant_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "selector_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lookup_table_size",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "permutation_columns",
              "type": "uint256"
            }
          ],
          "internalType": "struct types.arithmetization_params",
          "name": "ar_params",
          "type": "tuple"
        }
      ],
      "name": "verify_proof_be",
      "outputs": [
        {
          "internalType": "bool",
          "name": "result",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb8882c5c5e31911b9bf03c822dd5107239e939446aa96d9e4e9e7199387ad2af",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
    "transactionIndex": 0,
    "gasUsed": "5356507",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbfc4e9fa97bbd06a6e620fd9835ff95e1acdf8e252ca2799fcefa61bf37df0e8",
    "transactionHash": "0xb8882c5c5e31911b9bf03c822dd5107239e939446aa96d9e4e9e7199387ad2af",
    "logs": [],
    "blockNumber": 2,
    "cumulativeGasUsed": "5356507",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "07ba7a0caa89b8f722031ca835c75c0d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"blob\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"current_challenge\",\"type\":\"bytes32\"}],\"internalType\":\"struct types.transcript_data\",\"name\":\"tr_state\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"variable_values_commitment_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"v_perm_commitment_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"T_commitment_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fixed_values_commitment_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eval_proof_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eval_proof_lagrange_0_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eval_proof_combined_value_offset\",\"type\":\"uint256\"}],\"internalType\":\"struct types.placeholder_proof_map\",\"name\":\"proof_map\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"modulus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_degree\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lambda\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"omega\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"D_omegas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"correct_order_idx\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"step_list\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"q\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"s_indices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"s\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"max_step\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_batch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tmp_arr\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"evaluation_points\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256\",\"name\":\"z_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max_coset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batches_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"batches_sizes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"fri_proof_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fri_final_poly_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fri_cur_query_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poly_num\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"combined_U\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256[][]\",\"name\":\"denominators\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"factors\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"eval_map\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"unique_eval_points\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256\",\"name\":\"different_points\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ys\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"final_polynomial\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fri_roots\",\"type\":\"uint256[]\"}],\"internalType\":\"struct types.fri_params_type\",\"name\":\"fri_params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rows_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"omega\",\"type\":\"uint256\"},{\"internalType\":\"int256[][]\",\"name\":\"columns_rotations\",\"type\":\"int256[][]\"}],\"internalType\":\"struct types.placeholder_common_data\",\"name\":\"common_data\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"len\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zero_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"permutation_argument\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"gate_argument\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"alphas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"challenge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"e\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][][]\",\"name\":\"evaluation_points\",\"type\":\"uint256[][][]\"},{\"internalType\":\"uint256[]\",\"name\":\"F\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"F_consolidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"T_consolidated\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Z_at_challenge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"beta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gamma\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"g\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perm_polynomial_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perm_polynomial_shifted_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"q_blind_eval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"q_last_eval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"S_id_i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"S_sigma_i\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"roots\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"tmp1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tmp2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tmp3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idx1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idx2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inversed_omega\",\"type\":\"uint256\"}],\"internalType\":\"struct types.placeholder_state_type\",\"name\":\"local_vars\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"witness_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"public_input_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"constant_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selector_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lookup_table_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permutation_columns\",\"type\":\"uint256\"}],\"internalType\":\"struct types.arithmetization_params\",\"name\":\"ar_params\",\"type\":\"tuple\"}],\"name\":\"verify_proof_be\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/verifier.sol\":\"ProofVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@nilfoundation/evm-placeholder-verification/contracts/algebra/field.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary field {\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(uint256 base, uint256 exponent, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        result = 1;\\n        assembly {\\n            for {let count := 1}\\n            lt(count, add(exponent, 0x01))\\n            {count := shl(1, count)} {\\n                if and(exponent, count) {\\n                    result := mulmod(result, base, modulus)\\n                }\\n                base := mulmod(base, base, modulus)\\n            }\\n        }\\n    }\\n\\n    /// @dev Modular inverse of a (mod p) using euclid.\\n    /// 'a' and 'p' must be co-prime.\\n    /// @param a The number.\\n    /// @param p The mmodulus.\\n    /// @return x such that ax = 1 (mod p)\\n    function invmod(uint256 a, uint256 p)\\n    internal pure returns (uint256) {\\n        require(a != 0 && a != p && p != 0);\\n        if (a > p)\\n            a = a % p;\\n        int256 t1;\\n        int256 t2 = 1;\\n        uint256 r1 = p;\\n        uint256 r2 = a;\\n        uint256 q;\\n        while (r2 != 0) {\\n            q = r1 / r2;\\n            (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\\n        }\\n        if (t1 < 0)\\n            return (p - uint256(- t1));\\n        return uint256(t1);\\n    }\\n\\n    function fadd(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fsub(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, sub(modulus, b), modulus)\\n        }\\n    }\\n\\n    function fmul(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fdiv(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        uint256 b_inv = invmod(b, modulus);\\n        assembly {\\n            result := mulmod(a, b_inv, modulus)\\n        }\\n    }\\n\\n    // See https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\\n    function log2(uint256 x)\\n    internal pure returns (uint256 y){\\n        assembly {\\n            let arg := x\\n            x := sub(x, 1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(m, 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n            mstore(add(m, 0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n            mstore(add(m, 0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n            mstore(add(m, 0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n            mstore(add(m, 0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n            mstore(add(m, 0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n            mstore(add(m, 0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n            mstore(add(m, 0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n            mstore(0x40, add(m, 0x100))\\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m, sub(255, a))), shift)\\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n        }\\n    }\\n\\n    function expmod_static(uint256 base, uint256 exponent, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), base) // Base.\\n            mstore(add(p, 0x80), exponent) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function inverse_static(uint256 val, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        //        return expmod_static(val, modulus - 2, modulus); // code below similar to this call\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), val) // Base.\\n            mstore(add(p, 0x80), sub(modulus, 0x02)) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function double(uint256 val, uint256 modulus) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(2, val, modulus)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b080c1ab40776cc82b25e6b40f00e033085fd3c9d06f735775076232d66ec76\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/algebra/polynomial.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"./field.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\n/**\\n * @title Turbo Plonk polynomial evaluation\\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\\n *\\n * Expected to be inherited by `TurboPlonk.sol`\\n */\\nlibrary polynomial {\\n    uint256 constant LENGTH_OCTETS = 8;\\n\\n    function multiply_poly_on_coeff(uint256[] memory coeffs, uint256 mul, uint256 modulus)\\n    internal pure{\\n        for(uint256 i = 0; i < coeffs.length; i++){\\n            coeffs[i] = mulmod(coeffs[i], mul, modulus);\\n        }\\n    }\\n\\n    /*\\n      Computes the evaluation of a polynomial f(x) = sum(a_i * x^i) on the given point.\\n      The coefficients of the polynomial are given in\\n        a_0 = coefsStart[0], ..., a_{n-1} = coefsStart[n - 1]\\n      where n = nCoeffs = friLastLayerDegBound. Note that coefsStart is not actually an array but\\n      a direct pointer.\\n      The function requires that n is divisible by 8.\\n    */\\n    function evaluate(uint256[] memory coeffs, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        assembly {\\n            let cur_coefs := add(coeffs, mul(mload(coeffs), 0x20))\\n            for { } gt(cur_coefs, coeffs) {} {\\n                result := addmod(mulmod(result, point, modulus),\\n                                mload(cur_coefs), // (i - 1) * 32\\n                                modulus)\\n                cur_coefs := sub(cur_coefs, 0x20)\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function evaluate_by_ptr(bytes calldata blob, uint256 offset, uint256 len, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        for (uint256 i = len; i > 0;) {\\n            assembly {\\n                result := addmod(mulmod(result, point, modulus),\\n                                 calldataload(add(add(blob.offset, offset), shl(0x05, sub(i, 0x01)))), // (i - 1) * 32\\n                                 modulus)\\n            }\\n            unchecked{ i--; }\\n        }\\n//        assembly {\\n//            let i := sub(add(blob.offset, add(offset, mul(len, 0x20))), 0x20)\\n//            let coeff := sub(add(blob.offset, offset), 0x20)\\n//            for { } gt(coefsPtr, coeff) {} {\\n//                result := addmod(mulmod(result, point, modulus), calldataload(coefsPtr), modulus)\\n//                coefsPtr := sub(coefsPtr, 0x20)\\n//            }\\n//        }\\n        return result;\\n    }\\n\\n    function add_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        if (a.length < b.length) {\\n            result = new uint256[](b.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(b, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        } else {\\n            result = new uint256[](a.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(a, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        }\\n    }\\n\\n    function mul_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        result = new uint256[](a.length + b.length - 1);\\n        for (uint256 i = 0; i < b.length;) {\\n            for (uint256 j = 0; j < a.length;) {\\n                assembly {\\n                    mstore(add(add(result, 0x20), mul(add(j, i), 0x20)),\\n                           addmod(mload(add(add(result, 0x20), mul(add(j, i), 0x20))),\\n                                   mulmod(mload(add(add(a, 0x20), mul(j, 0x20))),\\n                                          mload(add(add(b, 0x20), mul(i, 0x20))), modulus),\\n                                   modulus)\\n                    )\\n                }\\n                unchecked{ j++; }\\n            }\\n            unchecked{ i++; }\\n        }\\n        return result;\\n    }\\n\\n    function lagrange_interpolation(\\n        uint256[] memory xs,\\n        uint256[] memory fxs,\\n        uint256 modulus\\n    ) internal pure returns (uint256[] memory result) {\\n        require(xs.length == fxs.length);\\n        uint256 len = fxs.length;\\n        for (uint256 i = 0; i < len;) {\\n            uint256[] memory thisPoly = new uint256[](1);\\n            thisPoly[0] = 1;\\n            for (uint256 j = 0; j < len;) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                uint256 denominator = field.fsub(xs[i], xs[j], modulus);\\n                uint256[] memory thisTerm = new uint256[](2);\\n                thisTerm[0] = field.fdiv(modulus - xs[j], denominator, modulus);\\n                thisTerm[1] = field.fdiv(uint256(1), denominator, modulus);\\n                thisPoly = mul_poly(thisPoly, thisTerm, modulus);\\n                unchecked{ j++; }\\n            }\\n            if (fxs.length + 1 >= i) {\\n                uint256[] memory multiple = new uint256[](1);\\n                multiple[0] = fxs[i];\\n                thisPoly = mul_poly(thisPoly, multiple, modulus);\\n            }\\n            result = add_poly(result, thisPoly, modulus);\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points_neg_x(uint256 x, uint256 dblXInv, uint256 fX, uint256 fMinusX,\\n                                                    uint256 evalPoint, uint256 modulus\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(\\n                mulmod(\\n                    mulmod(\\n                        addmod(fX, sub(modulus, fMinusX), modulus),\\n                        dblXInv,\\n                        modulus\\n                    ),\\n                    addmod(evalPoint, sub(modulus, x), modulus),\\n                    modulus\\n                ),\\n                fX,\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256 result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                mload(add(fx, 0x40)),\\n                sub(modulus, mload(add(fx, 0x20))),\\n                modulus\\n            )\\n            let x3_minus_x1 := addmod(\\n                eval_point,\\n                sub(modulus, mload(add(x, 0x20))),\\n                modulus\\n            )\\n            result := addmod(\\n                mulmod(\\n                    mulmod(y2_minus_y1, x2_minus_x1_inv, modulus),\\n                    x3_minus_x1,\\n                    modulus\\n                ),\\n                mload(add(fx, 0x20)),\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256) {\\n        if (x.length == 1 && fx.length == 1) {\\n            return fx[0];\\n        }\\n        if (x.length == 2) {\\n            return interpolate_evaluate_by_2_points(x, fx, eval_point, modulus);\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n        return 0;\\n    }\\n\\n    function interpolate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n        assembly {\\n            let y2_minus_y1 := addmod(mload(add(fx, 0x40)), sub(modulus, mload(add(fx, 0x20))), modulus)\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(modulus, mulmod(a, mload(add(x, 0x20)), modulus))\\n            let b := addmod(mload(add(fx, 0x20)), a_mul_x1_neg, modulus)\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && fx.length == 1) {\\n            result = new uint256[](1);\\n            result[0] = fx[0];\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(x, fx, modulus);\\n            return result;\\n        } else {\\n            require(false, \\\"unsupported number of points for interpolation\\\");\\n        }\\n    }\\n\\n    function interpolate_by_2_points(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(basic_marshalling.get_length(blob, fx_offset) == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                calldataload(\\n                    add(blob.offset, add(add(fx_offset, LENGTH_OCTETS), 0x20))\\n                ),\\n                sub(\\n                    modulus,\\n                    calldataload(\\n                        add(blob.offset, add(fx_offset, LENGTH_OCTETS))\\n                    )\\n                ),\\n                modulus\\n            )\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(\\n                modulus,\\n                mulmod(a, mload(add(x, 0x20)), modulus)\\n            )\\n            let b := addmod(\\n                calldataload(add(blob.offset, add(fx_offset, LENGTH_OCTETS))),\\n                a_mul_x1_neg,\\n                modulus\\n            )\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && basic_marshalling.get_length(blob, fx_offset) == 1) {\\n            result = new uint256[](1);\\n            result[0] = basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0);\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(blob, x, fx_offset, modulus);\\n            return result;\\n        } else if (x.length == 3) {\\n            uint256 y0 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0), field.fmul(field.fsub(x[0], x[1],modulus), field.fsub(x[0], x[2],modulus), modulus), modulus);\\n            uint256 y1 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 1), field.fmul(field.fsub(x[1], x[0],modulus), field.fsub(x[1], x[2],modulus), modulus), modulus);\\n            uint256 y2 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 2), field.fmul(field.fsub(x[2], x[0],modulus), field.fsub(x[2], x[1],modulus), modulus), modulus);\\n\\n            result = new uint256[](3);\\n            assembly {\\n                let x1 := mulmod(y0, mulmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus), modulus)\\n                let x2 := mulmod(y1, mulmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus), modulus)\\n                let x3 := mulmod(y2, mulmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus), modulus)\\n                mstore(add(result, 0x20), addmod(addmod(x1, x2, modulus), x3, modulus))\\n\\n                x1 := mulmod(y0, sub(modulus, addmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus)), modulus)\\n                x2 := mulmod(y1, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus)), modulus)\\n                x3 := mulmod(y2, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus)), modulus)\\n                mstore(add(result, 0x40), addmod(addmod(x1, x2, modulus), x3, modulus))\\n                mstore(add(result, 0x60), addmod(addmod(y0, y1, modulus), y2, modulus))\\n            }\\n            return result;\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x6d1a3ab64f2c88e343188f0fec990332e21f8062edf88a6ecf5ead6113d23329\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nlibrary basic_marshalling {\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n    uint256 constant LENGTH_OCTETS_ADD_32 = 40;\\n\\n    //================================================================================================================\\n    // Bounds non-checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n    }\\n\\n    function get_octet_vector_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(add(add(blob.offset, offset), LENGTH_OCTETS))\\n        }\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_uint256_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n    }\\n\\n    function skip_vector_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_v_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n    \\n    function skip_vv_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_v_of_vectors_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n\\n    function skip_length(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n    }\\n\\n    function get_skip_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_i_uint256_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20))))\\n        }\\n    }\\n\\n    function get_i_bytes32_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        assembly {\\n            result_ptr := add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_true(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n        unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector(blob, offset, j);\\n    }\\n\\n    function get_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n\\n    //================================================================================================================\\n    // Bounds checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be_check(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset < blob.length);\\n    }\\n\\n    function get_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        require(offset + LENGTH_OCTETS <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result_ptr := add(\\n                blob.offset,\\n                add(add(offset, LENGTH_OCTETS), mul(i, 0x20))\\n            )\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result){\\n        require(offset + 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4b8bda89ed07c52d7f8d59c4ed34475322d8478d087136eee6bc46efa43d964d\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_fri_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../containers/merkle_verifier.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\nlibrary batched_fri_verifier {\\n    uint256 constant FRI_PARAMS_COEFFS_OFFSET = 0x280;\\n\\n    uint256 constant S1_OFFSET = 0x00;                                      \\n    uint256 constant X_OFFSET = 0x20;                                      \\n    uint256 constant ALPHA_OFFSET = 0x40;                                   // alpha challenge\\n    uint256 constant COEFFS_OFFSET = 0x60;\\n    uint256 constant Y_OFFSET = 0x80;\\n    uint256 constant COLINEAR_OFFSET = 0xa0;                                // colinear_value_offset\\n    uint256 constant C1_OFFSET = 0xc0;                                      // coefficient1_offset\\n    uint256 constant C2_OFFSET = 0xe0;                                      // coefficient2_offset\\n    uint256 constant INTERPOLANT_OFFSET = 0x100;\\n    uint256 constant PREV_COEFFS_LEN_OFFSET = 0x120;\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = skip_query_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.step_list.length ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        fri_params.fri_roots = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.fri_roots[i] = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(result_offset));\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        fri_params.fri_final_poly_offset = result_offset;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n\\n        if( value_len > (( 1 << (field.log2(fri_params.max_degree + 1) - fri_params.r + 1) ) ) ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        fri_params.final_polynomial = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, result_offset);\\n            result_offset = basic_marshalling.skip_uint256_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        fri_params.fri_cur_query_offset = result_offset;\\n        if( value_len != fri_params.lambda ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        for (uint256 i = 0; i < value_len;) {\\n            (success, result_offset) = parse_query_proof_be(fri_params, blob, result_offset);\\n            if(!success) return(success, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_query_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_initial_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_round_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_query_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset){\\n        success = true;\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_initial_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( value_len != fri_params.step_list.length){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_round_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_initial_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        // coset_size\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_initial_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        uint256 len;\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != fri_params.batches_sizes[i] ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // coset_size\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != (1 << fri_params.step_list[0]) ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // values\\n        len = basic_marshalling.get_length(blob, result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        if(len != fri_params.batches_sizes[i] * (1 << fri_params.step_list[0])){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n    }\\n\\n    function skip_round_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_round_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        if( i < fri_params.step_list.length - 1){\\n            if( basic_marshalling.get_length(blob, result_offset) != (1 << fri_params.step_list[i+1]) ){\\n                success = false;\\n                return(success, result_offset);\\n            }\\n        }else{\\n            if( basic_marshalling.get_length(blob, result_offset) != 2 ){\\n                success = false;\\n                return( success, result_offset);\\n            }\\n        }\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns(uint256[] memory roots){\\n        roots = new uint256[](fri_params.batches_num);\\n        uint256 offset = fri_params.fri_cur_query_offset;\\n        offset = basic_marshalling.skip_length(offset);\\n        for( uint256 i = 0; i < fri_params.batches_num;){\\n            roots[i] = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n            offset = skip_initial_proof_be(blob, offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    // if x_index is index of x, then paired_index is index of -x\\n    function get_paired_index(uint256 x_index, uint256 domain_size)\\n    internal pure returns(uint256 result ){\\n        unchecked{ result = (x_index + (domain_size >> 1)) & (domain_size - 1); }\\n    }\\n\\n    // calculate indices for coset S = {s\\\\in D| s^(2^fri_step) == x_next}\\n    function get_folded_index(uint256 x_index, uint256 fri_step, uint256 domain_size_mod) \\n    internal pure returns(uint256 result){\\n        unchecked{result = x_index & (domain_size_mod >> fri_step);}\\n    }\\n  \\n    function calculate_s(\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars) internal pure{\\n\\n        fri_params.s[0] = local_vars.x;\\n        if( local_vars.coset_size > 1){\\n            uint256 base_index = local_vars.domain_size >> 2; \\n            uint256 prev_half_size = 1;\\n            uint256 i = 1;\\n            uint256 j;\\n            local_vars.newind = fri_params.D_omegas.length - 1;\\n            while( i < local_vars.coset_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n    }\\n\\n    function prepare_initial_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,\\n        uint256 k,                                              // current batch index\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[0] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[0], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 first_offset = 0x20;\\n        uint256 y_offset;\\n\\n        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        offset = basic_marshalling.skip_length(offset);             // Skip polynomial number\\n        offset = basic_marshalling.skip_length(offset);             // Skip coset size\\n        offset = basic_marshalling.skip_length(offset);             // Skip y length\\n        for (local_vars.p_ind = 0; local_vars.p_ind < fri_params.batches_sizes[k];) {\\n            for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n                local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n                // Check leaf size\\n                // Prepare y-s\\n                unchecked{ y_offset = offset + ( local_vars.newind << 6 ); }\\n\\n                // push y\\n                if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                    }\\n                } else {\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                    }\\n                }\\n                unchecked{ \\n                    local_vars.y_ind++; \\n                    first_offset += 0x40;\\n                }\\n            }\\n            unchecked{ offset += (1<<(fri_params.step_list[0]+5)); local_vars.p_ind++; }\\n        }\\n    }\\n\\n    // For round proofs\\n    //     Reorder local_vars.values and push to local_vars.b\\n    function prepare_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,                                         // round proof offset\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[local_vars.step] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[local_vars.step], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 y;\\n        offset = 0x20;\\n        for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n            local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n            // Check leaf size\\n            // Prepare y-s\\n\\n            // push y\\n            if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            } else {\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            }\\n            unchecked{ \\n                local_vars.y_ind++; \\n                offset += 0x40;\\n            }\\n        }\\n    }\\n\\n    function clear_values( uint256[] memory values )\\n    internal pure{\\n        for( uint256 i = 0; i < values.length;){\\n            values[i] = 0;\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function load_values( bytes calldata blob, uint256 offset, types.fri_state_type memory local_vars )\\n    internal pure{\\n        uint256 len;\\n        (len, offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( uint256 i = 0; i < len;){\\n            local_vars.values[i] = basic_marshalling.get_uint256_be(blob, offset);\\n            offset = basic_marshalling.skip_uint256_be(offset);\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob, \\n        uint256[] memory roots,\\n        types.transcript_data memory tr_state,\\n        types.fri_params_type memory fri_params\\n    ) internal view returns (bool result) {\\n        types.fri_state_type memory local_vars;\\n\\n        // TODO strange bug. If we we exchange two next lines, then it will not work.\\n        local_vars.alphas = new uint256[](fri_params.r);\\n        local_vars.b = new bytes(0x40 * fri_params.max_batch * fri_params.max_coset);\\n\\n        uint256 offset;\\n        uint256 ind;\\n        uint256 k;\\n        uint256 i;\\n\\n        offset = basic_marshalling.skip_length(fri_params.fri_proof_offset);\\n        offset = basic_marshalling.skip_length(offset);\\n        for( ind = 0; ind < fri_params.step_list.length;){\\n            transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, offset);\\n            for( uint256 round = 0; round < fri_params.step_list[ind];){\\n                local_vars.alphas[local_vars.cur] = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n                unchecked{ round++; local_vars.cur++;}\\n            }\\n            offset = basic_marshalling.skip_octet_vector_32_be(offset);\\n            unchecked{ind++;}\\n        }\\n\\n        for( local_vars.query_id = 0; local_vars.query_id < fri_params.lambda;){\\n            // It'll be init_vars function next\\n            unchecked{ local_vars.domain_size = 1 << (fri_params.D_omegas.length + 1); }\\n            unchecked{ local_vars.domain_size_mod = local_vars.domain_size - 1; }\\n            local_vars.x_index = transcript.get_integral_challenge_be(tr_state, 8) & local_vars.domain_size_mod;\\n            local_vars.x = field.expmod_static(\\n                fri_params.D_omegas[0],\\n                local_vars.x_index,\\n                fri_params.modulus\\n            );\\n\\n            // Check initial proofs\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                // Check merkle local_vars.roots\\n                local_vars.root = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n                if( local_vars.root != roots[k] ){\\n                    return false;\\n                }\\n                prepare_initial_leaf_data(blob, offset, k, fri_params, local_vars);\\n                local_vars.b_length = (fri_params.batches_sizes[k] << (fri_params.step_list[0] +5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n                offset = skip_initial_proof_be(blob, offset);\\n                // Check merkle proofs\\n                unchecked{k++;}\\n            }\\n\\n            // Construct ys for the first round\\n            local_vars.coset_size = 1 << fri_params.step_list[0];\\n            local_vars.values = new uint256[](1 << fri_params.max_step);\\n            local_vars.tmp_values = new uint256[](1 << fri_params.max_step);\\n\\n            for( ind = 0; ind < fri_params.different_points;){                \\n                offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                clear_values(local_vars.tmp_values);\\n                local_vars.cur = 0;\\n                for( k = 0; k < fri_params.batches_num;){\\n                    for( i = 0; i < fri_params.batches_sizes[k];){\\n                        polynomial.multiply_poly_on_coeff(local_vars.tmp_values,fri_params.theta, fri_params.modulus);\\n                        if( fri_params.eval_map[local_vars.cur] == ind ){\\n                            for( uint256 j = 0; j < local_vars.coset_size;){\\n                                local_vars.tmp_values[j] = addmod(\\n                                    local_vars.tmp_values[j], \\n                                    basic_marshalling.get_uint256_be(blob, offset),\\n                                    fri_params.modulus\\n                                );\\n                                offset = basic_marshalling.skip_uint256_be(offset);\\n                                unchecked{ j++; }\\n                            }\\n                        } else {\\n                            offset += (local_vars.coset_size << 5);\\n                        }\\n                        unchecked{ i++; local_vars.cur++;} \\n                    }\\n                    offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    unchecked{ k++; }\\n                }\\n\\n                for( uint256 j = 0; j < local_vars.coset_size; j++){\\n                    if( j & 1 == 0 )\\n                        { local_vars.s = fri_params.s[j>>1];}\\n                    else\\n                        { local_vars.s = fri_params.modulus - fri_params.s[j>>1];}\\n                    local_vars.tmp_values[j] = addmod(\\n                        mulmod( local_vars.tmp_values[j], fri_params.factors[ind], fri_params.modulus),\\n                        fri_params.modulus - polynomial.evaluate(fri_params.combined_U[ind], local_vars.s, fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                    // TODO Denominators for all s can be precomputed. It doesn't depend on polynomial.\\n                    local_vars.tmp_values[j] = mulmod(\\n                        local_vars.tmp_values[j],\\n                        field.inverse_static(\\n                            polynomial.evaluate(fri_params.denominators[ind], local_vars.s, fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        fri_params.modulus\\n                    );\\n                    local_vars.values[j] = addmod(local_vars.values[j], local_vars.tmp_values[j], fri_params.modulus);\\n                }\\n                unchecked{ind++;}\\n            }\\n\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num; ){\\n                offset = skip_initial_proof_be(blob, offset);\\n                unchecked{k++;}\\n            }\\n\\n            // Round proofs check\\n            local_vars.cur = 0;\\n            offset = basic_marshalling.skip_length(offset);\\n\\n            for( local_vars.step = 0; local_vars.step < fri_params.step_list.length;){\\n                // Merkle check;\\n                local_vars.fri_root = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(offset) + 0x8);\\n                if( local_vars.fri_root != fri_params.fri_roots[local_vars.step]) {\\n                    return false;\\n                }\\n\\n                local_vars.coset_size = 1 << fri_params.step_list[local_vars.step];\\n                prepare_leaf_data(blob, offset, fri_params, local_vars);\\n                local_vars.b_length = (1 << (fri_params.step_list[local_vars.step] + 5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n\\n                // Colinear check;\\n                local_vars.factor = 1;\\n                for( local_vars.round = 0; local_vars.round < fri_params.step_list[local_vars.step];){\\n                    local_vars.coset_size >>= 1;\\n                    calculate_s(fri_params, local_vars);\\n                    local_vars.domain_size >>= 1;\\n                    local_vars.domain_size_mod >>= 1;\\n                    local_vars.x_index &= local_vars.domain_size_mod;\\n                    local_vars.x = mulmod(local_vars.x, local_vars.x, fri_params.modulus);\\n                    if( local_vars.round == 0){\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, fri_params.modulus-local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            local_vars.values[j] = mulmod(\\n                                local_vars.values[j], \\n                                fri_params.s[j],\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    } else {\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, fri_params.modulus - local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    }\\n                    unchecked{local_vars.round++; local_vars.cur++;}\\n                }\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.interpolant = local_vars.values[0];\\n\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                load_values(blob, offset, local_vars);\\n                if( local_vars.interpolant != mulmod(local_vars.factor, local_vars.values[0], fri_params.modulus) ){\\n                    return false;\\n                }\\n                offset = basic_marshalling.skip_vector_of_uint256_be(blob, offset);\\n                unchecked{local_vars.step++;}\\n            }\\n\\n            // Final polynomial check. Final polynomial degree is already checked while parsing process\\n            if( polynomial.evaluate(fri_params.final_polynomial, local_vars.x, fri_params.modulus) != local_vars.values[0]){\\n                return false;\\n            }\\n            if( polynomial.evaluate(fri_params.final_polynomial, fri_params.modulus-local_vars.x, fri_params.modulus) != local_vars.values[1]){\\n                return false;\\n            }\\n            \\n            fri_params.fri_cur_query_offset = skip_query_proof_be(blob, fri_params.fri_cur_query_offset);\\n            unchecked{local_vars.query_id++;}\\n        }\\n        return true;\\n    }\\n}\",\"keccak256\":\"0xfd95c69c0d5359a10aaad33b60b1480a4e941b54d2749630149cdc56d08c901f\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_lpc_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022-2023 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"./batched_fri_verifier.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\nlibrary batched_lpc_verifier {\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 i;\\n        uint256 len;\\n        // z\\n        \\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( i = 0; i < len; ){\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        result_offset = batched_fri_verifier.skip_proof_be(blob, result_offset);\\n    }\\n\\n    // Check proof data carefully.\\n    // Load necessary offsets to fri params\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        uint256 len;\\n        // z\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return (success, result_offset);\\n        }\\n        for( uint256 i = 0; i < len; ){\\n            if( fri_params.batches_sizes[i] == 0 ){\\n                fri_params.batches_sizes[i] = basic_marshalling.get_length(blob, result_offset);\\n            } else {\\n                if( basic_marshalling.get_length(blob, result_offset) != fri_params.batches_sizes[i]){\\n                    success = false;\\n                    return (success, result_offset);\\n                }\\n            }\\n            fri_params.poly_num += fri_params.batches_sizes[i];\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        fri_params.fri_proof_offset = result_offset;\\n        (success, result_offset) = batched_fri_verifier.parse_proof_be(fri_params, blob, result_offset);\\n    }\\n\\n    // Input is proof_map.eval_proof_combined_value_offset\\n    function get_variable_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 vv_offset = basic_marshalling.skip_length(offset);\\n\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, vv_offset, i, j\\n        );\\n    }\\n\\n    function get_permutation_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 p_offset = basic_marshalling.skip_length(offset);\\n        \\n        p_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, p_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, p_offset, i, j\\n        );\\n    }\\n\\n    function get_quotient_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 q_offset = basic_marshalling.skip_length(offset);\\n        \\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, q_offset, i, j\\n        );\\n    }\\n\\n    // TODO add starting offsets of eval arrays to some kind of proof map\\n    function get_fixed_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 fv_offset = basic_marshalling.skip_length(offset);\\n        \\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, fv_offset, i, j\\n        );\\n    }\\n\\n    function eval_points_eq(uint256[] memory p1, uint256[] memory p2 )\\n    internal pure returns(bool eq){\\n        eq = true;\\n        if (p1.length != p2.length) return false;\\n        for(uint256 i = 0; i < p1.length;){\\n            if(p1[i] != p2[i]) return false;\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns (uint256[] memory roots){\\n        return batched_fri_verifier.extract_merkle_roots(blob, fri_params);\\n    }\\n\\n    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z, uint256 modulus)\\n    internal pure returns(uint256[2] memory U){\\n//        require( xi.length == 2 );\\n        U[0] = addmod(mulmod(z[0], xi[1], modulus),modulus - mulmod(z[1], xi[0], modulus), modulus);\\n        U[1] = addmod(z[1], modulus - z[0], modulus);\\n    }\\n\\n//  coeffs for zs on each degree can be precomputed if necessary\\n    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z, uint256 modulus)\\n    internal pure returns(uint256[3] memory U){\\n//        require( xi.length == 3 );\\n        z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);\\n        z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);\\n        z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);\\n\\n        U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob,\\n        uint256 offset, \\n        uint256[] memory roots,\\n        uint256[][][] memory evaluation_points,\\n        types.transcript_data memory tr_state, \\n        types.fri_params_type memory fri_params)\\n    internal view returns (bool result) {\\n        uint256 ind;\\n\\n        // Push all merkle roots to transcript\\n        for( ind = 0; ind < fri_params.batches_num;){\\n            transcript.update_transcript_b32(tr_state, bytes32(roots[ind]));\\n            unchecked{ind++;}\\n        }\\n        fri_params.theta = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n        fri_params.eval_map = new uint256[](fri_params.poly_num);\\n        fri_params.unique_eval_points = new uint256[][](fri_params.poly_num);\\n\\n        uint256 cur = 0;\\n        fri_params.different_points = 0;\\n        bool found = false;\\n        uint256[] memory point;\\n        uint256 k;\\n        uint256 i;        \\n\\n        // Prepare evaluation map;\\n        for( k = 0; k < fri_params.batches_num;){\\n            for( i = 0; i < fri_params.batches_sizes[k]; ){\\n                if( evaluation_points[k].length == 1 && i > 0){\\n                    fri_params.eval_map[cur] = fri_params.eval_map[cur - 1];\\n                } else {\\n                    point = evaluation_points[k][i];\\n                    // find this point\\n                    found = false;\\n                    for( ind = 0; ind < fri_params.different_points;){\\n                        if( eval_points_eq(point, fri_params.unique_eval_points[ind]) ){\\n                            found = true;\\n                            fri_params.eval_map[cur] = ind;\\n                            break;\\n                        }\\n                        unchecked{ind++;}\\n                    }\\n                    if(!found) {\\n                        fri_params.unique_eval_points[fri_params.different_points] = point;\\n                        fri_params.eval_map[cur] = fri_params.different_points;\\n                        unchecked{\\n                            fri_params.different_points++;\\n                        }\\n                    }   \\n                }\\n                unchecked{i++;cur++;}\\n            }\\n            unchecked{k++;}\\n        }\\n\\n        fri_params.denominators = new uint256[][](fri_params.different_points);\\n        fri_params.factors = new uint256[](fri_params.different_points);\\n\\n        // Prepare denominators\\n        for( ind = 0; ind < fri_params.different_points;){\\n            fri_params.denominators[ind] = new uint256[](fri_params.unique_eval_points[ind].length + 1);\\n            if( fri_params.unique_eval_points[ind].length == 1 ){\\n                fri_params.factors[ind] = 1;\\n                fri_params.denominators[ind][0] = fri_params.modulus - fri_params.unique_eval_points[ind][0];\\n                fri_params.denominators[ind][1] = 1;\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 2 ){\\n                // xi1 - xi0\\n                fri_params.factors[ind] = \\n                    addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus);\\n                fri_params.denominators[ind][2] = 1;\\n\\n                fri_params.denominators[ind][1] = \\n                    fri_params.modulus - addmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n\\n                fri_params.denominators[ind][0] = \\n                    mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 3 ){\\n                fri_params.factors[ind] = fri_params.modulus - \\n                    mulmod(\\n                        mulmod(\\n                            addmod(fri_params.unique_eval_points[ind][0], fri_params.modulus - fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                            addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        addmod(fri_params.unique_eval_points[ind][2], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][3] = 1;\\n                fri_params.denominators[ind][2] =\\n                    fri_params.modulus - addmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        addmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][1] = \\n                    addmod(\\n                        mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                        addmod(\\n                            mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            mulmod(fri_params.unique_eval_points[ind][1], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = \\n                    fri_params.modulus - mulmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        mulmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][3] = mulmod(fri_params.denominators[ind][3], fri_params.factors[ind], fri_params.modulus);\\n            } else {\\n                return false;\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n        // Prepare combined U\\n        fri_params.combined_U = new uint256[][](fri_params.different_points);\\n        for( ind = 0; ind < fri_params.different_points;){\\n            point = fri_params.unique_eval_points[ind];\\n            fri_params.combined_U[ind] = new uint256[](fri_params.unique_eval_points[ind].length);\\n            cur = 0;\\n            fri_params.z_offset = basic_marshalling.skip_length(offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                fri_params.z_offset = basic_marshalling.skip_length(fri_params.z_offset);\\n                for( i = 0; i < fri_params.batches_sizes[k];){                    \\n                    polynomial.multiply_poly_on_coeff(\\n                        fri_params.combined_U[ind], \\n                        fri_params.theta, \\n                        fri_params.modulus\\n                    );\\n                    if( fri_params.eval_map[cur] == ind ){\\n                        if( point.length == 1 ){\\n                            fri_params.combined_U[ind][0] = addmod(\\n                                fri_params.combined_U[ind][0],\\n                                basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0), \\n                                fri_params.modulus\\n                            );\\n                        } else \\n                        if( point.length == 2 ){\\n                            uint256[2] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp = calculate_2points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                        } else \\n                        if( point.length == 3){\\n                            uint256[3] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp[2] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 2);\\n                            tmp = calculate_3points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                            fri_params.combined_U[ind][2] = addmod(fri_params.combined_U[ind][2], tmp[2], fri_params.modulus);\\n                        } else {\\n                            return false;\\n                        }\\n                    } \\n                    fri_params.z_offset = basic_marshalling.skip_vector_of_uint256_be(blob, fri_params.z_offset);\\n                    unchecked{i++;cur++;}\\n                }\\n                unchecked{k++;}\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n\\n        if (!batched_fri_verifier.verify_proof_be(blob, roots, tr_state, fri_params)) {\\n            return false;\\n        }\\n        \\n        return true;\\n   }\\n} \",\"keccak256\":\"0xea655e8f167a8588e485b7e69c3635fd6799a37d74651b7c381d8df4b47dc6bf\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/containers/merkle_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\nlibrary merkle_verifier {\\n    // Merkle proof has the following structure:\\n    // [0:8] - leaf index\\n    // [8:16] - root length (which is always 32 bytes in current implementation)\\n    // [16:48] - root\\n    // [48:56] - merkle tree depth\\n    //\\n    // Depth number of layers with co-path elements follows then.\\n    // Each layer has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - number of co-path elements on the layer\\n    //  (layer_size = arity-1 actually, which (arity) is always 2 in current implementation)\\n    //\\n    // layer_size number of co-path elements for every layer in merkle proof follows then.\\n    // Each element has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - co-path element position on the layer\\n    // [8:16] - co-path element hash value length (which is always 32 bytes in current implementation)\\n    // [16:48] - co-path element hash value\\n    uint256 constant ROOT_OFFSET = 16;\\n    uint256 constant DEPTH_OFFSET = 48;\\n    uint256 constant LAYERS_OFFSET = 56;\\n    // only one co-element on each layer as arity is always 2\\n    // 8 + (number of co-path elements on the layer)\\n    // 8 + (co-path element position on the layer)\\n    // 8 + (co-path element hash value length)\\n    // 32 (co-path element hash value)\\n    uint256 constant LAYER_POSITION_OFFSET = 8;\\n    uint256 constant LAYER_COPATH_HASH_OFFSET = 24;\\n    uint256 constant LAYER_OCTETS = 56;\\n\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n\\n    function skip_merkle_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_merkle_proof_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        require(result_offset < blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length, \\\"skip_merkle_proof_be\\\");\\n    }\\n\\n    function parse_verify_merkle_proof_not_pre_hash_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n//        uint256 x = 0;\\n//        uint256 depth;\\n        assembly {\\n            let depth := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, add(offset, DEPTH_OFFSET))))\\n\\n            // save leaf hash data to required position\\n            let pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(\\n                        blob.offset,\\n                        add(add(offset, LAYERS_OFFSET), LAYER_POSITION_OFFSET)\\n                    )\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(0x20, verified_data)\\n            }\\n            case 1 {\\n                mstore(0x00, verified_data)\\n            }\\n\\n            let layer_offst := add(offset, LAYERS_OFFSET)\\n            let next_pos\\n            for {\\n                let cur_layer_i := 0\\n            } lt(cur_layer_i, sub(depth, 1)) {\\n                cur_layer_i := add(cur_layer_i, 1)\\n            } {\\n                pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_POSITION_OFFSET)\\n                        )\\n                    )\\n                )\\n                next_pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(\\n                                add(layer_offst, LAYER_POSITION_OFFSET),\\n                                LAYER_OCTETS\\n                            )\\n                        )\\n                    )\\n                )\\n//                x := add(x, pos)\\n//                x := mul(x, 10)\\n                switch pos\\n                case 0 {\\n                    mstore(\\n                        0x00,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                case 1 {\\n                    mstore(\\n                        0x20,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                layer_offst := add(layer_offst, LAYER_OCTETS)\\n            }\\n\\n            pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(blob.offset, add(layer_offst, LAYER_POSITION_OFFSET))\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(\\n                    0x00,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n            case 1 {\\n                mstore(\\n                    0x20,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n        }\\n\\n        bytes32 root;\\n        assembly {\\n            root := calldataload(add(blob.offset, add(offset, ROOT_OFFSET)))\\n        }\\n        result = (verified_data == root);\\n    }\\n    \\n    // We store merkle root as an octet vector. At first length==0x20 is stored.\\n    // We should skip it.\\n    // TODO: this function should return bytes32\\n    function get_merkle_root_from_blob(bytes calldata blob, uint256 merkle_root_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_root_offset, 0x8)))\\n        }\\n    }\\n\\n    // TODO: This function should return bytes32\\n    function get_merkle_root_from_proof(bytes calldata blob, uint256 merkle_proof_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_proof_offset, ROOT_OFFSET)))\\n        }\\n    }\\n\\n    function parse_verify_merkle_proof_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n        assembly {\\n            mstore(0, verified_data)\\n            verified_data := keccak256(0, 0x20)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data)\\n    internal pure returns (bool result) {\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, keccak256(verified_data));\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data_bytes,\\n                                                uint256 verified_data_bytes_len)\\n    internal pure returns (bool result) {\\n        bytes32 verified_data;\\n        assembly {\\n            verified_data := keccak256(add(verified_data_bytes, 0x20), verified_data_bytes_len)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n}\\n\",\"keccak256\":\"0x9495b7b9501fb77dc4e0c8e3a5af3544cb6fac48cc2deb2ec5030c991766b7f4\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/cryptography/transcript.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\n/**\\n * @title Transcript library\\n * @dev Generates Plonk random challenges\\n */\\nlibrary transcript {\\n    function init_transcript(types.transcript_data memory self, bytes memory init_blob)\\n    internal pure {\\n        self.current_challenge = keccak256(init_blob);\\n    }\\n\\n    function update_transcript(types.transcript_data memory self, bytes memory blob)\\n    internal pure {\\n        self.current_challenge = keccak256(bytes.concat(self.current_challenge, blob));\\n    }\\n\\n    function update_transcript_b32(types.transcript_data memory self, bytes32 blob)\\n    internal pure {\\n        self.current_challenge = keccak256(\\n            bytes.concat(self.current_challenge, blob)\\n        );\\n    }\\n\\n    function update_transcript_b32_by_offset(types.transcript_data memory self, bytes memory blob, uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := mload(add(add(blob, 0x20), offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function update_transcript_b32_by_offset_calldata(types.transcript_data memory self, bytes calldata blob,\\n                                                      uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := calldataload(add(blob.offset, offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function get_integral_challenge_be(types.transcript_data memory self, uint256 length)\\n    internal pure returns (uint256 result) {\\n        require(length <= 32);\\n        self.current_challenge = keccak256(abi.encodePacked(self.current_challenge));\\n        return (uint256(self.current_challenge) &\\n               (((uint256(1) << (length * 8)) - 1) << (uint256(256) - length * 8))) >> (uint256(256) - length * 8);\\n    }\\n\\n    function get_field_challenge(types.transcript_data memory self, uint256 modulus)\\n    internal pure returns (uint256) {\\n        self.current_challenge = keccak256(abi.encode(self.current_challenge));\\n        return uint256(self.current_challenge) % modulus;\\n    }\\n\\n    function get_field_challenges(types.transcript_data memory self, uint256[] memory challenges, uint256 modulus)\\n    internal pure {\\n        if (challenges.length > 0) {\\n            bytes32 new_challenge = self.current_challenge;\\n            for (uint256 i = 0; i < challenges.length;) {\\n                new_challenge = keccak256(abi.encode(new_challenge));\\n                challenges[i] = uint256(new_challenge) % modulus;\\n                unchecked{ i++; }\\n            }\\n            self.current_challenge = new_challenge;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe87be40233a78f3c08f5af77e7f0fe2e948eaaada4e84db08c94cf2cc1b60b78\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/permutation_argument.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"../commitments/batched_lpc_verifier.sol\\\";\\n\\nlibrary permutation_argument {\\n    uint256 constant ARGUMENT_SIZE = 3;\\n\\n    uint256 constant EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET = 0xa0;\\n\\n    uint256 constant LEN_OFFSET = 0x0;\\n    uint256 constant OFFSET_OFFSET = 0x20;\\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\\n    uint256 constant ALPHAS_OFFSET = 0xa0;\\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\\n    uint256 constant E_OFFSET = 0xe0;\\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\\n    uint256 constant F_OFFSET = 0x120;\\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\\n    uint256 constant BETA_OFFSET = 0x1a0;\\n    uint256 constant GAMMA_OFFSET = 0x1c0;\\n    uint256 constant G_OFFSET = 0x1e0;\\n    uint256 constant H_OFFSET = 0x200;\\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\\n    uint256 constant TMP1_OFFSET = 0x300;\\n    uint256 constant TMP2_OFFSET = 0x320;\\n    uint256 constant TMP3_OFFSET = 0x340;\\n    uint256 constant IDX1_OFFSET = 0x360;\\n    uint256 constant IDX2_OFFSET = 0x380;\\n    uint256 constant STATUS_OFFSET = 0x3a0;\\n\\n    function eval_permutations_at_challenge(\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_state_type memory local_vars,\\n        uint256 column_polynomials_values_i\\n    ) internal pure {\\n        assembly {\\n            let modulus := mload(fri_params)\\n            mstore(\\n                add(local_vars, G_OFFSET),\\n                mulmod(\\n                    mload(add(local_vars, G_OFFSET)),\\n                    // column_polynomials_values[i] + beta * S_id[i].evaluate(challenge) + gamma\\n                    addmod(\\n                        // column_polynomials_values[i]\\n                        column_polynomials_values_i,\\n                        // beta * S_id[i].evaluate(challenge) + gamma\\n                        addmod(\\n                            // beta * S_id[i].evaluate(challenge)\\n                            mulmod(\\n                                // beta\\n                                mload(add(local_vars, BETA_OFFSET)),\\n                                // S_id[i].evaluate(challenge)\\n                                mload(add(local_vars, S_ID_I_OFFSET)),\\n                                modulus\\n                            ),\\n                            // gamma\\n                            mload(add(local_vars, GAMMA_OFFSET)),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n            mstore(\\n                add(local_vars, H_OFFSET),\\n                mulmod(\\n                    mload(add(local_vars, H_OFFSET)),\\n                    // column_polynomials_values[i] + beta * S_sigma[i].evaluate(challenge) + gamma\\n                    addmod(\\n                        // column_polynomials_values[i]\\n                        column_polynomials_values_i,\\n                        // beta * S_sigma[i].evaluate(challenge) + gamma\\n                        addmod(\\n                            // beta * S_sigma[i].evaluate(challenge)\\n                            mulmod(\\n                                // beta\\n                                mload(add(local_vars, BETA_OFFSET)),\\n                                // S_sigma[i].evaluate(challenge)\\n                                mload(add(local_vars, S_SIGMA_I_OFFSET)),\\n                                modulus\\n                            ),\\n                            // gamma\\n                            mload(add(local_vars, GAMMA_OFFSET)),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n    }\\n\\n    function verify_eval_be(bytes calldata blob,\\n        types.transcript_data memory tr_state,\\n        types.placeholder_proof_map memory proof_map,\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_common_data memory common_data,\\n        types.placeholder_state_type memory local_vars,\\n        types.arithmetization_params memory ar_params\\n    ) internal pure returns (uint256[] memory F) {\\n        // 1. Get beta, gamma\\n        local_vars.beta = transcript.get_field_challenge(\\n            tr_state,\\n            fri_params.modulus\\n        );\\n        local_vars.gamma = transcript.get_field_challenge(\\n            tr_state,\\n            fri_params.modulus\\n        );\\n\\n        // 2. Add commitment to V_P to transcript\\n        transcript.update_transcript_b32_by_offset_calldata(\\n            tr_state,\\n            blob,\\n            proof_map.v_perm_commitment_offset + basic_marshalling.LENGTH_OCTETS\\n        );\\n\\n        // splash\\n        local_vars.len = ar_params.permutation_columns;\\n\\n        //require(\\n        //    batched_lpc_verifier.get_z_n_be(blob, proof_map.eval_proof_fixed_values_offset) == ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 2,\\n        //    \\\"Something wrong with number of fixed values polys\\\"\\n        //);\\n        local_vars.tmp1 = ar_params.witness_columns;\\n        local_vars.tmp2 = ar_params.public_input_columns;\\n        local_vars.tmp3 = ar_params.constant_columns;\\n\\n\\n        // 3. Calculate h_perm, g_perm at challenge pointa\\n        local_vars.g = 1;\\n        local_vars.h = 1;\\n        for (\\n            local_vars.idx1 = 0;\\n            local_vars.idx1 < local_vars.len;\\n            local_vars.idx1++\\n        ) {\\n            for (\\n                local_vars.idx2 = 0;\\n                local_vars.idx2 < common_data.columns_rotations[local_vars.idx1].length;\\n                local_vars.idx2++\\n            ) {\\n                if (common_data.columns_rotations[local_vars.idx1][local_vars.idx2] == 0 ) {\\n                    local_vars.zero_index = local_vars.idx2;\\n                }\\n            }\\n\\n            local_vars.S_id_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                blob,\\n                proof_map.eval_proof_combined_value_offset,\\n                local_vars.idx1,\\n                0\\n            );\\n\\n            // sigma_i\\n            local_vars.S_sigma_i = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                blob,\\n                proof_map.eval_proof_combined_value_offset,\\n                ar_params.permutation_columns + local_vars.idx1,\\n                0\\n            );\\n\\n            if (local_vars.idx1 < local_vars.tmp1) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // witnesses\\n                        local_vars.idx1,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            } else if (local_vars.idx1 < local_vars.tmp1 + local_vars.tmp2) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // public_input\\n                        local_vars.idx1,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            } else if ( local_vars.idx1 <  local_vars.tmp1 + local_vars.tmp2 + local_vars.tmp3 ) {\\n                eval_permutations_at_challenge(\\n                    fri_params,\\n                    local_vars,\\n                    batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                        blob,\\n                        proof_map.eval_proof_combined_value_offset, // constant\\n                        local_vars.idx1 - local_vars.tmp1 - local_vars.tmp2 + ar_params.permutation_columns + ar_params.permutation_columns,\\n                        local_vars.zero_index\\n                    )\\n                );\\n            }\\n        }\\n\\n        local_vars.perm_polynomial_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\\n            blob, proof_map.eval_proof_combined_value_offset, 0, 0\\n        );\\n        local_vars.perm_polynomial_shifted_value = batched_lpc_verifier.get_permutation_z_i_j_from_proof_be(\\n            blob, proof_map.eval_proof_combined_value_offset, 0, 1\\n        );\\n\\n        local_vars.q_last_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n            blob, \\n            proof_map.eval_proof_combined_value_offset,       // special selector 0\\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns,\\n            0\\n        );\\n        local_vars.q_blind_eval = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n            blob, \\n            proof_map.eval_proof_combined_value_offset,       // special selector 1\\n            ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + ar_params.selector_columns + 1,\\n            0\\n        );\\n        F = new uint256[](ARGUMENT_SIZE);\\n        local_vars.challenge = basic_marshalling.get_uint256_be(\\n            blob,\\n            proof_map.eval_proof_offset\\n        );\\n        assembly {\\n            let modulus := mload(fri_params)\\n\\n            // F[0]\\n            mstore(\\n                add(F, 0x20),\\n                mulmod(\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            mload(\\n                                add(\\n                                    proof_map,\\n                                    EVAL_PROOF_LAGRANGE_0_OFFSET_OFFSET\\n                                )\\n                            )\\n                        )\\n                    ),\\n                    addmod(\\n                        1,\\n                        // one - perm_polynomial_value\\n                        sub(\\n                            modulus,\\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n        assembly{\\n            let modulus := mload(fri_params)\\n            // F[1]\\n            mstore(\\n                add(F, 0x40),\\n                // (one - preprocessed_data.q_last.evaluate(challenge) -\\n                //  preprocessed_data.q_blind.evaluate(challenge)) *\\n                //  (perm_polynomial_shifted_value * h - perm_polynomial_value * g)\\n                mulmod(\\n                    // one - preprocessed_data.q_last.evaluate(challenge) -\\n                    //  preprocessed_data.q_blind.evaluate(challenge)\\n                    addmod(\\n                        1,\\n                        // -preprocessed_data.q_last.evaluate(challenge) - preprocessed_data.q_blind.evaluate(challenge)\\n                        addmod(\\n                            // -preprocessed_data.q_last.evaluate(challenge)\\n                            sub(\\n                                modulus,\\n                                mload(add(local_vars, Q_LAST_EVAL_OFFSET))\\n                            ),\\n                            // -preprocessed_data.q_blind.evaluate(challenge)\\n                            sub(\\n                                modulus,\\n                                mload(add(local_vars, Q_BLIND_EVAL_OFFSET))\\n                            ),\\n                            modulus\\n                        ),\\n                        modulus\\n                    ),\\n                    // perm_polynomial_shifted_value * h - perm_polynomial_value * g\\n                    addmod(\\n                        // perm_polynomial_shifted_value * h\\n                        mulmod(\\n                            // perm_polynomial_shifted_value\\n                            mload(\\n                                add(\\n                                    local_vars,\\n                                    PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET\\n                                )\\n                            ),\\n                            // h\\n                            mload(add(local_vars, H_OFFSET)),\\n                            modulus\\n                        ),\\n                        // - perm_polynomial_value * g\\n                        sub(\\n                            modulus,\\n                            mulmod(\\n                                // perm_polynomial_value\\n                                mload(\\n                                    add(\\n                                        local_vars,\\n                                        PERM_POLYNOMIAL_VALUE_OFFSET\\n                                    )\\n                                ),\\n                                // g\\n                                mload(add(local_vars, G_OFFSET)),\\n                                modulus\\n                            )\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n        assembly{\\n            let modulus := mload(fri_params)\\n            // F[2]\\n            mstore(\\n                add(F, 0x60),\\n                // preprocessed_data.q_last.evaluate(challenge) *\\n                //  (perm_polynomial_value.squared() - perm_polynomial_value)\\n                mulmod(\\n                    // preprocessed_data.q_last.evaluate(challenge)\\n                    mload(add(local_vars, Q_LAST_EVAL_OFFSET)),\\n                    // perm_polynomial_value.squared() - perm_polynomial_value\\n                    addmod(\\n                        // perm_polynomial_value.squared()\\n                        mulmod(\\n                            // perm_polynomial_value\\n                            mload(\\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\\n                            ),\\n                            // perm_polynomial_value\\n                            mload(\\n                                add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET)\\n                            ),\\n                            modulus\\n                        ),\\n                        // -perm_polynomial_value\\n                        sub(\\n                            modulus,\\n                            mload(add(local_vars, PERM_POLYNOMIAL_VALUE_OFFSET))\\n                        ),\\n                        modulus\\n                    ),\\n                    modulus\\n                )\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6185fabfe7b4cc9a00779f319f2d83fd6abaf31cc9dbf11ebdf232809034a051\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/placeholder/verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"./permutation_argument.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\nimport \\\"../algebra/field.sol\\\";\\n\\nlibrary ProofVerifier {\\n    // TODO: check correctness all this const\\n    uint256 constant f_parts = 9;\\n\\n    uint256 constant OMEGA_OFFSET = 0x20;\\n\\n    uint256 constant LEN_OFFSET = 0x0;\\n    uint256 constant OFFSET_OFFSET = 0x20;\\n    uint256 constant ZERO_INDEX_OFFSET = 0x40;\\n    uint256 constant PERMUTATION_ARGUMENT_OFFSET = 0x60;\\n    uint256 constant GATE_ARGUMENT_OFFSET = 0x80;\\n    uint256 constant ALPHAS_OFFSET = 0xa0;\\n    uint256 constant CHALLENGE_OFFSET = 0xc0;\\n    uint256 constant E_OFFSET = 0xe0;\\n    uint256 constant EVALUATION_POINTS_OFFSET = 0x100;\\n    uint256 constant F_OFFSET = 0x120;\\n    uint256 constant F_CONSOLIDATED_OFFSET = 0x140;\\n    uint256 constant T_CONSOLIDATED_OFFSET = 0x160;\\n    uint256 constant Z_AT_CHALLENGE_OFFSET = 0x180;\\n    uint256 constant BETA_OFFSET = 0x1a0;\\n    uint256 constant GAMMA_OFFSET = 0x1c0;\\n    uint256 constant G_OFFSET = 0x1e0;\\n    uint256 constant H_OFFSET = 0x200;\\n    uint256 constant PERM_POLYNOMIAL_VALUE_OFFSET = 0x220;\\n    uint256 constant PERM_POLYNOMIAL_SHIFTED_VALUE_OFFSET = 0x240;\\n    uint256 constant Q_BLIND_EVAL_OFFSET = 0x260;\\n    uint256 constant Q_LAST_EVAL_OFFSET = 0x280;\\n    uint256 constant S_ID_I_OFFSET = 0x2a0;\\n    uint256 constant S_SIGMA_I_OFFSET = 0x2c0;\\n    uint256 constant WITNESS_EVALUATION_POINTS_OFFSET = 0x2e0;\\n    uint256 constant STATUS_OFFSET = 0x3a0;\\n\\n    function verify_proof_be(bytes calldata blob,\\n        types.transcript_data memory tr_state,\\n        types.placeholder_proof_map memory proof_map,\\n        types.fri_params_type memory fri_params,\\n        types.placeholder_common_data memory common_data,\\n        types.placeholder_state_type memory local_vars,\\n        types.arithmetization_params memory ar_params\\n    ) external view returns (bool result) {\\n        // 8. alphas computations\\n        local_vars.alphas = new uint256[](f_parts);\\n        transcript.get_field_challenges(tr_state, local_vars.alphas, fri_params.modulus);\\n\\n        // 9. Evaluation proof check\\n        transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, basic_marshalling.skip_length(proof_map.T_commitment_offset));\\n        local_vars.challenge = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n        if (local_vars.challenge != basic_marshalling.get_uint256_be(blob, proof_map.eval_proof_offset)) {\\n            return false;\\n        }\\n\\n        // variable values\\n\\n        local_vars.inversed_omega = field.inverse_static(common_data.omega, fri_params.modulus);\\n        uint256 challenge_omega = field.fmul(local_vars.challenge, common_data.omega, fri_params.modulus);\\n        uint256 challenge_inversed_omega = field.fmul(local_vars.challenge, local_vars.inversed_omega, fri_params.modulus);\\n\\n        // TODO this should be bytes32\\n        local_vars.roots = new uint256[](fri_params.batches_num);\\n        local_vars.roots[0] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.variable_values_commitment_offset);\\n        local_vars.roots[1] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.v_perm_commitment_offset);\\n        local_vars.roots[2] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.T_commitment_offset);\\n        local_vars.roots[3] = merkle_verifier.get_merkle_root_from_blob(blob, proof_map.fixed_values_commitment_offset);\\n\\n        uint256[] memory challenge_point = new uint256[](1);\\n        challenge_point[0] = local_vars.challenge;\\n\\n        local_vars.evaluation_points = new uint256[][][](fri_params.batches_num);\\n        local_vars.evaluation_points[0] = new uint256[][](fri_params.batches_sizes[0]);\\n\\n        for (uint256 i = 0; i < ar_params.witness_columns + ar_params.public_input_columns;) {\\n            local_vars.evaluation_points[0][i] = new uint256[](common_data.columns_rotations[i].length);\\n            for (uint256 j = 0; j < common_data.columns_rotations[i].length;) {\\n                if(common_data.columns_rotations[i][j] == 0){\\n                    local_vars.evaluation_points[0][i][j] = local_vars.challenge;\\n                } else if(common_data.columns_rotations[i][j] == 1){\\n                    local_vars.evaluation_points[0][i][j] = challenge_omega;\\n                } else if(common_data.columns_rotations[i][j] == -1) {\\n                    local_vars.evaluation_points[0][i][j] = challenge_inversed_omega;\\n                } else {\\n                    uint256 omega;\\n                    uint256 e;\\n\\n                    if (common_data.columns_rotations[i][j] < 0) {\\n                        omega = local_vars.inversed_omega;\\n                        e = uint256(-common_data.columns_rotations[i][j]);\\n                    } else {\\n                        omega = common_data.omega;\\n                        e = uint256(common_data.columns_rotations[i][j]);\\n                    }\\n                    // TODO check it!!!!\\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\\n                    assembly{\\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\\n                            if not(eq(and(e,1), 0)){\\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\\n                            }\\n                            if not(eq(e, 1)){\\n                                omega := mulmod(omega,omega, mload(fri_params))\\n                            }\\n                        }\\n                    }\\n                    local_vars.evaluation_points[0][i][j] = local_vars.e;\\n                }\\n            unchecked{j++;}\\n            }\\n        unchecked{i++;}\\n        }\\n\\n        // For permutation polynomial\\n        local_vars.evaluation_points[1] = new uint256[][](1);\\n        local_vars.evaluation_points[1][0] = new uint256[](2);\\n        local_vars.evaluation_points[1][0][0] = local_vars.challenge;\\n        local_vars.evaluation_points[1][0][1] = challenge_omega;\\n\\n        local_vars.evaluation_points[2] = new uint256[][](1);\\n        local_vars.evaluation_points[2][0] = challenge_point;\\n\\n        local_vars.evaluation_points[3] = new uint256[][](fri_params.batches_sizes[3]);\\n        for (uint256 i = 0; i < (ar_params.permutation_columns << 1);) {\\n            local_vars.evaluation_points[3][i] = challenge_point;\\n            unchecked{i++;}\\n        }\\n\\n        // constant columns and selector columns may be rotated\\n        for( uint256 i = 0; i < ar_params.constant_columns + ar_params.selector_columns; ){\\n            uint256 eval_point_ind = i + (ar_params.permutation_columns << 1);\\n            uint256 rotation_ind = i + (ar_params.witness_columns + ar_params.public_input_columns);\\n            local_vars.evaluation_points[3][eval_point_ind] =\\n                new uint256[](common_data.columns_rotations[rotation_ind].length);\\n            for (uint256 j = 0; j < common_data.columns_rotations[rotation_ind].length;) {\\n                if(common_data.columns_rotations[rotation_ind][j] == 0){\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = local_vars.challenge;\\n                } else if(common_data.columns_rotations[rotation_ind][j] == 1){\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_omega;\\n                } else if(common_data.columns_rotations[rotation_ind][j] == -1) {\\n                    local_vars.evaluation_points[3][eval_point_ind][j] = challenge_inversed_omega;\\n                } else {\\n                    uint256 omega;\\n                    uint256 e;\\n\\n                    if (common_data.columns_rotations[rotation_ind][j] < 0) {\\n                        omega = local_vars.inversed_omega;\\n                        e = uint256(-common_data.columns_rotations[rotation_ind][j]);\\n                    } else {\\n                        omega = common_data.omega;\\n                        e = uint256(common_data.columns_rotations[rotation_ind][j]);\\n                    }\\n                    // TODO check it!!!!\\n                    // TODO: check properly if column_rotations will be not one of 0, +-1\\n                    // local_vars.evaluation_points[0][i][j] = local_vars.challenge * omega ^ column_rotations[i][j]\\n                    assembly{\\n                        for{mstore(add(local_vars, E_OFFSET), mload(add(local_vars, CHALLENGE_OFFSET)))} gt(e,0) {e := shr(e, 1)} {\\n                            if not(eq(and(e,1), 0)){\\n                                mstore(add(local_vars, E_OFFSET),mulmod(mload(add(local_vars, E_OFFSET)), omega, mload(fri_params)))\\n                            }\\n                            if not(eq(e, 1)){\\n                                omega := mulmod(omega,omega, mload(fri_params))\\n                            }\\n                        }\\n                    }\\n                    local_vars.evaluation_points[0][eval_point_ind][j] = local_vars.e;\\n                }\\n                unchecked{j++;}\\n            }\\n            unchecked{i++;}\\n        }\\n\\n        //  q_last and q_blind\\n        for (uint256 i = (ar_params.permutation_columns << 1) + ar_params.constant_columns + ar_params.selector_columns;\\n            i < fri_params.batches_sizes[3];\\n        ) {\\n            local_vars.evaluation_points[3][i] = challenge_point;\\n            unchecked{i++;}\\n        }\\n\\n        if( !batched_lpc_verifier.verify_proof_be(\\n            blob,\\n            proof_map.eval_proof_combined_value_offset,\\n            local_vars.roots,\\n            local_vars.evaluation_points,\\n            tr_state,\\n            fri_params\\n        )){\\n            return false;\\n        }\\n\\n        // quotient\\n        // 10. final check\\n        local_vars.F = new uint256[](f_parts);\\n        local_vars.F[0] = local_vars.permutation_argument[0];\\n        local_vars.F[1] = local_vars.permutation_argument[1];\\n        local_vars.F[2] = local_vars.permutation_argument[2];\\n        local_vars.F[3] = 0;\\n        local_vars.F[4] = 0;\\n        local_vars.F[5] = 0;\\n        local_vars.F[6] = 0;\\n        local_vars.F[7] = 0;\\n        local_vars.F[8] = local_vars.gate_argument;\\n\\n        local_vars.F_consolidated = 0;\\n        for (uint256 i = 0; i < f_parts;) {\\n            local_vars.F_consolidated = addmod(\\n                local_vars.F_consolidated,\\n                mulmod(local_vars.alphas[i], local_vars.F[i], fri_params.modulus),\\n                fri_params.modulus\\n            );\\n            unchecked{ i++; }\\n        }\\n        local_vars.T_consolidated = 0;\\n        local_vars.len = fri_params.batches_sizes[2];\\n\\n        for (uint256 i = 0; i < local_vars.len; i++) {\\n            local_vars.zero_index = batched_lpc_verifier.get_quotient_z_i_j_from_proof_be(blob, proof_map.eval_proof_combined_value_offset, i, 0);\\n            local_vars.e = field.expmod_static(local_vars.challenge, (fri_params.max_degree + 1) * i, fri_params.modulus);\\n            //local_vars.zero_index = field.fmul(local_vars.zero_index, local_vars.e, fri_params.modulus);\\n            //local_vars.T_consolidated  = field.fadd(local_vars.T_consolidated, local_vars.zero_index, fri_params.modulus);\\n            assembly {\\n                mstore(\\n                    // local_vars.zero_index\\n                    add(local_vars, ZERO_INDEX_OFFSET),\\n                    // local_vars.zero_index * local_vars.e\\n                    mulmod(\\n                        // local_vars.zero_index\\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\\n                        // local_vars.e\\n                        mload(add(local_vars, E_OFFSET)),\\n                        // modulus\\n                        mload(fri_params)\\n                    )\\n                )\\n                mstore(\\n                    // local_vars.T_consolidated\\n                    add(local_vars, T_CONSOLIDATED_OFFSET),\\n                    // local_vars.T_consolidated + local_vars.zero_index\\n                    addmod(\\n                        // local_vars.T_consolidated\\n                        mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\\n                        // local_vars.zero_index\\n                        mload(add(local_vars, ZERO_INDEX_OFFSET)),\\n                        // modulus\\n                        mload(fri_params)\\n                    )\\n                )\\n            }\\n        }\\n        local_vars.Z_at_challenge = field.expmod_static(local_vars.challenge, common_data.rows_amount, fri_params.modulus);\\n        //local_vars.Z_at_challenge = field.fsub(local_vars.Z_at_challenge, 1, fri_params.modulus);\\n        //local_vars.Z_at_challenge = field.fmul(local_vars.Z_at_challenge, local_vars.T_consolidated, fri_params.modulus);\\n        assembly {\\n            mstore(\\n                // local_vars.Z_at_challenge\\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\\n                // local_vars.Z_at_challenge - 1\\n                addmod(\\n                    // Z_at_challenge\\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\\n                    // -1\\n                    sub(mload(fri_params), 1),\\n                    // modulus\\n                    mload(fri_params)\\n                )\\n            )\\n            mstore(\\n                // local_vars.Z_at_challenge\\n                add(local_vars, Z_AT_CHALLENGE_OFFSET),\\n                // Z_at_challenge * T_consolidated\\n                mulmod(\\n                    // Z_at_challenge\\n                    mload(add(local_vars, Z_AT_CHALLENGE_OFFSET)),\\n                    // T_consolidated\\n                    mload(add(local_vars, T_CONSOLIDATED_OFFSET)),\\n                    // modulus\\n                    mload(fri_params)\\n                )\\n            )\\n        }\\n        if (local_vars.F_consolidated != local_vars.Z_at_challenge) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\",\"keccak256\":\"0xf0fc4c3e4d87dcb736d3aabb8a4d26d1a4f550d537cf0e2b0df4da1761f67647\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2018-2021 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct g1_point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct g2_point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct proof {\\n        g1_point W1;\\n        g1_point W2;\\n        g1_point W3;\\n        g1_point W4;\\n        g1_point Z;\\n        g1_point T1;\\n        g1_point T2;\\n        g1_point T3;\\n        g1_point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        g1_point PI_Z;\\n        g1_point PI_Z_OMEGA;\\n        g1_point recursive_P1;\\n        g1_point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct challenge_transcript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct verification_key {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        g1_point Q1;\\n        g1_point Q2;\\n        g1_point Q3;\\n        g1_point Q4;\\n        g1_point Q5;\\n        g1_point QM;\\n        g1_point QC;\\n        g1_point QARITH;\\n        g1_point QECC;\\n        g1_point QRANGE;\\n        g1_point QLOGIC;\\n        g1_point SIGMA1;\\n        g1_point SIGMA2;\\n        g1_point SIGMA3;\\n        g1_point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        g2_point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n    \\n    struct transcript_data {\\n        bytes32 current_challenge;\\n    }\\n\\n    struct fri_params_type {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 r;\\n        // 0x40\\n        uint256 max_degree;\\n        // 0x60\\n        uint256 lambda;\\n        // 0x80\\n        uint256 omega;\\n        // 0xa0\\n        uint256[] D_omegas;\\n        // 0xc0\\n        uint256[] correct_order_idx;       // Ordered indices to pack ys to check merkle proof\\n        // 0xe0\\n        uint256[] step_list;\\n        // 0x100\\n        uint256[] q;\\n\\n        // 0x120\\n        uint256[] s_indices;\\n        uint256[] s;                    // Coset indices\\n        uint256 max_step;       // variable for memory  initializing\\n        uint256 max_batch;      // variable for memory  initializing\\n\\n        // These are local variables for FRI. But it's useful to allocate memory once\\n        uint256[]    tmp_arr;\\n        uint256[][]  evaluation_points;\\n        uint256      z_offset;\\n\\n        // New fields\\n        uint256       max_coset;\\n        uint256       batches_num;\\n        uint256[]     batches_sizes;\\n        uint256       fri_proof_offset;         // fri_roots offset equals to fri_proof_offset + 0x20\\n        uint256       fri_final_poly_offset;\\n        uint256       fri_cur_query_offset;     // It'll be changed during verification process.\\n                                                // It's set at the begining of the first query proof after parse functions running.\\n        uint256       theta;\\n        uint256       poly_num;\\n        uint256[][]   combined_U;                // U polynomials for different evaluation points\\n        uint256[][]   denominators;              // V polynomials for different evaluation points\\n        uint256[]     factors;\\n        uint256[]     eval_map;\\n        uint256[][]   unique_eval_points;\\n        uint256       different_points;\\n        uint256[]     ys;\\n        uint256[]     final_polynomial;         // It's loaded once while parsing fri proof\\n        uint256[]     fri_roots;                // It should be bytes32\\n    }\\n\\n    struct fri_state_type {\\n        bytes   b;\\n        //0x0\\n        uint256 x_index;\\n        //0x20\\n        uint256 x;\\n        //0x40\\n        uint256 domain_size;\\n        //0x60\\n        uint256 domain_size_mod;\\n        //0x80\\n        uint256 newind;\\n        //0xa0\\n        uint256 p_ind;\\n        //0xc0\\n        uint256 y_ind;\\n        //0xe0\\n        uint256 indices_size;\\n        //0x100\\n        uint256 b_length;\\n        //0x120\\n        uint256 query_id;\\n        //0x140\\n        uint256[]     alphas;\\n        uint256[] values;\\n        uint256[] tmp_values;\\n        uint256 coset_size;\\n        uint256 offset;\\n        uint256 root;\\n        uint256 fri_root;\\n        uint256 s;\\n        uint256 step;\\n        uint256 round;\\n        uint256[] point;\\n        uint256 cur;\\n        uint256 interpolant;\\n        uint256 f0;\\n        uint256 f1;\\n        uint256 factor;\\n    }\\n\\n    struct placeholder_proof_map {\\n        // 0x0\\n        uint256 variable_values_commitment_offset;\\n        // 0x20\\n        uint256 v_perm_commitment_offset;\\n        // 0x40\\n        uint256 T_commitment_offset;\\n        // 0x60\\n        uint256 fixed_values_commitment_offset;\\n        // 0x80\\n        uint256 eval_proof_offset;\\n        // 0xa0\\n        uint256 eval_proof_lagrange_0_offset;\\n        // 0xc0\\n        uint256 eval_proof_combined_value_offset;\\n    }\\n\\n    struct placeholder_common_data {\\n        uint256 rows_amount;\\n        // 0x20\\n        uint256 omega;\\n        int256[][] columns_rotations; \\n    }\\n\\n    struct placeholder_state_type {\\n        // 0x0\\n        uint256 len;\\n        // 0x20\\n        uint256 offset;\\n        // 0x40\\n        uint256 zero_index;\\n        // 0x60\\n        uint256[] permutation_argument;\\n        // 0x80\\n        uint256 gate_argument;\\n        // 0xa0\\n        uint256[] alphas;\\n        // 0xc0\\n        uint256 challenge;\\n        // 0xe0\\n        uint256 e;\\n        // 0x100\\n        uint256[][][] evaluation_points;\\n        // 0x120\\n        uint256[] F;\\n        // 0x140\\n        uint256 F_consolidated;\\n        // 0x160\\n        uint256 T_consolidated;\\n        // 0x180\\n        uint256 Z_at_challenge;\\n        // 0x1a0\\n        uint256 beta;\\n        // 0x1c0\\n        uint256 gamma;\\n        // 0x1e0\\n        uint256 g;\\n        // 0x200\\n        uint256 h;\\n        // 0x220\\n        uint256 perm_polynomial_value;\\n        // 0x240\\n        uint256 perm_polynomial_shifted_value;\\n        // 0x260\\n        uint256 q_blind_eval;\\n        // 0x280\\n        uint256 q_last_eval;\\n        // 0x2a0\\n        uint256 S_id_i;\\n        // 0x2c0\\n        uint256 S_sigma_i;\\n        // 0x2e0\\n        uint256[] roots;\\n        // 0x300\\n        uint256 tmp1;\\n        // 0x320\\n        uint256 tmp2;\\n        // 0x340\\n        uint256 tmp3;\\n        // 0x360\\n        uint256 idx1;\\n        // 0x380\\n        uint256 idx2;\\n        // 0x3a0\\n        uint256 inversed_omega;\\n    }\\n\\n    struct arithmetization_params{\\n        uint256 witness_columns;\\n        uint256 public_input_columns;\\n        uint256 constant_columns;\\n        uint256 selector_columns;\\n        uint256 lookup_table_size;\\n\\n        // computed from other params\\n        uint256 permutation_columns;\\n    }\\n\\n    // parameters are sent to gate argument\\n    struct gate_argument_params {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 theta;\\n    }\\n}\\n\",\"keccak256\":\"0xcb25373de1222759842e237744b85bdbec1c00abd6bf7e3627269ad7d91b5c31\",\"license\":\"MIT OR Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x615fdc6200003b600b82828239805160001a60731461002e57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806371f212b31461003a575b600080fd5b61004d610048366004615de2565b610061565b604051901515815260200160405180910390f35b6040805160098082526101408201909252600091602082016101208036833750505060a08401819052855161009791899161121f565b6100b0878a8a6100ab8a6040015160080190565b611292565b6100be8786600001516113c3565b60c0840181905260808701518a0135146100da57506000611213565b6100ec8460200151866000015161140a565b6103a084015260c08301516020850151865160009261010c929091611450565b905060006101288560c00151866103a001518960000151611450565b90508661022001516001600160401b03811115610147576101476153e2565b604051908082528060200260200182016040528015610170578160200160208202803683370190505b506102e086015287518b0160080135856102e0015160008151811061019757610197615ed0565b6020908102919091018101919091528801518b0160080135856102e001516001815181106101c7576101c7615ed0565b602090810291909101015260408801518b0160080135856102e001516002815181106101f5576101f5615ed0565b602090810291909101015260608801518b0160080135856102e0015160038151811061022357610223615ed0565b60209081029190910101526040805160018082528183019092526000918160200160208202803683370190505090508560c001518160008151811061026a5761026a615ed0565b6020026020010181815250508761022001516001600160401b03811115610293576102936153e2565b6040519080825280602002602001820160405280156102c657816020015b60608152602001906001900390816102b15790505b5061010087015261024088015180516000906102e4576102e4615ed0565b60200260200101516001600160401b03811115610303576103036153e2565b60405190808252806020026020018201604052801561033657816020015b60608152602001906001900390816103215790505b5086610100015160008151811061034f5761034f615ed0565b602002602001018190525060005b6020860151865161036e9190615efc565b81101561070e578760400151818151811061038b5761038b615ed0565b6020026020010151516001600160401b038111156103ab576103ab6153e2565b6040519080825280602002602001820160405280156103d4578160200160208202803683370190505b508761010001516000815181106103ed576103ed615ed0565b6020026020010151828151811061040657610406615ed0565b602002602001018190525060005b8860400151828151811061042a5761042a615ed0565b602002602001015151811015610705578860400151828151811061045057610450615ed0565b6020026020010151818151811061046957610469615ed0565b60200260200101516000036104d8578760c0015188610100015160008151811061049557610495615ed0565b602002602001015183815181106104ae576104ae615ed0565b602002602001015182815181106104c7576104c7615ed0565b6020026020010181815250506106fd565b886040015182815181106104ee576104ee615ed0565b6020026020010151818151811061050757610507615ed0565b602002602001015160010361052f578488610100015160008151811061049557610495615ed0565b8860400151828151811061054557610545615ed0565b6020026020010151818151811061055e5761055e615ed0565b602002602001015160001903610587578388610100015160008151811061049557610495615ed0565b60008060008b6040015185815181106105a2576105a2615ed0565b602002602001015184815181106105bb576105bb615ed0565b6020026020010151121561061857896103a0015191508a6040015184815181106105e7576105e7615ed0565b6020026020010151838151811061060057610600615ed0565b602002602001015161061190615f0f565b9050610659565b8a6020015191508a60400151848151811061063557610635615ed0565b6020026020010151838151811061064e5761064e615ed0565b602002602001015190505b60c08a015160e08b01525b801561069f5760018116151915610684578b518260e08c01510960e08b01525b600181141915610696578b5182830991505b6001901c610664565b8960e001518a61010001516000815181106106bc576106bc615ed0565b602002602001015185815181106106d5576106d5615ed0565b602002602001015184815181106106ee576106ee615ed0565b60200260200101818152505050505b600101610414565b5060010161035d565b5060408051600180825281830190925290816020015b60608152602001906001900390816107245790505086610100015160018151811061075157610751615ed0565b602090810291909101015260408051600280825260608201909252908160200160208202803683370190505086610100015160018151811061079557610795615ed0565b60200260200101516000815181106107af576107af615ed0565b60200260200101819052508560c001518661010001516001815181106107d7576107d7615ed0565b60200260200101516000815181106107f1576107f1615ed0565b602002602001015160008151811061080b5761080b615ed0565b6020026020010181815250508286610100015160018151811061083057610830615ed0565b602002602001015160008151811061084a5761084a615ed0565b602002602001015160018151811061086457610864615ed0565b602090810291909101015260408051600180825281830190925290816020015b6060815260200190600190039081610884579050508661010001516002815181106108b1576108b1615ed0565b6020026020010181905250808661010001516002815181106108d5576108d5615ed0565b60200260200101516000815181106108ef576108ef615ed0565b602002602001018190525087610240015160038151811061091257610912615ed0565b60200260200101516001600160401b03811115610931576109316153e2565b60405190808252806020026020018201604052801561096457816020015b606081526020019060019003908161094f5790505b5086610100015160038151811061097d5761097d615ed0565b602002602001018190525060005b60a086015160011b8110156109df57818761010001516003815181106109b3576109b3615ed0565b602002602001015182815181106109cc576109cc615ed0565b602090810291909101015260010161098b565b5060005b856060015186604001516109f79190615efc565b811015610dd25760a0860151600090610a139060011b83615efc565b9050600087602001518860000151610a2b9190615efc565b610a359084615efc565b905089604001518181518110610a4d57610a4d615ed0565b6020026020010151516001600160401b03811115610a6d57610a6d6153e2565b604051908082528060200260200182016040528015610a96578160200160208202803683370190505b50896101000151600381518110610aaf57610aaf615ed0565b60200260200101518381518110610ac857610ac8615ed0565b602002602001018190525060005b8a604001518281518110610aec57610aec615ed0565b602002602001015151811015610dc7578a604001518281518110610b1257610b12615ed0565b60200260200101518181518110610b2b57610b2b615ed0565b6020026020010151600003610b9a578960c001518a6101000151600381518110610b5757610b57615ed0565b60200260200101518481518110610b7057610b70615ed0565b60200260200101518281518110610b8957610b89615ed0565b602002602001018181525050610dbf565b8a604001518281518110610bb057610bb0615ed0565b60200260200101518181518110610bc957610bc9615ed0565b6020026020010151600103610bf157868a6101000151600381518110610b5757610b57615ed0565b8a604001518281518110610c0757610c07615ed0565b60200260200101518181518110610c2057610c20615ed0565b602002602001015160001903610c4957858a6101000151600381518110610b5757610b57615ed0565b60008060008d604001518581518110610c6457610c64615ed0565b60200260200101518481518110610c7d57610c7d615ed0565b60200260200101511215610cda578b6103a0015191508c604001518481518110610ca957610ca9615ed0565b60200260200101518381518110610cc257610cc2615ed0565b6020026020010151610cd390615f0f565b9050610d1b565b8c6020015191508c604001518481518110610cf757610cf7615ed0565b60200260200101518381518110610d1057610d10615ed0565b602002602001015190505b60c08c015160e08d01525b8015610d615760018116151915610d46578d518260e08e01510960e08d01525b600181141915610d58578d5182830991505b6001901c610d26565b8b60e001518c6101000151600081518110610d7e57610d7e615ed0565b60200260200101518681518110610d9757610d97615ed0565b60200260200101518481518110610db057610db0615ed0565b60200260200101818152505050505b600101610ad6565b5050506001016109e3565b5060008560600151866040015160018860a00151901b610df29190615efc565b610dfc9190615efc565b90505b886102400151600381518110610e1757610e17615ed0565b6020026020010151811015610e6b5781876101000151600381518110610e3f57610e3f615ed0565b60200260200101518281518110610e5857610e58615ed0565b6020908102919091010152600101610dff565b50610e898c8c8b60c00151896102e001518a61010001518f8e61145e565b610e995760009350505050611213565b604080516009808252610140820190925290602082016101208036833750505061012087015260608601518051600090610ed557610ed5615ed0565b6020026020010151866101200151600081518110610ef557610ef5615ed0565b6020026020010181815250508560600151600181518110610f1857610f18615ed0565b6020026020010151866101200151600181518110610f3857610f38615ed0565b6020026020010181815250508560600151600281518110610f5b57610f5b615ed0565b6020026020010151866101200151600281518110610f7b57610f7b615ed0565b6020026020010181815250506000866101200151600381518110610fa157610fa1615ed0565b6020026020010181815250506000866101200151600481518110610fc757610fc7615ed0565b6020026020010181815250506000866101200151600581518110610fed57610fed615ed0565b602002602001018181525050600086610120015160068151811061101357611013615ed0565b602002602001018181525050600086610120015160078151811061103957611039615ed0565b602002602001018181525050856080015186610120015160088151811061106257611062615ed0565b6020908102919091010152600061014087018190525b60098110156110f25788518061109057611090615f2b565b89518061109f5761109f615f2b565b88610120015183815181106110b6576110b6615ed0565b60200260200101518960a0015184815181106110d4576110d4615ed0565b60200260200101510988610140015108610140880152600101611078565b5060006101608701526102408801518051600290811061111457611114615ed0565b6020908102919091010151865260005b86518110156111b05761113f8d8d8c60c00151846000612e03565b8760400181815250506111738760c00151828b6040015160016111629190615efc565b61116c9190615f41565b8b51612e30565b60e08801819052895160408901519091900960408801528851604088015161016089015108610160880152806111a881615f58565b915050611124565b5060c0860151875189516111c5929190612e30565b61018087018190528851906000198201900861018087015287516101608701516101808801510961018087018190526101408701511461120b5760009350505050611213565b600193505050505b98975050505050505050565b81511561128d57825160005b83518110156112895760408051602081018490520160408051601f19818403018152919052805160209091012091506112648383615f71565b84828151811061127657611276615ed0565b602090810291909101015260010161122b565b5083525b505050565b8181106113045760405162461bcd60e51b815260206004820152603560248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a604482015274040decccce6cae8407840c4d8dec45cd8cadccee8d605b1b60648201526084015b60405180910390fd5b61130e8183615f93565b602011156113845760405162461bcd60e51b815260206004820152603b60248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a60448201527f203332203c3d20626c6f622e6c656e677468202d206f6666736574000000000060648201526084016112fb565b828101356113bc8582815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b5050505050565b81516040516000916113db9160200190815260200190565b60408051601f198184030181529190528051602090910120808452611401908390615f71565b90505b92915050565b600060405160208152602080820152602060408201528360608201526002830360808201528260a082015260208160c08360055afa61144857600080fd5b519392505050565b600081838509949350505050565b6000805b8261022001518110156114c7576114bf8487838151811061148557611485615ed0565b602002602001015160001b815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b600101611462565b6114d58484600001516113c3565b6102c08401526102e08301516001600160401b038111156114f8576114f86153e2565b604051908082528060200260200182016040528015611521578160200160208202803683370190505b506103608401526102e08301516001600160401b03811115611545576115456153e2565b60405190808252806020026020018201604052801561157857816020015b60608152602001906001900390816115635790505b5061038084015260006103a0840181905280606081805b87610220015182101561176f575060005b87610240015182815181106115b7576115b7615ed0565b6020026020010151811015611764578982815181106115d8576115d8615ed0565b60200260200101515160011480156115f05750600081115b1561164657610360880151611606600187615f93565b8151811061161657611616615ed0565b6020026020010151886103600151868151811061163557611635615ed0565b602002602001018181525050611758565b89828151811061165857611658615ed0565b6020026020010151818151811061167157611671615ed0565b6020026020010151925060009350600095505b876103a001518610156116f6576116b98389610380015188815181106116ac576116ac615ed0565b6020026020010151612e74565b156116eb57600193508588610360015186815181106116da576116da615ed0565b6020026020010181815250506116f6565b600190950194611684565b836117585782886103800151896103a001518151811061171857611718615ed0565b6020026020010181905250876103a00151886103600151868151811061174057611740615ed0565b60209081029190910101526103a08801805160010190525b600194850194016115a0565b60019091019061158f565b876103a001516001600160401b0381111561178c5761178c6153e2565b6040519080825280602002602001820160405280156117bf57816020015b60608152602001906001900390816117aa5790505b506103208901526103a08801516001600160401b038111156117e3576117e36153e2565b60405190808252806020026020018201604052801561180c578160200160208202803683370190505b50610340890152600095505b876103a0015186101561275957876103800151868151811061183c5761183c615ed0565b60200260200101515160016118519190615efc565b6001600160401b03811115611868576118686153e2565b604051908082528060200260200182016040528015611891578160200160208202803683370190505b5088610320015187815181106118a9576118a9615ed0565b602002602001018190525087610380015186815181106118cb576118cb615ed0565b6020026020010151516001036119c957600188610340015187815181106118f4576118f4615ed0565b602002602001018181525050876103800151868151811061191757611917615ed0565b602002602001015160008151811061193157611931615ed0565b602002602001015188600001516119489190615f93565b886103200151878151811061195f5761195f615ed0565b602002602001015160008151811061197957611979615ed0565b6020026020010181815250506001886103200151878151811061199e5761199e615ed0565b60200260200101516001815181106119b8576119b8615ed0565b60200260200101818152505061274e565b87610380015186815181106119e0576119e0615ed0565b602002602001015151600203611e4b578751806119ff576119ff615f2b565b8861038001518781518110611a1657611a16615ed0565b6020026020010151600081518110611a3057611a30615ed0565b60200260200101518960000151611a479190615f93565b8961038001518881518110611a5e57611a5e615ed0565b6020026020010151600181518110611a7857611a78615ed0565b6020026020010151088861034001518781518110611a9857611a98615ed0565b60200260200101818152505060018861032001518781518110611abd57611abd615ed0565b6020026020010151600281518110611ad757611ad7615ed0565b6020908102919091010152875180611af157611af1615f2b565b8861038001518781518110611b0857611b08615ed0565b6020026020010151600181518110611b2257611b22615ed0565b60200260200101518961038001518881518110611b4157611b41615ed0565b6020026020010151600081518110611b5b57611b5b615ed0565b6020026020010151088851611b709190615f93565b8861032001518781518110611b8757611b87615ed0565b6020026020010151600181518110611ba157611ba1615ed0565b6020908102919091010152875180611bbb57611bbb615f2b565b8861038001518781518110611bd257611bd2615ed0565b6020026020010151600181518110611bec57611bec615ed0565b60200260200101518961038001518881518110611c0b57611c0b615ed0565b6020026020010151600081518110611c2557611c25615ed0565b6020026020010151098861032001518781518110611c4557611c45615ed0565b6020026020010151600081518110611c5f57611c5f615ed0565b6020908102919091010152875180611c7957611c79615f2b565b8861034001518781518110611c9057611c90615ed0565b60200260200101518961032001518881518110611caf57611caf615ed0565b6020026020010151600081518110611cc957611cc9615ed0565b6020026020010151098861032001518781518110611ce957611ce9615ed0565b6020026020010151600081518110611d0357611d03615ed0565b6020908102919091010152875180611d1d57611d1d615f2b565b8861034001518781518110611d3457611d34615ed0565b60200260200101518961032001518881518110611d5357611d53615ed0565b6020026020010151600181518110611d6d57611d6d615ed0565b6020026020010151098861032001518781518110611d8d57611d8d615ed0565b6020026020010151600181518110611da757611da7615ed0565b6020908102919091010152875180611dc157611dc1615f2b565b8861034001518781518110611dd857611dd8615ed0565b60200260200101518961032001518881518110611df757611df7615ed0565b6020026020010151600281518110611e1157611e11615ed0565b6020026020010151098861032001518781518110611e3157611e31615ed0565b60200260200101516002815181106119b8576119b8615ed0565b8761038001518681518110611e6257611e62615ed0565b60200260200101515160030361273f57875180611e8157611e81615f2b565b885180611e9057611e90615f2b565b8961038001518881518110611ea757611ea7615ed0565b6020026020010151600081518110611ec157611ec1615ed0565b60200260200101518a60000151611ed89190615f93565b8a61038001518981518110611eef57611eef615ed0565b6020026020010151600281518110611f0957611f09615ed0565b602002602001015108895180611f2157611f21615f2b565b8a5180611f3057611f30615f2b565b8b61038001518a81518110611f4757611f47615ed0565b6020026020010151600281518110611f6157611f61615ed0565b60200260200101518c60000151611f789190615f93565b8c61038001518b81518110611f8f57611f8f615ed0565b6020026020010151600181518110611fa957611fa9615ed0565b6020026020010151088b5180611fc157611fc1615f2b565b8c61038001518b81518110611fd857611fd8615ed0565b6020026020010151600181518110611ff257611ff2615ed0565b60200260200101518d600001516120099190615f93565b8d61038001518c8151811061202057612020615ed0565b602002602001015160008151811061203a5761203a615ed0565b602002602001015108090988516120519190615f93565b886103400151878151811061206857612068615ed0565b6020026020010181815250506001886103200151878151811061208d5761208d615ed0565b60200260200101516003815181106120a7576120a7615ed0565b60209081029190910101528751806120c1576120c1615f2b565b8851806120d0576120d0615f2b565b89610380015188815181106120e7576120e7615ed0565b602002602001015160028151811061210157612101615ed0565b60200260200101518a6103800151898151811061212057612120615ed0565b602002602001015160018151811061213a5761213a615ed0565b602002602001015108896103800151888151811061215a5761215a615ed0565b602002602001015160008151811061217457612174615ed0565b60200260200101510888516121899190615f93565b88610320015187815181106121a0576121a0615ed0565b60200260200101516002815181106121ba576121ba615ed0565b60209081029190910101528751806121d4576121d4615f2b565b8851806121e3576121e3615f2b565b8951806121f2576121f2615f2b565b8a6103800151898151811061220957612209615ed0565b602002602001015160028151811061222357612223615ed0565b60200260200101518b61038001518a8151811061224257612242615ed0565b602002602001015160018151811061225c5761225c615ed0565b6020026020010151098a518061227457612274615f2b565b8b61038001518a8151811061228b5761228b615ed0565b60200260200101516002815181106122a5576122a5615ed0565b60200260200101518c61038001518b815181106122c4576122c4615ed0565b60200260200101516000815181106122de576122de615ed0565b602002602001015109088951806122f7576122f7615f2b565b8a6103800151898151811061230e5761230e615ed0565b602002602001015160018151811061232857612328615ed0565b60200260200101518b61038001518a8151811061234757612347615ed0565b602002602001015160008151811061236157612361615ed0565b60200260200101510908886103200151878151811061238257612382615ed0565b602002602001015160018151811061239c5761239c615ed0565b60209081029190910101528751806123b6576123b6615f2b565b8851806123c5576123c5615f2b565b89610380015188815181106123dc576123dc615ed0565b60200260200101516002815181106123f6576123f6615ed0565b60200260200101518a6103800151898151811061241557612415615ed0565b602002602001015160018151811061242f5761242f615ed0565b602002602001015109896103800151888151811061244f5761244f615ed0565b602002602001015160008151811061246957612469615ed0565b602002602001015109885161247e9190615f93565b886103200151878151811061249557612495615ed0565b60200260200101516000815181106124af576124af615ed0565b60209081029190910101528751806124c9576124c9615f2b565b88610340015187815181106124e0576124e0615ed0565b602002602001015189610320015188815181106124ff576124ff615ed0565b602002602001015160008151811061251957612519615ed0565b602002602001015109886103200151878151811061253957612539615ed0565b602002602001015160008151811061255357612553615ed0565b602090810291909101015287518061256d5761256d615f2b565b886103400151878151811061258457612584615ed0565b602002602001015189610320015188815181106125a3576125a3615ed0565b60200260200101516001815181106125bd576125bd615ed0565b60200260200101510988610320015187815181106125dd576125dd615ed0565b60200260200101516001815181106125f7576125f7615ed0565b602090810291909101015287518061261157612611615f2b565b886103400151878151811061262857612628615ed0565b6020026020010151896103200151888151811061264757612647615ed0565b602002602001015160028151811061266157612661615ed0565b602002602001015109886103200151878151811061268157612681615ed0565b602002602001015160028151811061269b5761269b615ed0565b60209081029190910101528751806126b5576126b5615f2b565b88610340015187815181106126cc576126cc615ed0565b602002602001015189610320015188815181106126eb576126eb615ed0565b602002602001015160038151811061270557612705615ed0565b602002602001015109886103200151878151811061272557612725615ed0565b60200260200101516003815181106119b8576119b8615ed0565b60009650505050505050612df8565b600190950194611818565b876103a001516001600160401b03811115612776576127766153e2565b6040519080825280602002602001820160405280156127a957816020015b60608152602001906001900390816127945790505b50610300890152600095505b876103a00151861015612dcd5787610380015186815181106127d9576127d9615ed0565b6020026020010151925087610380015186815181106127fa576127fa615ed0565b6020026020010151516001600160401b0381111561281a5761281a6153e2565b604051908082528060200260200182016040528015612843578160200160208202803683370190505b50886103000151878151811061285b5761285b615ed0565b6020026020010181905250600094506128748c60080190565b6101e0890152600091505b876102200151821015612dc257506101e087018051600801905260005b87610240015182815181106128b3576128b3615ed0565b6020026020010151811015612db7576128f488610300015187815181106128dc576128dc615ed0565b6020026020010151896102c001518a60000151612ee6565b85886103600151868151811061290c5761290c615ed0565b602002602001015103612d825782516001036129cb5787518061293157612931615f2b565b61294f8f8f8b6101e001516000602002019190910160080135919050565b896103000151888151811061296657612966615ed0565b602002602001015160008151811061298057612980615ed0565b60200260200101510888610300015187815181106129a0576129a0615ed0565b60200260200101516000815181106129ba576129ba615ed0565b602002602001018181525050612d82565b8251600203612b55576129dc61535e565b6129fa8f8f8b6101e001516000602002019190910160080135919050565b816000602002018181525050612a248f8f8b6101e001516001602002019190910160080135919050565b60208201528851612a389085908390612f51565b895190915080612a4a57612a4a615f2b565b81516103008b015180518a908110612a6457612a64615ed0565b6020026020010151600081518110612a7e57612a7e615ed0565b6020026020010151088961030001518881518110612a9e57612a9e615ed0565b6020026020010151600081518110612ab857612ab8615ed0565b6020908102919091010152885180612ad257612ad2615f2b565b60208201516103008b015180518a908110612aef57612aef615ed0565b6020026020010151600181518110612b0957612b09615ed0565b6020026020010151088961030001518881518110612b2957612b29615ed0565b6020026020010151600181518110612b4357612b43615ed0565b60200260200101818152505050612d82565b825160030361273f57612b6661537c565b612b848f8f8b6101e001516000602002019190910160080135919050565b816000602002018181525050612bae8f8f8b6101e001516001602002019190910160080135919050565b816001602002018181525050612bd88f8f8b6101e001516002602002019190910160080135919050565b60408201528851612bec9085908390613028565b895190915080612bfe57612bfe615f2b565b81516103008b015180518a908110612c1857612c18615ed0565b6020026020010151600081518110612c3257612c32615ed0565b6020026020010151088961030001518881518110612c5257612c52615ed0565b6020026020010151600081518110612c6c57612c6c615ed0565b6020908102919091010152885180612c8657612c86615f2b565b60208201516103008b015180518a908110612ca357612ca3615ed0565b6020026020010151600181518110612cbd57612cbd615ed0565b6020026020010151088961030001518881518110612cdd57612cdd615ed0565b6020026020010151600181518110612cf757612cf7615ed0565b6020908102919091010152885180612d1157612d11615f2b565b60408201516103008b015180518a908110612d2e57612d2e615ed0565b6020026020010151600281518110612d4857612d48615ed0565b6020026020010151088961030001518881518110612d6857612d68615ed0565b6020026020010151600281518110612b4357612b43615ed0565b612da58e8e8a6101e0015160209281013560c01c92909202909101600801919050565b6101e08901526001948501940161289c565b60019091019061287f565b6001909501946127b5565b612dda8e8e8d8c8c613424565b612ded5760009650505050505050612df8565b600196505050505050505b979650505050505050565b600060088401612e14878783614515565b9050612e21878783614515565b9050612df8878783878761454d565b600060405160208152602080820152602060408201528460608201528360808201528260a082015260208160c08360055afa612e6b57600080fd5b51949350505050565b8051825160019114612e8857506000611404565b60005b8351811015612edf57828181518110612ea657612ea6615ed0565b6020026020010151848281518110612ec057612ec0615ed0565b602002602001015114612ed7576000915050611404565b600101612e8b565b5092915050565b60005b8351811015612f4b578180612f0057612f00615f2b565b83858381518110612f1357612f13615ed0565b602002602001015109848281518110612f2e57612f2e615ed0565b602090810291909101015280612f4381615f58565b915050612ee9565b50505050565b612f5961535e565b8180612f6757612f67615f2b565b8280612f7557612f75615f2b565b85600081518110612f8857612f88615ed0565b602002602001015185600160028110612fa357612fa3615ed0565b602002015109612fb39084615f93565b8380612fc157612fc1615f2b565b86600181518110612fd457612fd4615ed0565b602002602001015186600060028110612fef57612fef615ed0565b602002015109088152818061300657613006615f2b565b83516130129084615f93565b6020850151088160015b60200201529392505050565b61303061537c565b818061303e5761303e615f2b565b828061304c5761304c615f2b565b8560028151811061305f5761305f615ed0565b6020026020010151846130729190615f93565b8660018151811061308557613085615ed0565b602002602001015108845109835281806130a1576130a1615f2b565b82806130af576130af615f2b565b856000815181106130c2576130c2615ed0565b6020026020010151846130d59190615f93565b866002815181106130e8576130e8615ed0565b6020026020010151086020850151096020840152818061310a5761310a615f2b565b828061311857613118615f2b565b8560018151811061312b5761312b615ed0565b60200260200101518461313e9190615f93565b8660008151811061315157613151615ed0565b6020026020010151086040850151096040840152818061317357613173615f2b565b828061318157613181615f2b565b8560028151811061319457613194615ed0565b6020026020010151866001815181106131af576131af615ed0565b602002602001015109845109815281806131cb576131cb615f2b565b82806131d9576131d9615f2b565b83806131e7576131e7615f2b565b866002815181106131fa576131fa615ed0565b60200260200101518760008151811061321557613215615ed0565b6020026020010151096020860151098251088152818061323757613237615f2b565b828061324557613245615f2b565b838061325357613253615f2b565b8660018151811061326657613266615ed0565b60200260200101518760008151811061328157613281615ed0565b602002602001015109604086015109825108815281806132a3576132a3615f2b565b82806132b1576132b1615f2b565b856002815181106132c4576132c4615ed0565b6020026020010151866001815181106132df576132df615ed0565b6020026020010151088451096132f59083615f93565b6020820152818061330857613308615f2b565b828061331657613316615f2b565b838061332457613324615f2b565b8660028151811061333757613337615ed0565b60200260200101518760008151811061335257613352615ed0565b60200260200101510860208601510961336b9084615f93565b6020830151086020820152818061338457613384615f2b565b828061339257613392615f2b565b83806133a0576133a0615f2b565b866001815181106133b3576133b3615ed0565b6020026020010151876000815181106133ce576133ce615ed0565b6020026020010151086040860151096133e79084615f93565b6020830151086020820152818061340057613400615f2b565b828061340e5761340e615f2b565b604085015160208601510884510881600261301c565b60006134f36040518061036001604052806060815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081526020016060815260200160608152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016000815260200160008152602001600081525090565b82602001516001600160401b0381111561350f5761350f6153e2565b604051908082528060200260200182016040528015613538578160200160208202803683370190505b50610160820152610200830151610180840151613556906040615f41565b6135609190615f41565b6001600160401b03811115613577576135776153e2565b6040519080825280601f01601f1916602001820160405280156135a1576020820181803683370190505b508152610260830151601001600080805b8660e001515183101561364f576135cb888c8c87611292565b60005b8760e0015184815181106135e4576135e4615ed0565b602002602001015181101561363d576136018989600001516113c3565b866101600151876102c001518151811061361d5761361d615ed0565b60209081029190910101526102c0860180516001908101909152016135ce565b506028840193506001909201916135b2565b60006101408601525b866060015185610140015110156145025760a08701515160019081011b606086018190526000190160808601819052613692896008614590565b16602086015260a087015180516136ca91906000906136b3576136b3615ed0565b602002602001015186602001518960000151612e30565b60408601526102a08701516008019350600091505b8661022001518210156137d2576010848c010135610200860152885189908390811061370d5761370d615ed0565b60200260200101518561020001511461372e5760009550505050505061450c565b61373c8b8b86858b8a614621565b8660e0015160008151811061375357613753615ed0565b602002602001015160056137679190615efc565b876102400151838151811061377e5761377e615ed0565b6020026020010151901b856101200181815250506137a88b8b868860000151896101200151614b0e565b6137ba5760009550505050505061450c565b6137c58b8b86614b24565b93506001909101906136df565b8660e001516000815181106137e9576137e9615ed0565b60200260200101516001901b856101c00181815250508661016001516001901b6001600160401b03811115613820576138206153e2565b604051908082528060200260200182016040528015613849578160200160208202803683370190505b506101808601526101608701516001901b6001600160401b03811115613871576138716153e2565b60405190808252806020026020018201604052801561389a578160200160208202803683370190505b506101a0860152600092505b866103a00151831015613c8d576102a08701516101a086015160388d830181013560c01c0290910160580194506138dc90614b55565b60006102c0860181905291505b866102200151821015613a2e575060005b866102400151828151811061391157613911615ed0565b6020026020010151811015613a0e57613939856101a00151886102c001518960000151612ee6565b82876103600151866102c001518151811061395657613956615ed0565b6020026020010151036139e35760005b856101c001518110156139dd5787518061398257613982615f2b565b858d0135876101a00151838151811061399d5761399d615ed0565b602002602001015108866101a0015182815181106139bd576139bd615ed0565b6020026020010181815250506139d38560200190565b9450600101613966565b506139f9565b6101c08501516139f69060051b85615efc565b93505b6102c0850180516001908101909152016138fa565b60386030858d01013560c01c0290930160500192600191909101906138e9565b60005b856101c00151811015613c815780600116600003613a7b57876101400151600182901c81518110613a6457613a64615ed0565b602002602001015186610240018181525050613ab4565b876101400151600182901c81518110613a9657613a96615ed0565b60200260200101518860000151613aad9190615f93565b6102408701525b875180613ac357613ac3615f2b565b613af58961030001518681518110613add57613add615ed0565b60200260200101518861024001518b60000151614b8c565b8951613b019190615f93565b895180613b1057613b10615f2b565b8a61034001518781518110613b2757613b27615ed0565b6020026020010151896101a001518581518110613b4657613b46615ed0565b60200260200101510908866101a001518281518110613b6757613b67615ed0565b6020908102919091010152875180613b8157613b81615f2b565b613bbd613bb68a61032001518781518110613b9e57613b9e615ed0565b60200260200101518961024001518c60000151614b8c565b8a5161140a565b876101a001518381518110613bd457613bd4615ed0565b602002602001015109866101a001518281518110613bf457613bf4615ed0565b6020908102919091010152875180613c0e57613c0e615f2b565b866101a001518281518110613c2557613c25615ed0565b60200260200101518761018001518381518110613c4457613c44615ed0565b6020026020010151088661018001518281518110613c6457613c64615ed0565b602090810291909101015280613c7981615f58565b915050613a31565b506001909201916138a6565b6102a08701516008019350600091505b866102200151821015613cc257613cb58b8b86614b24565b9350600190910190613c9d565b60006102c086015260088401600061026087015293505b8660e0015151856102600151101561443957613d098b8b60088701613cff906008615efc565b9190910135919050565b61022086015261040087015161026086015181518110613d2b57613d2b615ed0565b602002602001015185610220015114613d4c5760009550505050505061450c565b8660e0015185610260015181518110613d6757613d67615ed0565b60200260200101516001901b856101c0018181525050613d8a8b8b868a89614bbb565b8660e0015185610260015181518110613da557613da5615ed0565b60200260200101516005613db99190615efc565b6001901b61012086018190528551613dd7918d918d91889190614b0e565b613de95760009550505050505061450c565b600161034086015260006102808601525b8660e0015185610260015181518110613e1557613e15615ed0565b60200260200101518561028001511015614309576101c08501805160011c9052613e3f878661505f565b606085018051600190811c90915260808601805190911c908190526020860180519091169052865180613e7457613e74615f2b565b6040860151800960408601526102808501516000036140f55760005b856101c001518110156140d157856101800151600182901b81518110613eb857613eb8615ed0565b6020908102919091010151610300870152610180860151613edd600183811b90615efc565b81518110613eed57613eed615ed0565b6020908102919091010151610320870152875180613f0d57613f0d615f2b565b866103200151876103000151088661018001518281518110613f3157613f31615ed0565b6020908102919091010152875180613f4b57613f4b615f2b565b8861014001518281518110613f6257613f62615ed0565b60200260200101518761018001518381518110613f8157613f81615ed0565b6020026020010151098661018001518281518110613fa157613fa1615ed0565b6020908102919091010152875180613fbb57613fbb615f2b565b885180613fca57613fca615f2b565b895180613fd957613fd9615f2b565b6103208901518b51613feb9190615f93565b89610300015108886101600151896102c001518151811061400e5761400e615ed0565b602002602001015109876101800151838151811061402e5761402e615ed0565b602002602001015108866101800151828151811061404e5761404e615ed0565b602090810291909101015287518061406857614068615f2b565b886101400151828151811061407f5761407f615ed0565b6020026020010151876101800151838151811061409e5761409e615ed0565b60200260200101510986610180015182815181106140be576140be615ed0565b6020908102919091010152600101613e90565b508651806140e1576140e1615f2b565b6002866103400151096103408601526142e9565b60005b856101c001518110156142c957856101800151600182901b8151811061412057614120615ed0565b6020908102919091010151610300870152610180860151614145600183811b90615efc565b8151811061415557614155615ed0565b602090810291909101015161032087015287518061417557614175615f2b565b61032087015189516141879190615f93565b8761030001510886610180015182815181106141a5576141a5615ed0565b60209081029190910101528751806141bf576141bf615f2b565b88610140015182815181106141d6576141d6615ed0565b602002602001015187610180015183815181106141f5576141f5615ed0565b602002602001015109866101800151828151811061421557614215615ed0565b602090810291909101015287518061422f5761422f615f2b565b88518061423e5761423e615f2b565b89518061424d5761424d615f2b565b88610320015189610300015108886101600151896102c001518151811061427657614276615ed0565b602002602001015109876101800151838151811061429657614296615ed0565b60200260200101510886610180015182815181106142b6576142b6615ed0565b60209081029190910101526001016140f8565b508651806142d9576142d9615f2b565b6002866103400151096103408601525b6102808501805160019081019091526102c0860180519091019052613dfa565b86518061431857614318615f2b565b87610140015160008151811061433057614330615ed0565b60200260200101518661034001510961034086015286518061435457614354615f2b565b87610140015160008151811061436c5761436c615ed0565b602002602001015186610340015109610340860152610180850151805160009061439857614398615ed0565b60209081029190910101516102e086015260386030858d01013560c01c810285010193506143c88b8b8688615146565b8651806143d7576143d7615f2b565b8561018001516000815181106143ef576143ef615ed0565b602002602001015186610340015109856102e00151146144175760009550505050505061450c565b6008848c013560c01c6020028501016102608601805160010190529350613cd9565b84610180015160008151811061445157614451615ed0565b6020026020010151614471886103e0015187604001518a60000151614b8c565b146144845760009550505050505061450c565b84610180015160018151811061449c5761449c615ed0565b60200260200101516144c8886103e0015187604001518a600001516144c19190615f93565b8a51614b8c565b146144db5760009550505050505061450c565b6144eb8b8b896102a00151615197565b6102a0880152610140850180516001019052613658565b6001955050505050505b95945050505050565b600881018382013560c01c60005b818110156145445760088387013560c01c6020028401019250600101614523565b50509392505050565b600060088401935060005b838110156145795760088588013560c01c6020028601019450600101614558565b506008602083028501870101359695505050505050565b600060208211156145a057600080fd5b82516040805160208101929092520160408051601f19818403018152919052805160209091012083526145d4826008615f41565b6145e090610100615f93565b6145eb836008615f41565b6145f790610100615f93565b6001614604856008615f41565b6001901b6146129190615f93565b8551911b16901c905092915050565b60008060008060018660e0015160008151811061464057614640615ed0565b60200260200101516146529190615f93565b6001901b6101008601526020850151610120870151805160009061467857614678615ed0565b60200260200101818152505084604001518661014001516000815181106146a1576146a1615ed0565b6020026020010181815250506146df85602001518760e001516000815181106146cc576146cc615ed0565b60200260200101518760800151901c1690565b866101a001516000815181106146f7576146f7615ed0565b6020026020010181815250506001856101000151111561487757606085015160a08088015151600019019087015260021c9350600192508291505b846101000151821015614877575060005b8281101561485b578460800151866101200151828151811061476757614767615ed0565b6020026020010151850116866101200151838151811061478957614789615ed0565b6020026020010181815250508460800151866101a0015182815181106147b1576147b1615ed0565b6020026020010151850116866101a0015183815181106147d3576147d3615ed0565b60200260200101818152505061482d86610140015182815181106147f9576147f9615ed0565b60200260200101518760a001518760a001518151811061481b5761481b615ed0565b60200260200101518860000151611450565b866101400151838151811061484457614844615ed0565b602090810291909101015260019182019101614743565b60a085018051600019019052600193841c939290921b91614732565b600091505b84610100015182101561498c575060005b84610100015181101561495b57856101a0015182815181106148b1576148b1615ed0565b602002602001015186610120015182815181106148d0576148d0615ed0565b6020026020010151036148e95760a0850181905261495b565b856101a00151828151811061490057614900615ed0565b6020026020010151614942876101200151838151811061492257614922615ed0565b60200260200101518760600151600181901c919091016000199091011690565b036149535760a0850181905261495b565b60010161488d565b8460a001518660c00151838151811061497657614976615ed0565b602090810291909101015260019091019061487c565b600060c0868101829052603860308b8e01013590911c02909801605001976020905b87610240015189815181106149c5576149c5615ed0565b60200260200101518760c001511015614b0057600060e08801525b8661010001518760e001511015614ac1578760c001518760e0015181518110614a0b57614a0b615ed0565b60200260200101518760a001818152505060068760a00151901b8a019050876101a001518760e0015181518110614a4457614a44615ed0565b60200260200101518861012001518860a0015181518110614a6757614a67615ed0565b602002602001015103614a9157808c01358288510152602081018c01356020830188510152614aaa565b602081018c01358288510152808c013560208301885101525b60e0870180516001019052604091909101906149e0565b8760e00151600081518110614ad857614ad8615ed0565b60200260200101516005016001901b8a0199508660c0018051809190600101815250506149ae565b505050505050505050505050565b60208201819020600090612df8878787846151ef565b60386030828501013560c01c02810160408101906048015b905060088482013560c01c602002820101949350505050565b60005b8151811015614b88576000828281518110614b7557614b75615ed0565b6020908102919091010152600101614b58565b5050565b600080602085510285015b85811115614bb25783815185878509089150601f1901614b97565b50949350505050565b60008060008060018660e0015186610260015181518110614bde57614bde615ed0565b6020026020010151614bf09190615f93565b6001901b61010086015260208501516101208701518051600090614c1657614c16615ed0565b6020026020010181815250508460400151866101400151600081518110614c3f57614c3f615ed0565b602002602001018181525050614c6e85602001518760e00151876102600151815181106146cc576146cc615ed0565b866101a00151600081518110614c8657614c86615ed0565b60200260200101818152505060018561010001511115614dd257606085015160a08088015151600019019087015260021c9350600192508291505b846101000151821015614dd2575060005b82811015614db65784608001518661012001518281518110614cf657614cf6615ed0565b60200260200101518501168661012001518381518110614d1857614d18615ed0565b6020026020010181815250508460800151866101a001518281518110614d4057614d40615ed0565b6020026020010151850116866101a001518381518110614d6257614d62615ed0565b602002602001018181525050614d8886610140015182815181106147f9576147f9615ed0565b8661014001518381518110614d9f57614d9f615ed0565b602090810291909101015260019182019101614cd2565b60a085018051600019019052600193841c939290921b91614cc1565b600091505b846101000151821015614ec7575060005b846101000151811015614e9657856101a001518281518110614e0c57614e0c615ed0565b60200260200101518661012001518281518110614e2b57614e2b615ed0565b602002602001015103614e445760a08501819052614e96565b856101a001518281518110614e5b57614e5b615ed0565b6020026020010151614e7d876101200151838151811061492257614922615ed0565b03614e8e5760a08501819052614e96565b600101614de8565b8460a001518660c001518381518110614eb157614eb1615ed0565b6020908102919091010152600190910190614dd7565b600060e08601819052602097505b8561010001518660e001511015615053578660c001518660e0015181518110614f0057614f00615ed0565b60200260200101518660a0018181525050866101a001518660e0015181518110614f2c57614f2c615ed0565b60200260200101518761012001518760a0015181518110614f4f57614f4f615ed0565b602002602001015103614fce5785610180015160018760a00151901b81518110614f7b57614f7b615ed0565b6020026020010151905080888751015285610180015160018760a00151901b6001614fa69190615efc565b81518110614fb657614fb6615ed0565b6020026020010151905080602089018751015261503c565b85610180015160018760a00151901b6001614fe99190615efc565b81518110614ff957614ff9615ed0565b6020026020010151905080888751015285610180015160018760a00151901b8151811061502857615028615ed0565b602002602001015190508060208901875101525b60e086018051600101905260409790970196614ed5565b50505050505050505050565b806040015182610140015160008151811061507c5761507c615ed0565b6020026020010181815250506001816101c001511115614b8857606081015160a08301515160029190911c9060019081906000906150bb908390615f93565b60a08601525b846101c0015182101561513e575060005b82811015615122576150f486610140015182815181106147f9576147f9615ed0565b866101400151838151811061510b5761510b615ed0565b6020908102919091010152600191820191016150d2565b60a085018051600019019052600193841c939290921b916150c1565b505050505050565b600882019184013560c01c60005b8181101561513e5783860135836101800151828151811061517757615177615ed0565b60200260200101818152505061518d8460200190565b9350600101615154565b600881018382013560c01c60005b818110156151c2576151b8868685614b24565b92506001016151a5565b5050600881019084013560c01c60005b81811015614544576151e5868685615346565b92506001016151d2565b6000848301603081013560c090811c9160400135901c808015615219576001811461522257615227565b84602052615227565b846000525b50603885016000805b600185038110156152e857898301600881013560c090811c9550604090910135901c915083801561526857600181146152a2576152d8565b8a84016018013560005282801561528657600181146152935761529c565b604060002060205261529c565b60406000206000525b506152d8565b8a8401601801356020528280156152c057600181146152cd576152d6565b60406000206020526152d6565b60406000206000525b505b5060389290920191600101615230565b50508781016008013560c01c915081801561530a576001811461532057615332565b6018820189013560005260406000209550615332565b60188201890135602052604060002095505b505050505092016010013591909114919050565b600060386030838601013560c01c8102830101614b3c565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b60008083601f8401126153ac57600080fd5b5081356001600160401b038111156153c357600080fd5b6020830191508360208285010111156153db57600080fd5b9250929050565b634e487b7160e01b600052604160045260246000fd5b60405161042081016001600160401b038111828210171561541b5761541b6153e2565b60405290565b604051606081016001600160401b038111828210171561541b5761541b6153e2565b6040516103c081016001600160401b038111828210171561541b5761541b6153e2565b604051601f8201601f191681016001600160401b038111828210171561548e5761548e6153e2565b604052919050565b6000602082840312156154a857600080fd5b604051602081018181106001600160401b03821117156154ca576154ca6153e2565b6040529135825250919050565b600060e082840312156154e957600080fd5b60405160e081018181106001600160401b038211171561550b5761550b6153e2565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c08201525092915050565b60006001600160401b03821115615573576155736153e2565b5060051b60200190565b600082601f83011261558e57600080fd5b813560206155a361559e8361555a565b615466565b82815260059290921b840181019181810190868411156155c257600080fd5b8286015b848110156155dd57803583529183019183016155c6565b509695505050505050565b600082601f8301126155f957600080fd5b8135602061560961559e8361555a565b82815260059290921b8401810191818101908684111561562857600080fd5b8286015b848110156155dd5780356001600160401b0381111561564b5760008081fd5b6156598986838b010161557d565b84525091830191830161562c565b6000610420828403121561567a57600080fd5b6156826153f8565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015260a08201356001600160401b03808211156156ca57600080fd5b6156d68583860161557d565b60a084015260c08401359150808211156156ef57600080fd5b6156fb8583860161557d565b60c084015260e084013591508082111561571457600080fd5b6157208583860161557d565b60e08401526101009150818401358181111561573b57600080fd5b6157478682870161557d565b83850152506101209150818401358181111561576257600080fd5b61576e8682870161557d565b83850152506101409150818401358181111561578957600080fd5b6157958682870161557d565b92840192909252610160848101359084015261018080850135908401526101a0915081840135818111156157c857600080fd5b6157d48682870161557d565b83850152506101c0915081840135818111156157ef57600080fd5b6157fb868287016155e8565b928401929092526101e08481013590840152610200808501359084015261022080850135908401526102409150818401358181111561583957600080fd5b6158458682870161557d565b92840192909252610260848101359084015261028080850135908401526102a080850135908401526102c080850135908401526102e080850135908401526103009150818401358181111561589957600080fd5b6158a5868287016155e8565b8385015250610320915081840135818111156158c057600080fd5b6158cc868287016155e8565b8385015250610340915081840135818111156158e757600080fd5b6158f38682870161557d565b83850152506103609150818401358181111561590e57600080fd5b61591a8682870161557d565b83850152506103809150818401358181111561593557600080fd5b615941868287016155e8565b83850152506103a0915081840135828401526103c09150818401358181111561596957600080fd5b6159758682870161557d565b83850152506103e09150818401358181111561599057600080fd5b61599c8682870161557d565b8385015250610400915081840135818111156159b757600080fd5b6159c38682870161557d565b8385015250505092915050565b6000606082840312156159e257600080fd5b6159ea615421565b905081358152602080830135818301526040808401356001600160401b0380821115615a1557600080fd5b818601915086601f830112615a2957600080fd5b8135615a3761559e8261555a565b818152600591821b840186019186820191908a841115615a5657600080fd5b8786015b84811015615adf57803586811115615a725760008081fd5b8701603f81018d13615a845760008081fd5b89810135615a9461559e8261555a565b81815290841b82018a01908b8101908f831115615ab15760008081fd5b928b01925b82841015615acf5783358252928c0192908c0190615ab6565b8752505050928801928801615a5a565b505080868901525050505050505092915050565b600082601f830112615b0457600080fd5b81356020615b1461559e8361555a565b82815260059290921b84018101918181019086841115615b3357600080fd5b8286015b848110156155dd5780356001600160401b03811115615b565760008081fd5b615b648986838b01016155e8565b845250918301918301615b37565b60006103c08284031215615b8557600080fd5b615b8d615443565b905081358152602082013560208201526040820135604082015260608201356001600160401b0380821115615bc157600080fd5b615bcd8583860161557d565b60608401526080840135608084015260a0840135915080821115615bf057600080fd5b615bfc8583860161557d565b60a084015260c084013560c084015260e084013560e084015261010091508184013581811115615c2b57600080fd5b615c3786828701615af3565b838501525061012091508184013581811115615c5257600080fd5b615c5e8682870161557d565b928401929092526101408481013590840152610160808501359084015261018080850135908401526101a080850135908401526101c080850135908401526101e08085013590840152610200808501359084015261022080850135908401526102408085013590840152610260808501359084015261028080850135908401526102a080850135908401526102c080850135908401526102e091508184013581811115615d0a57600080fd5b615d168682870161557d565b928401929092525050610300828101359082015261032080830135908201526103408083013590820152610360808301359082015261038080830135908201526103a09182013591810191909152919050565b600060c08284031215615d7b57600080fd5b60405160c081018181106001600160401b0382111715615d9d57615d9d6153e2565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201525092915050565b600080600080600080600080610240898b031215615dff57600080fd5b88356001600160401b0380821115615e1657600080fd5b615e228c838d0161539a565b909a509850889150615e378c60208d01615496565b9750615e468c60408d016154d7565b96506101208b0135915080821115615e5d57600080fd5b615e698c838d01615667565b95506101408b0135915080821115615e8057600080fd5b615e8c8c838d016159d0565b94506101608b0135915080821115615ea357600080fd5b50615eb08b828c01615b72565b925050615ec18a6101808b01615d69565b90509295985092959890939650565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561140457611404615ee6565b6000600160ff1b8201615f2457615f24615ee6565b5060000390565b634e487b7160e01b600052601260045260246000fd5b808202811582820484141761140457611404615ee6565b600060018201615f6a57615f6a615ee6565b5060010190565b600082615f8e57634e487b7160e01b600052601260045260246000fd5b500690565b8181038181111561140457611404615ee656fea264697066735822122033c5e2a54883ea56c140aa32cdf31e0039541f9433eabeddde922352e2471bc364736f6c63430008130033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100355760003560e01c806371f212b31461003a575b600080fd5b61004d610048366004615de2565b610061565b604051901515815260200160405180910390f35b6040805160098082526101408201909252600091602082016101208036833750505060a08401819052855161009791899161121f565b6100b0878a8a6100ab8a6040015160080190565b611292565b6100be8786600001516113c3565b60c0840181905260808701518a0135146100da57506000611213565b6100ec8460200151866000015161140a565b6103a084015260c08301516020850151865160009261010c929091611450565b905060006101288560c00151866103a001518960000151611450565b90508661022001516001600160401b03811115610147576101476153e2565b604051908082528060200260200182016040528015610170578160200160208202803683370190505b506102e086015287518b0160080135856102e0015160008151811061019757610197615ed0565b6020908102919091018101919091528801518b0160080135856102e001516001815181106101c7576101c7615ed0565b602090810291909101015260408801518b0160080135856102e001516002815181106101f5576101f5615ed0565b602090810291909101015260608801518b0160080135856102e0015160038151811061022357610223615ed0565b60209081029190910101526040805160018082528183019092526000918160200160208202803683370190505090508560c001518160008151811061026a5761026a615ed0565b6020026020010181815250508761022001516001600160401b03811115610293576102936153e2565b6040519080825280602002602001820160405280156102c657816020015b60608152602001906001900390816102b15790505b5061010087015261024088015180516000906102e4576102e4615ed0565b60200260200101516001600160401b03811115610303576103036153e2565b60405190808252806020026020018201604052801561033657816020015b60608152602001906001900390816103215790505b5086610100015160008151811061034f5761034f615ed0565b602002602001018190525060005b6020860151865161036e9190615efc565b81101561070e578760400151818151811061038b5761038b615ed0565b6020026020010151516001600160401b038111156103ab576103ab6153e2565b6040519080825280602002602001820160405280156103d4578160200160208202803683370190505b508761010001516000815181106103ed576103ed615ed0565b6020026020010151828151811061040657610406615ed0565b602002602001018190525060005b8860400151828151811061042a5761042a615ed0565b602002602001015151811015610705578860400151828151811061045057610450615ed0565b6020026020010151818151811061046957610469615ed0565b60200260200101516000036104d8578760c0015188610100015160008151811061049557610495615ed0565b602002602001015183815181106104ae576104ae615ed0565b602002602001015182815181106104c7576104c7615ed0565b6020026020010181815250506106fd565b886040015182815181106104ee576104ee615ed0565b6020026020010151818151811061050757610507615ed0565b602002602001015160010361052f578488610100015160008151811061049557610495615ed0565b8860400151828151811061054557610545615ed0565b6020026020010151818151811061055e5761055e615ed0565b602002602001015160001903610587578388610100015160008151811061049557610495615ed0565b60008060008b6040015185815181106105a2576105a2615ed0565b602002602001015184815181106105bb576105bb615ed0565b6020026020010151121561061857896103a0015191508a6040015184815181106105e7576105e7615ed0565b6020026020010151838151811061060057610600615ed0565b602002602001015161061190615f0f565b9050610659565b8a6020015191508a60400151848151811061063557610635615ed0565b6020026020010151838151811061064e5761064e615ed0565b602002602001015190505b60c08a015160e08b01525b801561069f5760018116151915610684578b518260e08c01510960e08b01525b600181141915610696578b5182830991505b6001901c610664565b8960e001518a61010001516000815181106106bc576106bc615ed0565b602002602001015185815181106106d5576106d5615ed0565b602002602001015184815181106106ee576106ee615ed0565b60200260200101818152505050505b600101610414565b5060010161035d565b5060408051600180825281830190925290816020015b60608152602001906001900390816107245790505086610100015160018151811061075157610751615ed0565b602090810291909101015260408051600280825260608201909252908160200160208202803683370190505086610100015160018151811061079557610795615ed0565b60200260200101516000815181106107af576107af615ed0565b60200260200101819052508560c001518661010001516001815181106107d7576107d7615ed0565b60200260200101516000815181106107f1576107f1615ed0565b602002602001015160008151811061080b5761080b615ed0565b6020026020010181815250508286610100015160018151811061083057610830615ed0565b602002602001015160008151811061084a5761084a615ed0565b602002602001015160018151811061086457610864615ed0565b602090810291909101015260408051600180825281830190925290816020015b6060815260200190600190039081610884579050508661010001516002815181106108b1576108b1615ed0565b6020026020010181905250808661010001516002815181106108d5576108d5615ed0565b60200260200101516000815181106108ef576108ef615ed0565b602002602001018190525087610240015160038151811061091257610912615ed0565b60200260200101516001600160401b03811115610931576109316153e2565b60405190808252806020026020018201604052801561096457816020015b606081526020019060019003908161094f5790505b5086610100015160038151811061097d5761097d615ed0565b602002602001018190525060005b60a086015160011b8110156109df57818761010001516003815181106109b3576109b3615ed0565b602002602001015182815181106109cc576109cc615ed0565b602090810291909101015260010161098b565b5060005b856060015186604001516109f79190615efc565b811015610dd25760a0860151600090610a139060011b83615efc565b9050600087602001518860000151610a2b9190615efc565b610a359084615efc565b905089604001518181518110610a4d57610a4d615ed0565b6020026020010151516001600160401b03811115610a6d57610a6d6153e2565b604051908082528060200260200182016040528015610a96578160200160208202803683370190505b50896101000151600381518110610aaf57610aaf615ed0565b60200260200101518381518110610ac857610ac8615ed0565b602002602001018190525060005b8a604001518281518110610aec57610aec615ed0565b602002602001015151811015610dc7578a604001518281518110610b1257610b12615ed0565b60200260200101518181518110610b2b57610b2b615ed0565b6020026020010151600003610b9a578960c001518a6101000151600381518110610b5757610b57615ed0565b60200260200101518481518110610b7057610b70615ed0565b60200260200101518281518110610b8957610b89615ed0565b602002602001018181525050610dbf565b8a604001518281518110610bb057610bb0615ed0565b60200260200101518181518110610bc957610bc9615ed0565b6020026020010151600103610bf157868a6101000151600381518110610b5757610b57615ed0565b8a604001518281518110610c0757610c07615ed0565b60200260200101518181518110610c2057610c20615ed0565b602002602001015160001903610c4957858a6101000151600381518110610b5757610b57615ed0565b60008060008d604001518581518110610c6457610c64615ed0565b60200260200101518481518110610c7d57610c7d615ed0565b60200260200101511215610cda578b6103a0015191508c604001518481518110610ca957610ca9615ed0565b60200260200101518381518110610cc257610cc2615ed0565b6020026020010151610cd390615f0f565b9050610d1b565b8c6020015191508c604001518481518110610cf757610cf7615ed0565b60200260200101518381518110610d1057610d10615ed0565b602002602001015190505b60c08c015160e08d01525b8015610d615760018116151915610d46578d518260e08e01510960e08d01525b600181141915610d58578d5182830991505b6001901c610d26565b8b60e001518c6101000151600081518110610d7e57610d7e615ed0565b60200260200101518681518110610d9757610d97615ed0565b60200260200101518481518110610db057610db0615ed0565b60200260200101818152505050505b600101610ad6565b5050506001016109e3565b5060008560600151866040015160018860a00151901b610df29190615efc565b610dfc9190615efc565b90505b886102400151600381518110610e1757610e17615ed0565b6020026020010151811015610e6b5781876101000151600381518110610e3f57610e3f615ed0565b60200260200101518281518110610e5857610e58615ed0565b6020908102919091010152600101610dff565b50610e898c8c8b60c00151896102e001518a61010001518f8e61145e565b610e995760009350505050611213565b604080516009808252610140820190925290602082016101208036833750505061012087015260608601518051600090610ed557610ed5615ed0565b6020026020010151866101200151600081518110610ef557610ef5615ed0565b6020026020010181815250508560600151600181518110610f1857610f18615ed0565b6020026020010151866101200151600181518110610f3857610f38615ed0565b6020026020010181815250508560600151600281518110610f5b57610f5b615ed0565b6020026020010151866101200151600281518110610f7b57610f7b615ed0565b6020026020010181815250506000866101200151600381518110610fa157610fa1615ed0565b6020026020010181815250506000866101200151600481518110610fc757610fc7615ed0565b6020026020010181815250506000866101200151600581518110610fed57610fed615ed0565b602002602001018181525050600086610120015160068151811061101357611013615ed0565b602002602001018181525050600086610120015160078151811061103957611039615ed0565b602002602001018181525050856080015186610120015160088151811061106257611062615ed0565b6020908102919091010152600061014087018190525b60098110156110f25788518061109057611090615f2b565b89518061109f5761109f615f2b565b88610120015183815181106110b6576110b6615ed0565b60200260200101518960a0015184815181106110d4576110d4615ed0565b60200260200101510988610140015108610140880152600101611078565b5060006101608701526102408801518051600290811061111457611114615ed0565b6020908102919091010151865260005b86518110156111b05761113f8d8d8c60c00151846000612e03565b8760400181815250506111738760c00151828b6040015160016111629190615efc565b61116c9190615f41565b8b51612e30565b60e08801819052895160408901519091900960408801528851604088015161016089015108610160880152806111a881615f58565b915050611124565b5060c0860151875189516111c5929190612e30565b61018087018190528851906000198201900861018087015287516101608701516101808801510961018087018190526101408701511461120b5760009350505050611213565b600193505050505b98975050505050505050565b81511561128d57825160005b83518110156112895760408051602081018490520160408051601f19818403018152919052805160209091012091506112648383615f71565b84828151811061127657611276615ed0565b602090810291909101015260010161122b565b5083525b505050565b8181106113045760405162461bcd60e51b815260206004820152603560248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a604482015274040decccce6cae8407840c4d8dec45cd8cadccee8d605b1b60648201526084015b60405180910390fd5b61130e8183615f93565b602011156113845760405162461bcd60e51b815260206004820152603b60248201527f7570646174655f7472616e7363726970745f6233325f62795f6f66667365743a60448201527f203332203c3d20626c6f622e6c656e677468202d206f6666736574000000000060648201526084016112fb565b828101356113bc8582815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b5050505050565b81516040516000916113db9160200190815260200190565b60408051601f198184030181529190528051602090910120808452611401908390615f71565b90505b92915050565b600060405160208152602080820152602060408201528360608201526002830360808201528260a082015260208160c08360055afa61144857600080fd5b519392505050565b600081838509949350505050565b6000805b8261022001518110156114c7576114bf8487838151811061148557611485615ed0565b602002602001015160001b815160408051602080820193909352808201939093528051808403820181526060909301905281519101209052565b600101611462565b6114d58484600001516113c3565b6102c08401526102e08301516001600160401b038111156114f8576114f86153e2565b604051908082528060200260200182016040528015611521578160200160208202803683370190505b506103608401526102e08301516001600160401b03811115611545576115456153e2565b60405190808252806020026020018201604052801561157857816020015b60608152602001906001900390816115635790505b5061038084015260006103a0840181905280606081805b87610220015182101561176f575060005b87610240015182815181106115b7576115b7615ed0565b6020026020010151811015611764578982815181106115d8576115d8615ed0565b60200260200101515160011480156115f05750600081115b1561164657610360880151611606600187615f93565b8151811061161657611616615ed0565b6020026020010151886103600151868151811061163557611635615ed0565b602002602001018181525050611758565b89828151811061165857611658615ed0565b6020026020010151818151811061167157611671615ed0565b6020026020010151925060009350600095505b876103a001518610156116f6576116b98389610380015188815181106116ac576116ac615ed0565b6020026020010151612e74565b156116eb57600193508588610360015186815181106116da576116da615ed0565b6020026020010181815250506116f6565b600190950194611684565b836117585782886103800151896103a001518151811061171857611718615ed0565b6020026020010181905250876103a00151886103600151868151811061174057611740615ed0565b60209081029190910101526103a08801805160010190525b600194850194016115a0565b60019091019061158f565b876103a001516001600160401b0381111561178c5761178c6153e2565b6040519080825280602002602001820160405280156117bf57816020015b60608152602001906001900390816117aa5790505b506103208901526103a08801516001600160401b038111156117e3576117e36153e2565b60405190808252806020026020018201604052801561180c578160200160208202803683370190505b50610340890152600095505b876103a0015186101561275957876103800151868151811061183c5761183c615ed0565b60200260200101515160016118519190615efc565b6001600160401b03811115611868576118686153e2565b604051908082528060200260200182016040528015611891578160200160208202803683370190505b5088610320015187815181106118a9576118a9615ed0565b602002602001018190525087610380015186815181106118cb576118cb615ed0565b6020026020010151516001036119c957600188610340015187815181106118f4576118f4615ed0565b602002602001018181525050876103800151868151811061191757611917615ed0565b602002602001015160008151811061193157611931615ed0565b602002602001015188600001516119489190615f93565b886103200151878151811061195f5761195f615ed0565b602002602001015160008151811061197957611979615ed0565b6020026020010181815250506001886103200151878151811061199e5761199e615ed0565b60200260200101516001815181106119b8576119b8615ed0565b60200260200101818152505061274e565b87610380015186815181106119e0576119e0615ed0565b602002602001015151600203611e4b578751806119ff576119ff615f2b565b8861038001518781518110611a1657611a16615ed0565b6020026020010151600081518110611a3057611a30615ed0565b60200260200101518960000151611a479190615f93565b8961038001518881518110611a5e57611a5e615ed0565b6020026020010151600181518110611a7857611a78615ed0565b6020026020010151088861034001518781518110611a9857611a98615ed0565b60200260200101818152505060018861032001518781518110611abd57611abd615ed0565b6020026020010151600281518110611ad757611ad7615ed0565b6020908102919091010152875180611af157611af1615f2b565b8861038001518781518110611b0857611b08615ed0565b6020026020010151600181518110611b2257611b22615ed0565b60200260200101518961038001518881518110611b4157611b41615ed0565b6020026020010151600081518110611b5b57611b5b615ed0565b6020026020010151088851611b709190615f93565b8861032001518781518110611b8757611b87615ed0565b6020026020010151600181518110611ba157611ba1615ed0565b6020908102919091010152875180611bbb57611bbb615f2b565b8861038001518781518110611bd257611bd2615ed0565b6020026020010151600181518110611bec57611bec615ed0565b60200260200101518961038001518881518110611c0b57611c0b615ed0565b6020026020010151600081518110611c2557611c25615ed0565b6020026020010151098861032001518781518110611c4557611c45615ed0565b6020026020010151600081518110611c5f57611c5f615ed0565b6020908102919091010152875180611c7957611c79615f2b565b8861034001518781518110611c9057611c90615ed0565b60200260200101518961032001518881518110611caf57611caf615ed0565b6020026020010151600081518110611cc957611cc9615ed0565b6020026020010151098861032001518781518110611ce957611ce9615ed0565b6020026020010151600081518110611d0357611d03615ed0565b6020908102919091010152875180611d1d57611d1d615f2b565b8861034001518781518110611d3457611d34615ed0565b60200260200101518961032001518881518110611d5357611d53615ed0565b6020026020010151600181518110611d6d57611d6d615ed0565b6020026020010151098861032001518781518110611d8d57611d8d615ed0565b6020026020010151600181518110611da757611da7615ed0565b6020908102919091010152875180611dc157611dc1615f2b565b8861034001518781518110611dd857611dd8615ed0565b60200260200101518961032001518881518110611df757611df7615ed0565b6020026020010151600281518110611e1157611e11615ed0565b6020026020010151098861032001518781518110611e3157611e31615ed0565b60200260200101516002815181106119b8576119b8615ed0565b8761038001518681518110611e6257611e62615ed0565b60200260200101515160030361273f57875180611e8157611e81615f2b565b885180611e9057611e90615f2b565b8961038001518881518110611ea757611ea7615ed0565b6020026020010151600081518110611ec157611ec1615ed0565b60200260200101518a60000151611ed89190615f93565b8a61038001518981518110611eef57611eef615ed0565b6020026020010151600281518110611f0957611f09615ed0565b602002602001015108895180611f2157611f21615f2b565b8a5180611f3057611f30615f2b565b8b61038001518a81518110611f4757611f47615ed0565b6020026020010151600281518110611f6157611f61615ed0565b60200260200101518c60000151611f789190615f93565b8c61038001518b81518110611f8f57611f8f615ed0565b6020026020010151600181518110611fa957611fa9615ed0565b6020026020010151088b5180611fc157611fc1615f2b565b8c61038001518b81518110611fd857611fd8615ed0565b6020026020010151600181518110611ff257611ff2615ed0565b60200260200101518d600001516120099190615f93565b8d61038001518c8151811061202057612020615ed0565b602002602001015160008151811061203a5761203a615ed0565b602002602001015108090988516120519190615f93565b886103400151878151811061206857612068615ed0565b6020026020010181815250506001886103200151878151811061208d5761208d615ed0565b60200260200101516003815181106120a7576120a7615ed0565b60209081029190910101528751806120c1576120c1615f2b565b8851806120d0576120d0615f2b565b89610380015188815181106120e7576120e7615ed0565b602002602001015160028151811061210157612101615ed0565b60200260200101518a6103800151898151811061212057612120615ed0565b602002602001015160018151811061213a5761213a615ed0565b602002602001015108896103800151888151811061215a5761215a615ed0565b602002602001015160008151811061217457612174615ed0565b60200260200101510888516121899190615f93565b88610320015187815181106121a0576121a0615ed0565b60200260200101516002815181106121ba576121ba615ed0565b60209081029190910101528751806121d4576121d4615f2b565b8851806121e3576121e3615f2b565b8951806121f2576121f2615f2b565b8a6103800151898151811061220957612209615ed0565b602002602001015160028151811061222357612223615ed0565b60200260200101518b61038001518a8151811061224257612242615ed0565b602002602001015160018151811061225c5761225c615ed0565b6020026020010151098a518061227457612274615f2b565b8b61038001518a8151811061228b5761228b615ed0565b60200260200101516002815181106122a5576122a5615ed0565b60200260200101518c61038001518b815181106122c4576122c4615ed0565b60200260200101516000815181106122de576122de615ed0565b602002602001015109088951806122f7576122f7615f2b565b8a6103800151898151811061230e5761230e615ed0565b602002602001015160018151811061232857612328615ed0565b60200260200101518b61038001518a8151811061234757612347615ed0565b602002602001015160008151811061236157612361615ed0565b60200260200101510908886103200151878151811061238257612382615ed0565b602002602001015160018151811061239c5761239c615ed0565b60209081029190910101528751806123b6576123b6615f2b565b8851806123c5576123c5615f2b565b89610380015188815181106123dc576123dc615ed0565b60200260200101516002815181106123f6576123f6615ed0565b60200260200101518a6103800151898151811061241557612415615ed0565b602002602001015160018151811061242f5761242f615ed0565b602002602001015109896103800151888151811061244f5761244f615ed0565b602002602001015160008151811061246957612469615ed0565b602002602001015109885161247e9190615f93565b886103200151878151811061249557612495615ed0565b60200260200101516000815181106124af576124af615ed0565b60209081029190910101528751806124c9576124c9615f2b565b88610340015187815181106124e0576124e0615ed0565b602002602001015189610320015188815181106124ff576124ff615ed0565b602002602001015160008151811061251957612519615ed0565b602002602001015109886103200151878151811061253957612539615ed0565b602002602001015160008151811061255357612553615ed0565b602090810291909101015287518061256d5761256d615f2b565b886103400151878151811061258457612584615ed0565b602002602001015189610320015188815181106125a3576125a3615ed0565b60200260200101516001815181106125bd576125bd615ed0565b60200260200101510988610320015187815181106125dd576125dd615ed0565b60200260200101516001815181106125f7576125f7615ed0565b602090810291909101015287518061261157612611615f2b565b886103400151878151811061262857612628615ed0565b6020026020010151896103200151888151811061264757612647615ed0565b602002602001015160028151811061266157612661615ed0565b602002602001015109886103200151878151811061268157612681615ed0565b602002602001015160028151811061269b5761269b615ed0565b60209081029190910101528751806126b5576126b5615f2b565b88610340015187815181106126cc576126cc615ed0565b602002602001015189610320015188815181106126eb576126eb615ed0565b602002602001015160038151811061270557612705615ed0565b602002602001015109886103200151878151811061272557612725615ed0565b60200260200101516003815181106119b8576119b8615ed0565b60009650505050505050612df8565b600190950194611818565b876103a001516001600160401b03811115612776576127766153e2565b6040519080825280602002602001820160405280156127a957816020015b60608152602001906001900390816127945790505b50610300890152600095505b876103a00151861015612dcd5787610380015186815181106127d9576127d9615ed0565b6020026020010151925087610380015186815181106127fa576127fa615ed0565b6020026020010151516001600160401b0381111561281a5761281a6153e2565b604051908082528060200260200182016040528015612843578160200160208202803683370190505b50886103000151878151811061285b5761285b615ed0565b6020026020010181905250600094506128748c60080190565b6101e0890152600091505b876102200151821015612dc257506101e087018051600801905260005b87610240015182815181106128b3576128b3615ed0565b6020026020010151811015612db7576128f488610300015187815181106128dc576128dc615ed0565b6020026020010151896102c001518a60000151612ee6565b85886103600151868151811061290c5761290c615ed0565b602002602001015103612d825782516001036129cb5787518061293157612931615f2b565b61294f8f8f8b6101e001516000602002019190910160080135919050565b896103000151888151811061296657612966615ed0565b602002602001015160008151811061298057612980615ed0565b60200260200101510888610300015187815181106129a0576129a0615ed0565b60200260200101516000815181106129ba576129ba615ed0565b602002602001018181525050612d82565b8251600203612b55576129dc61535e565b6129fa8f8f8b6101e001516000602002019190910160080135919050565b816000602002018181525050612a248f8f8b6101e001516001602002019190910160080135919050565b60208201528851612a389085908390612f51565b895190915080612a4a57612a4a615f2b565b81516103008b015180518a908110612a6457612a64615ed0565b6020026020010151600081518110612a7e57612a7e615ed0565b6020026020010151088961030001518881518110612a9e57612a9e615ed0565b6020026020010151600081518110612ab857612ab8615ed0565b6020908102919091010152885180612ad257612ad2615f2b565b60208201516103008b015180518a908110612aef57612aef615ed0565b6020026020010151600181518110612b0957612b09615ed0565b6020026020010151088961030001518881518110612b2957612b29615ed0565b6020026020010151600181518110612b4357612b43615ed0565b60200260200101818152505050612d82565b825160030361273f57612b6661537c565b612b848f8f8b6101e001516000602002019190910160080135919050565b816000602002018181525050612bae8f8f8b6101e001516001602002019190910160080135919050565b816001602002018181525050612bd88f8f8b6101e001516002602002019190910160080135919050565b60408201528851612bec9085908390613028565b895190915080612bfe57612bfe615f2b565b81516103008b015180518a908110612c1857612c18615ed0565b6020026020010151600081518110612c3257612c32615ed0565b6020026020010151088961030001518881518110612c5257612c52615ed0565b6020026020010151600081518110612c6c57612c6c615ed0565b6020908102919091010152885180612c8657612c86615f2b565b60208201516103008b015180518a908110612ca357612ca3615ed0565b6020026020010151600181518110612cbd57612cbd615ed0565b6020026020010151088961030001518881518110612cdd57612cdd615ed0565b6020026020010151600181518110612cf757612cf7615ed0565b6020908102919091010152885180612d1157612d11615f2b565b60408201516103008b015180518a908110612d2e57612d2e615ed0565b6020026020010151600281518110612d4857612d48615ed0565b6020026020010151088961030001518881518110612d6857612d68615ed0565b6020026020010151600281518110612b4357612b43615ed0565b612da58e8e8a6101e0015160209281013560c01c92909202909101600801919050565b6101e08901526001948501940161289c565b60019091019061287f565b6001909501946127b5565b612dda8e8e8d8c8c613424565b612ded5760009650505050505050612df8565b600196505050505050505b979650505050505050565b600060088401612e14878783614515565b9050612e21878783614515565b9050612df8878783878761454d565b600060405160208152602080820152602060408201528460608201528360808201528260a082015260208160c08360055afa612e6b57600080fd5b51949350505050565b8051825160019114612e8857506000611404565b60005b8351811015612edf57828181518110612ea657612ea6615ed0565b6020026020010151848281518110612ec057612ec0615ed0565b602002602001015114612ed7576000915050611404565b600101612e8b565b5092915050565b60005b8351811015612f4b578180612f0057612f00615f2b565b83858381518110612f1357612f13615ed0565b602002602001015109848281518110612f2e57612f2e615ed0565b602090810291909101015280612f4381615f58565b915050612ee9565b50505050565b612f5961535e565b8180612f6757612f67615f2b565b8280612f7557612f75615f2b565b85600081518110612f8857612f88615ed0565b602002602001015185600160028110612fa357612fa3615ed0565b602002015109612fb39084615f93565b8380612fc157612fc1615f2b565b86600181518110612fd457612fd4615ed0565b602002602001015186600060028110612fef57612fef615ed0565b602002015109088152818061300657613006615f2b565b83516130129084615f93565b6020850151088160015b60200201529392505050565b61303061537c565b818061303e5761303e615f2b565b828061304c5761304c615f2b565b8560028151811061305f5761305f615ed0565b6020026020010151846130729190615f93565b8660018151811061308557613085615ed0565b602002602001015108845109835281806130a1576130a1615f2b565b82806130af576130af615f2b565b856000815181106130c2576130c2615ed0565b6020026020010151846130d59190615f93565b866002815181106130e8576130e8615ed0565b6020026020010151086020850151096020840152818061310a5761310a615f2b565b828061311857613118615f2b565b8560018151811061312b5761312b615ed0565b60200260200101518461313e9190615f93565b8660008151811061315157613151615ed0565b6020026020010151086040850151096040840152818061317357613173615f2b565b828061318157613181615f2b565b8560028151811061319457613194615ed0565b6020026020010151866001815181106131af576131af615ed0565b602002602001015109845109815281806131cb576131cb615f2b565b82806131d9576131d9615f2b565b83806131e7576131e7615f2b565b866002815181106131fa576131fa615ed0565b60200260200101518760008151811061321557613215615ed0565b6020026020010151096020860151098251088152818061323757613237615f2b565b828061324557613245615f2b565b838061325357613253615f2b565b8660018151811061326657613266615ed0565b60200260200101518760008151811061328157613281615ed0565b602002602001015109604086015109825108815281806132a3576132a3615f2b565b82806132b1576132b1615f2b565b856002815181106132c4576132c4615ed0565b6020026020010151866001815181106132df576132df615ed0565b6020026020010151088451096132f59083615f93565b6020820152818061330857613308615f2b565b828061331657613316615f2b565b838061332457613324615f2b565b8660028151811061333757613337615ed0565b60200260200101518760008151811061335257613352615ed0565b60200260200101510860208601510961336b9084615f93565b6020830151086020820152818061338457613384615f2b565b828061339257613392615f2b565b83806133a0576133a0615f2b565b866001815181106133b3576133b3615ed0565b6020026020010151876000815181106133ce576133ce615ed0565b6020026020010151086040860151096133e79084615f93565b6020830151086020820152818061340057613400615f2b565b828061340e5761340e615f2b565b604085015160208601510884510881600261301c565b60006134f36040518061036001604052806060815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001606081526020016060815260200160608152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016000815260200160008152602001600081525090565b82602001516001600160401b0381111561350f5761350f6153e2565b604051908082528060200260200182016040528015613538578160200160208202803683370190505b50610160820152610200830151610180840151613556906040615f41565b6135609190615f41565b6001600160401b03811115613577576135776153e2565b6040519080825280601f01601f1916602001820160405280156135a1576020820181803683370190505b508152610260830151601001600080805b8660e001515183101561364f576135cb888c8c87611292565b60005b8760e0015184815181106135e4576135e4615ed0565b602002602001015181101561363d576136018989600001516113c3565b866101600151876102c001518151811061361d5761361d615ed0565b60209081029190910101526102c0860180516001908101909152016135ce565b506028840193506001909201916135b2565b60006101408601525b866060015185610140015110156145025760a08701515160019081011b606086018190526000190160808601819052613692896008614590565b16602086015260a087015180516136ca91906000906136b3576136b3615ed0565b602002602001015186602001518960000151612e30565b60408601526102a08701516008019350600091505b8661022001518210156137d2576010848c010135610200860152885189908390811061370d5761370d615ed0565b60200260200101518561020001511461372e5760009550505050505061450c565b61373c8b8b86858b8a614621565b8660e0015160008151811061375357613753615ed0565b602002602001015160056137679190615efc565b876102400151838151811061377e5761377e615ed0565b6020026020010151901b856101200181815250506137a88b8b868860000151896101200151614b0e565b6137ba5760009550505050505061450c565b6137c58b8b86614b24565b93506001909101906136df565b8660e001516000815181106137e9576137e9615ed0565b60200260200101516001901b856101c00181815250508661016001516001901b6001600160401b03811115613820576138206153e2565b604051908082528060200260200182016040528015613849578160200160208202803683370190505b506101808601526101608701516001901b6001600160401b03811115613871576138716153e2565b60405190808252806020026020018201604052801561389a578160200160208202803683370190505b506101a0860152600092505b866103a00151831015613c8d576102a08701516101a086015160388d830181013560c01c0290910160580194506138dc90614b55565b60006102c0860181905291505b866102200151821015613a2e575060005b866102400151828151811061391157613911615ed0565b6020026020010151811015613a0e57613939856101a00151886102c001518960000151612ee6565b82876103600151866102c001518151811061395657613956615ed0565b6020026020010151036139e35760005b856101c001518110156139dd5787518061398257613982615f2b565b858d0135876101a00151838151811061399d5761399d615ed0565b602002602001015108866101a0015182815181106139bd576139bd615ed0565b6020026020010181815250506139d38560200190565b9450600101613966565b506139f9565b6101c08501516139f69060051b85615efc565b93505b6102c0850180516001908101909152016138fa565b60386030858d01013560c01c0290930160500192600191909101906138e9565b60005b856101c00151811015613c815780600116600003613a7b57876101400151600182901c81518110613a6457613a64615ed0565b602002602001015186610240018181525050613ab4565b876101400151600182901c81518110613a9657613a96615ed0565b60200260200101518860000151613aad9190615f93565b6102408701525b875180613ac357613ac3615f2b565b613af58961030001518681518110613add57613add615ed0565b60200260200101518861024001518b60000151614b8c565b8951613b019190615f93565b895180613b1057613b10615f2b565b8a61034001518781518110613b2757613b27615ed0565b6020026020010151896101a001518581518110613b4657613b46615ed0565b60200260200101510908866101a001518281518110613b6757613b67615ed0565b6020908102919091010152875180613b8157613b81615f2b565b613bbd613bb68a61032001518781518110613b9e57613b9e615ed0565b60200260200101518961024001518c60000151614b8c565b8a5161140a565b876101a001518381518110613bd457613bd4615ed0565b602002602001015109866101a001518281518110613bf457613bf4615ed0565b6020908102919091010152875180613c0e57613c0e615f2b565b866101a001518281518110613c2557613c25615ed0565b60200260200101518761018001518381518110613c4457613c44615ed0565b6020026020010151088661018001518281518110613c6457613c64615ed0565b602090810291909101015280613c7981615f58565b915050613a31565b506001909201916138a6565b6102a08701516008019350600091505b866102200151821015613cc257613cb58b8b86614b24565b9350600190910190613c9d565b60006102c086015260088401600061026087015293505b8660e0015151856102600151101561443957613d098b8b60088701613cff906008615efc565b9190910135919050565b61022086015261040087015161026086015181518110613d2b57613d2b615ed0565b602002602001015185610220015114613d4c5760009550505050505061450c565b8660e0015185610260015181518110613d6757613d67615ed0565b60200260200101516001901b856101c0018181525050613d8a8b8b868a89614bbb565b8660e0015185610260015181518110613da557613da5615ed0565b60200260200101516005613db99190615efc565b6001901b61012086018190528551613dd7918d918d91889190614b0e565b613de95760009550505050505061450c565b600161034086015260006102808601525b8660e0015185610260015181518110613e1557613e15615ed0565b60200260200101518561028001511015614309576101c08501805160011c9052613e3f878661505f565b606085018051600190811c90915260808601805190911c908190526020860180519091169052865180613e7457613e74615f2b565b6040860151800960408601526102808501516000036140f55760005b856101c001518110156140d157856101800151600182901b81518110613eb857613eb8615ed0565b6020908102919091010151610300870152610180860151613edd600183811b90615efc565b81518110613eed57613eed615ed0565b6020908102919091010151610320870152875180613f0d57613f0d615f2b565b866103200151876103000151088661018001518281518110613f3157613f31615ed0565b6020908102919091010152875180613f4b57613f4b615f2b565b8861014001518281518110613f6257613f62615ed0565b60200260200101518761018001518381518110613f8157613f81615ed0565b6020026020010151098661018001518281518110613fa157613fa1615ed0565b6020908102919091010152875180613fbb57613fbb615f2b565b885180613fca57613fca615f2b565b895180613fd957613fd9615f2b565b6103208901518b51613feb9190615f93565b89610300015108886101600151896102c001518151811061400e5761400e615ed0565b602002602001015109876101800151838151811061402e5761402e615ed0565b602002602001015108866101800151828151811061404e5761404e615ed0565b602090810291909101015287518061406857614068615f2b565b886101400151828151811061407f5761407f615ed0565b6020026020010151876101800151838151811061409e5761409e615ed0565b60200260200101510986610180015182815181106140be576140be615ed0565b6020908102919091010152600101613e90565b508651806140e1576140e1615f2b565b6002866103400151096103408601526142e9565b60005b856101c001518110156142c957856101800151600182901b8151811061412057614120615ed0565b6020908102919091010151610300870152610180860151614145600183811b90615efc565b8151811061415557614155615ed0565b602090810291909101015161032087015287518061417557614175615f2b565b61032087015189516141879190615f93565b8761030001510886610180015182815181106141a5576141a5615ed0565b60209081029190910101528751806141bf576141bf615f2b565b88610140015182815181106141d6576141d6615ed0565b602002602001015187610180015183815181106141f5576141f5615ed0565b602002602001015109866101800151828151811061421557614215615ed0565b602090810291909101015287518061422f5761422f615f2b565b88518061423e5761423e615f2b565b89518061424d5761424d615f2b565b88610320015189610300015108886101600151896102c001518151811061427657614276615ed0565b602002602001015109876101800151838151811061429657614296615ed0565b60200260200101510886610180015182815181106142b6576142b6615ed0565b60209081029190910101526001016140f8565b508651806142d9576142d9615f2b565b6002866103400151096103408601525b6102808501805160019081019091526102c0860180519091019052613dfa565b86518061431857614318615f2b565b87610140015160008151811061433057614330615ed0565b60200260200101518661034001510961034086015286518061435457614354615f2b565b87610140015160008151811061436c5761436c615ed0565b602002602001015186610340015109610340860152610180850151805160009061439857614398615ed0565b60209081029190910101516102e086015260386030858d01013560c01c810285010193506143c88b8b8688615146565b8651806143d7576143d7615f2b565b8561018001516000815181106143ef576143ef615ed0565b602002602001015186610340015109856102e00151146144175760009550505050505061450c565b6008848c013560c01c6020028501016102608601805160010190529350613cd9565b84610180015160008151811061445157614451615ed0565b6020026020010151614471886103e0015187604001518a60000151614b8c565b146144845760009550505050505061450c565b84610180015160018151811061449c5761449c615ed0565b60200260200101516144c8886103e0015187604001518a600001516144c19190615f93565b8a51614b8c565b146144db5760009550505050505061450c565b6144eb8b8b896102a00151615197565b6102a0880152610140850180516001019052613658565b6001955050505050505b95945050505050565b600881018382013560c01c60005b818110156145445760088387013560c01c6020028401019250600101614523565b50509392505050565b600060088401935060005b838110156145795760088588013560c01c6020028601019450600101614558565b506008602083028501870101359695505050505050565b600060208211156145a057600080fd5b82516040805160208101929092520160408051601f19818403018152919052805160209091012083526145d4826008615f41565b6145e090610100615f93565b6145eb836008615f41565b6145f790610100615f93565b6001614604856008615f41565b6001901b6146129190615f93565b8551911b16901c905092915050565b60008060008060018660e0015160008151811061464057614640615ed0565b60200260200101516146529190615f93565b6001901b6101008601526020850151610120870151805160009061467857614678615ed0565b60200260200101818152505084604001518661014001516000815181106146a1576146a1615ed0565b6020026020010181815250506146df85602001518760e001516000815181106146cc576146cc615ed0565b60200260200101518760800151901c1690565b866101a001516000815181106146f7576146f7615ed0565b6020026020010181815250506001856101000151111561487757606085015160a08088015151600019019087015260021c9350600192508291505b846101000151821015614877575060005b8281101561485b578460800151866101200151828151811061476757614767615ed0565b6020026020010151850116866101200151838151811061478957614789615ed0565b6020026020010181815250508460800151866101a0015182815181106147b1576147b1615ed0565b6020026020010151850116866101a0015183815181106147d3576147d3615ed0565b60200260200101818152505061482d86610140015182815181106147f9576147f9615ed0565b60200260200101518760a001518760a001518151811061481b5761481b615ed0565b60200260200101518860000151611450565b866101400151838151811061484457614844615ed0565b602090810291909101015260019182019101614743565b60a085018051600019019052600193841c939290921b91614732565b600091505b84610100015182101561498c575060005b84610100015181101561495b57856101a0015182815181106148b1576148b1615ed0565b602002602001015186610120015182815181106148d0576148d0615ed0565b6020026020010151036148e95760a0850181905261495b565b856101a00151828151811061490057614900615ed0565b6020026020010151614942876101200151838151811061492257614922615ed0565b60200260200101518760600151600181901c919091016000199091011690565b036149535760a0850181905261495b565b60010161488d565b8460a001518660c00151838151811061497657614976615ed0565b602090810291909101015260019091019061487c565b600060c0868101829052603860308b8e01013590911c02909801605001976020905b87610240015189815181106149c5576149c5615ed0565b60200260200101518760c001511015614b0057600060e08801525b8661010001518760e001511015614ac1578760c001518760e0015181518110614a0b57614a0b615ed0565b60200260200101518760a001818152505060068760a00151901b8a019050876101a001518760e0015181518110614a4457614a44615ed0565b60200260200101518861012001518860a0015181518110614a6757614a67615ed0565b602002602001015103614a9157808c01358288510152602081018c01356020830188510152614aaa565b602081018c01358288510152808c013560208301885101525b60e0870180516001019052604091909101906149e0565b8760e00151600081518110614ad857614ad8615ed0565b60200260200101516005016001901b8a0199508660c0018051809190600101815250506149ae565b505050505050505050505050565b60208201819020600090612df8878787846151ef565b60386030828501013560c01c02810160408101906048015b905060088482013560c01c602002820101949350505050565b60005b8151811015614b88576000828281518110614b7557614b75615ed0565b6020908102919091010152600101614b58565b5050565b600080602085510285015b85811115614bb25783815185878509089150601f1901614b97565b50949350505050565b60008060008060018660e0015186610260015181518110614bde57614bde615ed0565b6020026020010151614bf09190615f93565b6001901b61010086015260208501516101208701518051600090614c1657614c16615ed0565b6020026020010181815250508460400151866101400151600081518110614c3f57614c3f615ed0565b602002602001018181525050614c6e85602001518760e00151876102600151815181106146cc576146cc615ed0565b866101a00151600081518110614c8657614c86615ed0565b60200260200101818152505060018561010001511115614dd257606085015160a08088015151600019019087015260021c9350600192508291505b846101000151821015614dd2575060005b82811015614db65784608001518661012001518281518110614cf657614cf6615ed0565b60200260200101518501168661012001518381518110614d1857614d18615ed0565b6020026020010181815250508460800151866101a001518281518110614d4057614d40615ed0565b6020026020010151850116866101a001518381518110614d6257614d62615ed0565b602002602001018181525050614d8886610140015182815181106147f9576147f9615ed0565b8661014001518381518110614d9f57614d9f615ed0565b602090810291909101015260019182019101614cd2565b60a085018051600019019052600193841c939290921b91614cc1565b600091505b846101000151821015614ec7575060005b846101000151811015614e9657856101a001518281518110614e0c57614e0c615ed0565b60200260200101518661012001518281518110614e2b57614e2b615ed0565b602002602001015103614e445760a08501819052614e96565b856101a001518281518110614e5b57614e5b615ed0565b6020026020010151614e7d876101200151838151811061492257614922615ed0565b03614e8e5760a08501819052614e96565b600101614de8565b8460a001518660c001518381518110614eb157614eb1615ed0565b6020908102919091010152600190910190614dd7565b600060e08601819052602097505b8561010001518660e001511015615053578660c001518660e0015181518110614f0057614f00615ed0565b60200260200101518660a0018181525050866101a001518660e0015181518110614f2c57614f2c615ed0565b60200260200101518761012001518760a0015181518110614f4f57614f4f615ed0565b602002602001015103614fce5785610180015160018760a00151901b81518110614f7b57614f7b615ed0565b6020026020010151905080888751015285610180015160018760a00151901b6001614fa69190615efc565b81518110614fb657614fb6615ed0565b6020026020010151905080602089018751015261503c565b85610180015160018760a00151901b6001614fe99190615efc565b81518110614ff957614ff9615ed0565b6020026020010151905080888751015285610180015160018760a00151901b8151811061502857615028615ed0565b602002602001015190508060208901875101525b60e086018051600101905260409790970196614ed5565b50505050505050505050565b806040015182610140015160008151811061507c5761507c615ed0565b6020026020010181815250506001816101c001511115614b8857606081015160a08301515160029190911c9060019081906000906150bb908390615f93565b60a08601525b846101c0015182101561513e575060005b82811015615122576150f486610140015182815181106147f9576147f9615ed0565b866101400151838151811061510b5761510b615ed0565b6020908102919091010152600191820191016150d2565b60a085018051600019019052600193841c939290921b916150c1565b505050505050565b600882019184013560c01c60005b8181101561513e5783860135836101800151828151811061517757615177615ed0565b60200260200101818152505061518d8460200190565b9350600101615154565b600881018382013560c01c60005b818110156151c2576151b8868685614b24565b92506001016151a5565b5050600881019084013560c01c60005b81811015614544576151e5868685615346565b92506001016151d2565b6000848301603081013560c090811c9160400135901c808015615219576001811461522257615227565b84602052615227565b846000525b50603885016000805b600185038110156152e857898301600881013560c090811c9550604090910135901c915083801561526857600181146152a2576152d8565b8a84016018013560005282801561528657600181146152935761529c565b604060002060205261529c565b60406000206000525b506152d8565b8a8401601801356020528280156152c057600181146152cd576152d6565b60406000206020526152d6565b60406000206000525b505b5060389290920191600101615230565b50508781016008013560c01c915081801561530a576001811461532057615332565b6018820189013560005260406000209550615332565b60188201890135602052604060002095505b505050505092016010013591909114919050565b600060386030838601013560c01c8102830101614b3c565b60405180604001604052806002906020820280368337509192915050565b60405180606001604052806003906020820280368337509192915050565b60008083601f8401126153ac57600080fd5b5081356001600160401b038111156153c357600080fd5b6020830191508360208285010111156153db57600080fd5b9250929050565b634e487b7160e01b600052604160045260246000fd5b60405161042081016001600160401b038111828210171561541b5761541b6153e2565b60405290565b604051606081016001600160401b038111828210171561541b5761541b6153e2565b6040516103c081016001600160401b038111828210171561541b5761541b6153e2565b604051601f8201601f191681016001600160401b038111828210171561548e5761548e6153e2565b604052919050565b6000602082840312156154a857600080fd5b604051602081018181106001600160401b03821117156154ca576154ca6153e2565b6040529135825250919050565b600060e082840312156154e957600080fd5b60405160e081018181106001600160401b038211171561550b5761550b6153e2565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a082015260c083013560c08201525092915050565b60006001600160401b03821115615573576155736153e2565b5060051b60200190565b600082601f83011261558e57600080fd5b813560206155a361559e8361555a565b615466565b82815260059290921b840181019181810190868411156155c257600080fd5b8286015b848110156155dd57803583529183019183016155c6565b509695505050505050565b600082601f8301126155f957600080fd5b8135602061560961559e8361555a565b82815260059290921b8401810191818101908684111561562857600080fd5b8286015b848110156155dd5780356001600160401b0381111561564b5760008081fd5b6156598986838b010161557d565b84525091830191830161562c565b6000610420828403121561567a57600080fd5b6156826153f8565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015260a08201356001600160401b03808211156156ca57600080fd5b6156d68583860161557d565b60a084015260c08401359150808211156156ef57600080fd5b6156fb8583860161557d565b60c084015260e084013591508082111561571457600080fd5b6157208583860161557d565b60e08401526101009150818401358181111561573b57600080fd5b6157478682870161557d565b83850152506101209150818401358181111561576257600080fd5b61576e8682870161557d565b83850152506101409150818401358181111561578957600080fd5b6157958682870161557d565b92840192909252610160848101359084015261018080850135908401526101a0915081840135818111156157c857600080fd5b6157d48682870161557d565b83850152506101c0915081840135818111156157ef57600080fd5b6157fb868287016155e8565b928401929092526101e08481013590840152610200808501359084015261022080850135908401526102409150818401358181111561583957600080fd5b6158458682870161557d565b92840192909252610260848101359084015261028080850135908401526102a080850135908401526102c080850135908401526102e080850135908401526103009150818401358181111561589957600080fd5b6158a5868287016155e8565b8385015250610320915081840135818111156158c057600080fd5b6158cc868287016155e8565b8385015250610340915081840135818111156158e757600080fd5b6158f38682870161557d565b83850152506103609150818401358181111561590e57600080fd5b61591a8682870161557d565b83850152506103809150818401358181111561593557600080fd5b615941868287016155e8565b83850152506103a0915081840135828401526103c09150818401358181111561596957600080fd5b6159758682870161557d565b83850152506103e09150818401358181111561599057600080fd5b61599c8682870161557d565b8385015250610400915081840135818111156159b757600080fd5b6159c38682870161557d565b8385015250505092915050565b6000606082840312156159e257600080fd5b6159ea615421565b905081358152602080830135818301526040808401356001600160401b0380821115615a1557600080fd5b818601915086601f830112615a2957600080fd5b8135615a3761559e8261555a565b818152600591821b840186019186820191908a841115615a5657600080fd5b8786015b84811015615adf57803586811115615a725760008081fd5b8701603f81018d13615a845760008081fd5b89810135615a9461559e8261555a565b81815290841b82018a01908b8101908f831115615ab15760008081fd5b928b01925b82841015615acf5783358252928c0192908c0190615ab6565b8752505050928801928801615a5a565b505080868901525050505050505092915050565b600082601f830112615b0457600080fd5b81356020615b1461559e8361555a565b82815260059290921b84018101918181019086841115615b3357600080fd5b8286015b848110156155dd5780356001600160401b03811115615b565760008081fd5b615b648986838b01016155e8565b845250918301918301615b37565b60006103c08284031215615b8557600080fd5b615b8d615443565b905081358152602082013560208201526040820135604082015260608201356001600160401b0380821115615bc157600080fd5b615bcd8583860161557d565b60608401526080840135608084015260a0840135915080821115615bf057600080fd5b615bfc8583860161557d565b60a084015260c084013560c084015260e084013560e084015261010091508184013581811115615c2b57600080fd5b615c3786828701615af3565b838501525061012091508184013581811115615c5257600080fd5b615c5e8682870161557d565b928401929092526101408481013590840152610160808501359084015261018080850135908401526101a080850135908401526101c080850135908401526101e08085013590840152610200808501359084015261022080850135908401526102408085013590840152610260808501359084015261028080850135908401526102a080850135908401526102c080850135908401526102e091508184013581811115615d0a57600080fd5b615d168682870161557d565b928401929092525050610300828101359082015261032080830135908201526103408083013590820152610360808301359082015261038080830135908201526103a09182013591810191909152919050565b600060c08284031215615d7b57600080fd5b60405160c081018181106001600160401b0382111715615d9d57615d9d6153e2565b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201525092915050565b600080600080600080600080610240898b031215615dff57600080fd5b88356001600160401b0380821115615e1657600080fd5b615e228c838d0161539a565b909a509850889150615e378c60208d01615496565b9750615e468c60408d016154d7565b96506101208b0135915080821115615e5d57600080fd5b615e698c838d01615667565b95506101408b0135915080821115615e8057600080fd5b615e8c8c838d016159d0565b94506101608b0135915080821115615ea357600080fd5b50615eb08b828c01615b72565b925050615ec18a6101808b01615d69565b90509295985092959890939650565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561140457611404615ee6565b6000600160ff1b8201615f2457615f24615ee6565b5060000390565b634e487b7160e01b600052601260045260246000fd5b808202811582820484141761140457611404615ee6565b600060018201615f6a57615f6a615ee6565b5060010190565b600082615f8e57634e487b7160e01b600052601260045260246000fd5b500690565b8181038181111561140457611404615ee656fea264697066735822122033c5e2a54883ea56c140aa32cdf31e0039541f9433eabeddde922352e2471bc364736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}