{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "blob",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "eval_proof_combined_value_offset",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "modulus",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "theta",
              "type": "uint256"
            }
          ],
          "internalType": "struct types.gate_argument_params",
          "name": "gate_params",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "witness_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "public_input_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "constant_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "selector_columns",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lookup_table_size",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "permutation_columns",
              "type": "uint256"
            }
          ],
          "internalType": "struct types.arithmetization_params",
          "name": "ar_params",
          "type": "tuple"
        },
        {
          "internalType": "int256[][]",
          "name": "columns_rotations",
          "type": "int256[][]"
        }
      ],
      "name": "evaluate_gates_be",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "gates_evaluation",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x5b44b42113c99554561452f0586825b07de2012e187a81bbf585eaea45233d09",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "382753",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x490ba5bc058bc216793b345c182be99449c89aaef4fcd5efd80c52cfdb1f4305",
    "transactionHash": "0x5b44b42113c99554561452f0586825b07de2012e187a81bbf585eaea45233d09",
    "logs": [],
    "blockNumber": 1,
    "cumulativeGasUsed": "382753",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "bb4d2b75948dfcdd8899ba193abaed54",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"blob\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"eval_proof_combined_value_offset\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"modulus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"theta\",\"type\":\"uint256\"}],\"internalType\":\"struct types.gate_argument_params\",\"name\":\"gate_params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"witness_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"public_input_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"constant_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"selector_columns\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lookup_table_size\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permutation_columns\",\"type\":\"uint256\"}],\"internalType\":\"struct types.arithmetization_params\",\"name\":\"ar_params\",\"type\":\"tuple\"},{\"internalType\":\"int256[][]\",\"name\":\"columns_rotations\",\"type\":\"int256[][]\"}],\"name\":\"evaluate_gates_be\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gates_evaluation\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/gates/gate_argument.sol\":\"gates_gate_argument_split_gen\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@nilfoundation/evm-placeholder-verification/contracts/algebra/field.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary field {\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(uint256 base, uint256 exponent, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        result = 1;\\n        assembly {\\n            for {let count := 1}\\n            lt(count, add(exponent, 0x01))\\n            {count := shl(1, count)} {\\n                if and(exponent, count) {\\n                    result := mulmod(result, base, modulus)\\n                }\\n                base := mulmod(base, base, modulus)\\n            }\\n        }\\n    }\\n\\n    /// @dev Modular inverse of a (mod p) using euclid.\\n    /// 'a' and 'p' must be co-prime.\\n    /// @param a The number.\\n    /// @param p The mmodulus.\\n    /// @return x such that ax = 1 (mod p)\\n    function invmod(uint256 a, uint256 p)\\n    internal pure returns (uint256) {\\n        require(a != 0 && a != p && p != 0);\\n        if (a > p)\\n            a = a % p;\\n        int256 t1;\\n        int256 t2 = 1;\\n        uint256 r1 = p;\\n        uint256 r2 = a;\\n        uint256 q;\\n        while (r2 != 0) {\\n            q = r1 / r2;\\n            (t1, t2, r1, r2) = (t2, t1 - int256(q) * t2, r2, r1 - q * r2);\\n        }\\n        if (t1 < 0)\\n            return (p - uint256(- t1));\\n        return uint256(t1);\\n    }\\n\\n    function fadd(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fsub(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(a, sub(modulus, b), modulus)\\n        }\\n    }\\n\\n    function fmul(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(a, b, modulus)\\n        }\\n    }\\n\\n    function fdiv(uint256 a, uint256 b, uint256 modulus)\\n    internal pure returns (uint256 result) {\\n        uint256 b_inv = invmod(b, modulus);\\n        assembly {\\n            result := mulmod(a, b_inv, modulus)\\n        }\\n    }\\n\\n    // See https://ethereum.stackexchange.com/questions/8086/logarithm-math-operation-in-solidity\\n    function log2(uint256 x)\\n    internal pure returns (uint256 y){\\n        assembly {\\n            let arg := x\\n            x := sub(x, 1)\\n            x := or(x, div(x, 0x02))\\n            x := or(x, div(x, 0x04))\\n            x := or(x, div(x, 0x10))\\n            x := or(x, div(x, 0x100))\\n            x := or(x, div(x, 0x10000))\\n            x := or(x, div(x, 0x100000000))\\n            x := or(x, div(x, 0x10000000000000000))\\n            x := or(x, div(x, 0x100000000000000000000000000000000))\\n            x := add(x, 1)\\n            let m := mload(0x40)\\n            mstore(m, 0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n            mstore(add(m, 0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n            mstore(add(m, 0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n            mstore(add(m, 0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n            mstore(add(m, 0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n            mstore(add(m, 0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n            mstore(add(m, 0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n            mstore(add(m, 0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n            mstore(0x40, add(m, 0x100))\\n            let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n            let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n            let a := div(mul(x, magic), shift)\\n            y := div(mload(add(m, sub(255, a))), shift)\\n            y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n        }\\n    }\\n\\n    function expmod_static(uint256 base, uint256 exponent, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), base) // Base.\\n            mstore(add(p, 0x80), exponent) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function inverse_static(uint256 val, uint256 modulus)\\n    internal view returns (uint256 res) {\\n        //        return expmod_static(val, modulus - 2, modulus); // code below similar to this call\\n        assembly {\\n            let p := mload(0x40)\\n            mstore(p, 0x20) // Length of Base.\\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\\n            mstore(add(p, 0x60), val) // Base.\\n            mstore(add(p, 0x80), sub(modulus, 0x02)) // Exponent.\\n            mstore(add(p, 0xa0), modulus) // Modulus.\\n        // Call modexp precompile.\\n            if iszero(staticcall(gas(), 0x05, p, 0xc0, p, 0x20)) {\\n                revert(0, 0)\\n            }\\n            res := mload(p)\\n        }\\n    }\\n\\n    function double(uint256 val, uint256 modulus) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mulmod(2, val, modulus)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x1b080c1ab40776cc82b25e6b40f00e033085fd3c9d06f735775076232d66ec76\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/algebra/polynomial.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"./field.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\n/**\\n * @title Turbo Plonk polynomial evaluation\\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\\n *\\n * Expected to be inherited by `TurboPlonk.sol`\\n */\\nlibrary polynomial {\\n    uint256 constant LENGTH_OCTETS = 8;\\n\\n    function multiply_poly_on_coeff(uint256[] memory coeffs, uint256 mul, uint256 modulus)\\n    internal pure{\\n        for(uint256 i = 0; i < coeffs.length; i++){\\n            coeffs[i] = mulmod(coeffs[i], mul, modulus);\\n        }\\n    }\\n\\n    /*\\n      Computes the evaluation of a polynomial f(x) = sum(a_i * x^i) on the given point.\\n      The coefficients of the polynomial are given in\\n        a_0 = coefsStart[0], ..., a_{n-1} = coefsStart[n - 1]\\n      where n = nCoeffs = friLastLayerDegBound. Note that coefsStart is not actually an array but\\n      a direct pointer.\\n      The function requires that n is divisible by 8.\\n    */\\n    function evaluate(uint256[] memory coeffs, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        assembly {\\n            let cur_coefs := add(coeffs, mul(mload(coeffs), 0x20))\\n            for { } gt(cur_coefs, coeffs) {} {\\n                result := addmod(mulmod(result, point, modulus),\\n                                mload(cur_coefs), // (i - 1) * 32\\n                                modulus)\\n                cur_coefs := sub(cur_coefs, 0x20)\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function evaluate_by_ptr(bytes calldata blob, uint256 offset, uint256 len, uint256 point, uint256 modulus)\\n    internal pure returns (uint256) {\\n        uint256 result;\\n        for (uint256 i = len; i > 0;) {\\n            assembly {\\n                result := addmod(mulmod(result, point, modulus),\\n                                 calldataload(add(add(blob.offset, offset), shl(0x05, sub(i, 0x01)))), // (i - 1) * 32\\n                                 modulus)\\n            }\\n            unchecked{ i--; }\\n        }\\n//        assembly {\\n//            let i := sub(add(blob.offset, add(offset, mul(len, 0x20))), 0x20)\\n//            let coeff := sub(add(blob.offset, offset), 0x20)\\n//            for { } gt(coefsPtr, coeff) {} {\\n//                result := addmod(mulmod(result, point, modulus), calldataload(coefsPtr), modulus)\\n//                coefsPtr := sub(coefsPtr, 0x20)\\n//            }\\n//        }\\n        return result;\\n    }\\n\\n    function add_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        if (a.length < b.length) {\\n            result = new uint256[](b.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(b, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        } else {\\n            result = new uint256[](a.length);\\n            assembly {\\n                let i := 0\\n                for {} lt(i, mul(mload(b), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    addmod(mload(add(add(a, 0x20), i)), mload(add(add(b, 0x20), i)), modulus)\\n                    )\\n                }\\n                for {} lt(i, mul(mload(a), 0x20)) {\\n                    i := add(i, 0x20)\\n                } {\\n                    mstore(\\n                    add(add(result, 0x20), i),\\n                    mload(add(a, add(0x20, i)))\\n                    )\\n                }\\n            }\\n        }\\n    }\\n\\n    function mul_poly(uint256[] memory a, uint256[] memory b, uint256 modulus)\\n    internal pure returns (uint256[] memory result) {\\n        result = new uint256[](a.length + b.length - 1);\\n        for (uint256 i = 0; i < b.length;) {\\n            for (uint256 j = 0; j < a.length;) {\\n                assembly {\\n                    mstore(add(add(result, 0x20), mul(add(j, i), 0x20)),\\n                           addmod(mload(add(add(result, 0x20), mul(add(j, i), 0x20))),\\n                                   mulmod(mload(add(add(a, 0x20), mul(j, 0x20))),\\n                                          mload(add(add(b, 0x20), mul(i, 0x20))), modulus),\\n                                   modulus)\\n                    )\\n                }\\n                unchecked{ j++; }\\n            }\\n            unchecked{ i++; }\\n        }\\n        return result;\\n    }\\n\\n    function lagrange_interpolation(\\n        uint256[] memory xs,\\n        uint256[] memory fxs,\\n        uint256 modulus\\n    ) internal pure returns (uint256[] memory result) {\\n        require(xs.length == fxs.length);\\n        uint256 len = fxs.length;\\n        for (uint256 i = 0; i < len;) {\\n            uint256[] memory thisPoly = new uint256[](1);\\n            thisPoly[0] = 1;\\n            for (uint256 j = 0; j < len;) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                uint256 denominator = field.fsub(xs[i], xs[j], modulus);\\n                uint256[] memory thisTerm = new uint256[](2);\\n                thisTerm[0] = field.fdiv(modulus - xs[j], denominator, modulus);\\n                thisTerm[1] = field.fdiv(uint256(1), denominator, modulus);\\n                thisPoly = mul_poly(thisPoly, thisTerm, modulus);\\n                unchecked{ j++; }\\n            }\\n            if (fxs.length + 1 >= i) {\\n                uint256[] memory multiple = new uint256[](1);\\n                multiple[0] = fxs[i];\\n                thisPoly = mul_poly(thisPoly, multiple, modulus);\\n            }\\n            result = add_poly(result, thisPoly, modulus);\\n            unchecked { i++; }\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points_neg_x(uint256 x, uint256 dblXInv, uint256 fX, uint256 fMinusX,\\n                                                    uint256 evalPoint, uint256 modulus\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            result := addmod(\\n                mulmod(\\n                    mulmod(\\n                        addmod(fX, sub(modulus, fMinusX), modulus),\\n                        dblXInv,\\n                        modulus\\n                    ),\\n                    addmod(evalPoint, sub(modulus, x), modulus),\\n                    modulus\\n                ),\\n                fX,\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256 result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                mload(add(fx, 0x40)),\\n                sub(modulus, mload(add(fx, 0x20))),\\n                modulus\\n            )\\n            let x3_minus_x1 := addmod(\\n                eval_point,\\n                sub(modulus, mload(add(x, 0x20))),\\n                modulus\\n            )\\n            result := addmod(\\n                mulmod(\\n                    mulmod(y2_minus_y1, x2_minus_x1_inv, modulus),\\n                    x3_minus_x1,\\n                    modulus\\n                ),\\n                mload(add(fx, 0x20)),\\n                modulus\\n            )\\n        }\\n    }\\n\\n    function interpolate_evaluate(uint256[] memory x, uint256[] memory fx, uint256 eval_point, uint256 modulus)\\n    internal view returns (uint256) {\\n        if (x.length == 1 && fx.length == 1) {\\n            return fx[0];\\n        }\\n        if (x.length == 2) {\\n            return interpolate_evaluate_by_2_points(x, fx, eval_point, modulus);\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n        return 0;\\n    }\\n\\n    function interpolate_by_2_points(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(fx.length == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n        assembly {\\n            let y2_minus_y1 := addmod(mload(add(fx, 0x40)), sub(modulus, mload(add(fx, 0x20))), modulus)\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(modulus, mulmod(a, mload(add(x, 0x20)), modulus))\\n            let b := addmod(mload(add(fx, 0x20)), a_mul_x1_neg, modulus)\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(uint256[] memory x, uint256[] memory fx, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && fx.length == 1) {\\n            result = new uint256[](1);\\n            result[0] = fx[0];\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(x, fx, modulus);\\n            return result;\\n        } else {\\n            require(false, \\\"unsupported number of points for interpolation\\\");\\n        }\\n    }\\n\\n    function interpolate_by_2_points(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        require(x.length == 2, \\\"x length is not equal to 2\\\");\\n        require(basic_marshalling.get_length(blob, fx_offset) == 2, \\\"fx length is not equal to 2\\\");\\n        uint256 x2_minus_x1_inv = field.inverse_static((x[1] + (modulus - x[0])) % modulus, modulus);\\n        result = new uint256[](2);\\n\\n        assembly {\\n            let y2_minus_y1 := addmod(\\n                calldataload(\\n                    add(blob.offset, add(add(fx_offset, LENGTH_OCTETS), 0x20))\\n                ),\\n                sub(\\n                    modulus,\\n                    calldataload(\\n                        add(blob.offset, add(fx_offset, LENGTH_OCTETS))\\n                    )\\n                ),\\n                modulus\\n            )\\n            let a := mulmod(y2_minus_y1, x2_minus_x1_inv, modulus)\\n            let a_mul_x1_neg := sub(\\n                modulus,\\n                mulmod(a, mload(add(x, 0x20)), modulus)\\n            )\\n            let b := addmod(\\n                calldataload(add(blob.offset, add(fx_offset, LENGTH_OCTETS))),\\n                a_mul_x1_neg,\\n                modulus\\n            )\\n            mstore(add(result, 0x20), b)\\n            mstore(add(result, 0x40), a)\\n        }\\n    }\\n\\n    function interpolate(bytes calldata blob, uint256[] memory x, uint256 fx_offset, uint256 modulus)\\n    internal view returns (uint256[] memory result) {\\n        if (x.length == 1 && basic_marshalling.get_length(blob, fx_offset) == 1) {\\n            result = new uint256[](1);\\n            result[0] = basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0);\\n            return result;\\n        } else if (x.length == 2) {\\n            result = interpolate_by_2_points(blob, x, fx_offset, modulus);\\n            return result;\\n        } else if (x.length == 3) {\\n            uint256 y0 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 0), field.fmul(field.fsub(x[0], x[1],modulus), field.fsub(x[0], x[2],modulus), modulus), modulus);\\n            uint256 y1 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 1), field.fmul(field.fsub(x[1], x[0],modulus), field.fsub(x[1], x[2],modulus), modulus), modulus);\\n            uint256 y2 = field.fdiv(basic_marshalling.get_i_uint256_from_vector(blob, fx_offset, 2), field.fmul(field.fsub(x[2], x[0],modulus), field.fsub(x[2], x[1],modulus), modulus), modulus);\\n\\n            result = new uint256[](3);\\n            assembly {\\n                let x1 := mulmod(y0, mulmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus), modulus)\\n                let x2 := mulmod(y1, mulmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus), modulus)\\n                let x3 := mulmod(y2, mulmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus), modulus)\\n                mstore(add(result, 0x20), addmod(addmod(x1, x2, modulus), x3, modulus))\\n\\n                x1 := mulmod(y0, sub(modulus, addmod(mload(add(x, 0x40)), mload(add(x, 0x60)), modulus)), modulus)\\n                x2 := mulmod(y1, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x60)), modulus)), modulus)\\n                x3 := mulmod(y2, sub(modulus, addmod(mload(add(x, 0x20)), mload(add(x, 0x40)), modulus)), modulus)\\n                mstore(add(result, 0x40), addmod(addmod(x1, x2, modulus), x3, modulus))\\n                mstore(add(result, 0x60), addmod(addmod(y0, y1, modulus), y2, modulus))\\n            }\\n            return result;\\n        }\\n        require(false, \\\"unsupported number of points for interpolation\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x6d1a3ab64f2c88e343188f0fec990332e21f8062edf88a6ecf5ead6113d23329\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nlibrary basic_marshalling {\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n    uint256 constant LENGTH_OCTETS_ADD_32 = 40;\\n\\n    //================================================================================================================\\n    // Bounds non-checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n    }\\n\\n    function get_octet_vector_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := mload(add(add(blob.offset, offset), LENGTH_OCTETS))\\n        }\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_uint256_be(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n    }\\n\\n    function skip_vector_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_v_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n    \\n    function skip_vv_of_vectors_of_vectors_of_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 n = get_length(blob, offset);\\n        result_offset = skip_length(offset);\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_v_of_vectors_of_vectors_of_uint256_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n\\n    function skip_length(uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n    }\\n\\n    function get_skip_length(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset){\\n        assembly {\\n            result_length := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, offset)))\\n        }\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n    }\\n\\n    function get_i_uint256_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20))))\\n        }\\n    }\\n\\n    function get_i_bytes32_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (bytes32 result) {\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        assembly {\\n            result_ptr := add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_true(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n        unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length(offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector(blob, offset, j);\\n    }\\n\\n    function get_uint256_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result) {\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n\\n    //================================================================================================================\\n    // Bounds checking functions\\n    //================================================================================================================\\n    // TODO: general case\\n    function skip_octet_vector_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS_ADD_32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    // TODO: general case\\n    function skip_vector_of_octet_vectors_32_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LENGTH_OCTETS_ADD_32,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(add(blob.offset, offset))\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + 32; }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        assembly {\\n            result_offset := add(\\n                add(\\n                    offset,\\n                    mul(\\n                        0x20,\\n                        shr(\\n                            LENGTH_RESTORING_SHIFT,\\n                            calldataload(add(blob.offset, offset))\\n                        )\\n                    )\\n                ),\\n                LENGTH_OCTETS\\n            )\\n        }\\n        require(result_offset <= blob.length);\\n    }\\n\\n    function skip_vector_of_vectors_of_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        uint256 n;\\n        assembly {\\n            n := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n        for (uint256 i = 0; i < n;) {\\n            result_offset = skip_vector_of_uint256_be_check(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset < blob.length);\\n    }\\n\\n    function get_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length){\\n        require(offset + LENGTH_OCTETS <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_skip_length_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_length, uint256 result_offset) {\\n        unchecked { result_offset = offset + LENGTH_OCTETS; }\\n        require(result_offset <= blob.length);\\n        assembly {\\n            result_length := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(add(blob.offset, offset))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(\\n                add(blob.offset, add(add(offset, LENGTH_OCTETS), mul(i, 0x20)))\\n            )\\n        }\\n    }\\n\\n    function get_i_uint256_ptr_from_vector_check(bytes calldata blob, uint256 offset, uint256 i)\\n    internal pure returns (uint256 result_ptr) {\\n        require(offset + LENGTH_OCTETS + (i + 1) * 0x20 <= blob.length);\\n        assembly {\\n            result_ptr := add(\\n                blob.offset,\\n                add(add(offset, LENGTH_OCTETS), mul(i, 0x20))\\n            )\\n        }\\n    }\\n\\n    function get_i_j_uint256_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result = get_i_uint256_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_i_j_uint256_ptr_from_vector_of_vectors_check(bytes calldata blob, uint256 offset, uint256 i, uint256 j)\\n    internal pure returns (uint256 result_ptr) {\\n        offset = skip_length_check(blob, offset);\\n        for (uint256 _i = 0; _i < i;) {\\n            offset = skip_vector_of_uint256_be_check(blob, offset);\\n            unchecked{ _i++; }\\n        }\\n        result_ptr = get_i_uint256_ptr_from_vector_check(blob, offset, j);\\n    }\\n\\n    function get_uint256_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result){\\n        require(offset + 0x20 <= blob.length);\\n        assembly {\\n            result := calldataload(add(blob.offset, offset))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x4b8bda89ed07c52d7f8d59c4ed34475322d8478d087136eee6bc46efa43d964d\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_fri_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../containers/merkle_verifier.sol\\\";\\nimport \\\"../cryptography/transcript.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\n\\nlibrary batched_fri_verifier {\\n    uint256 constant FRI_PARAMS_COEFFS_OFFSET = 0x280;\\n\\n    uint256 constant S1_OFFSET = 0x00;                                      \\n    uint256 constant X_OFFSET = 0x20;                                      \\n    uint256 constant ALPHA_OFFSET = 0x40;                                   // alpha challenge\\n    uint256 constant COEFFS_OFFSET = 0x60;\\n    uint256 constant Y_OFFSET = 0x80;\\n    uint256 constant COLINEAR_OFFSET = 0xa0;                                // colinear_value_offset\\n    uint256 constant C1_OFFSET = 0xc0;                                      // coefficient1_offset\\n    uint256 constant C2_OFFSET = 0xe0;                                      // coefficient2_offset\\n    uint256 constant INTERPOLANT_OFFSET = 0x100;\\n    uint256 constant PREV_COEFFS_LEN_OFFSET = 0x120;\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for (uint256 i = 0; i < value_len;) {\\n            result_offset = skip_query_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        // fri_roots\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.step_list.length ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        fri_params.fri_roots = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.fri_roots[i] = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(result_offset));\\n            result_offset = basic_marshalling.skip_octet_vector_32_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n        // final_polynomial\\n        fri_params.fri_final_poly_offset = result_offset;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n\\n        if( value_len > (( 1 << (field.log2(fri_params.max_degree + 1) - fri_params.r + 1) ) ) ){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        fri_params.final_polynomial = new uint256[](value_len);\\n        for (uint256 i = 0; i < value_len;) {\\n            fri_params.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, result_offset);\\n            result_offset = basic_marshalling.skip_uint256_be(result_offset);\\n            unchecked{ i++; }\\n        }\\n\\n        // query_proofs\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        fri_params.fri_cur_query_offset = result_offset;\\n        if( value_len != fri_params.lambda ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n\\n        for (uint256 i = 0; i < value_len;) {\\n            (success, result_offset) = parse_query_proof_be(fri_params, blob, result_offset);\\n            if(!success) return(success, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_query_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset){\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_initial_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        for(uint256 i = 0; i < value_len;){\\n            result_offset = skip_round_proof_be(blob, result_offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function parse_query_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset){\\n        success = true;\\n        uint256 value_len;\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( value_len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_initial_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n        (value_len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( value_len != fri_params.step_list.length){\\n            success = false;\\n            return( success, result_offset);\\n        }\\n        for(uint256 i = 0; i < value_len;){\\n            (success, result_offset) = parse_round_proof_be(fri_params, i, blob, result_offset);\\n            if( !success ) return(success, result_offset );\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function skip_initial_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        // coset_size\\n        result_offset = basic_marshalling.skip_length(result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_initial_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // polynomials num\\n        uint256 len;\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != fri_params.batches_sizes[i] ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // coset_size\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, result_offset);\\n        if( len != (1 << fri_params.step_list[0]) ) {\\n            success = false;\\n            return(success, result_offset);\\n        }\\n        // values\\n        len = basic_marshalling.get_length(blob, result_offset);\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n        if(len != fri_params.batches_sizes[i] * (1 << fri_params.step_list[0])){\\n            success = false;\\n            return(success, result_offset);\\n        }\\n    }\\n\\n    function skip_round_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns(uint256 result_offset){\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    function parse_round_proof_be(types.fri_params_type memory fri_params, uint256 i, bytes calldata blob, uint256 offset)\\n    internal pure returns(bool success, uint256 result_offset){\\n        success = true;\\n        // p;\\n        result_offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        // y;\\n        if( i < fri_params.step_list.length - 1){\\n            if( basic_marshalling.get_length(blob, result_offset) != (1 << fri_params.step_list[i+1]) ){\\n                success = false;\\n                return(success, result_offset);\\n            }\\n        }else{\\n            if( basic_marshalling.get_length(blob, result_offset) != 2 ){\\n                success = false;\\n                return( success, result_offset);\\n            }\\n        }\\n        result_offset = basic_marshalling.skip_vector_of_uint256_be(blob, result_offset);\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns(uint256[] memory roots){\\n        roots = new uint256[](fri_params.batches_num);\\n        uint256 offset = fri_params.fri_cur_query_offset;\\n        offset = basic_marshalling.skip_length(offset);\\n        for( uint256 i = 0; i < fri_params.batches_num;){\\n            roots[i] = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n            offset = skip_initial_proof_be(blob, offset);\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    // if x_index is index of x, then paired_index is index of -x\\n    function get_paired_index(uint256 x_index, uint256 domain_size)\\n    internal pure returns(uint256 result ){\\n        unchecked{ result = (x_index + (domain_size >> 1)) & (domain_size - 1); }\\n    }\\n\\n    // calculate indices for coset S = {s\\\\in D| s^(2^fri_step) == x_next}\\n    function get_folded_index(uint256 x_index, uint256 fri_step, uint256 domain_size_mod) \\n    internal pure returns(uint256 result){\\n        unchecked{result = x_index & (domain_size_mod >> fri_step);}\\n    }\\n  \\n    function calculate_s(\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars) internal pure{\\n\\n        fri_params.s[0] = local_vars.x;\\n        if( local_vars.coset_size > 1){\\n            uint256 base_index = local_vars.domain_size >> 2; \\n            uint256 prev_half_size = 1;\\n            uint256 i = 1;\\n            uint256 j;\\n            local_vars.newind = fri_params.D_omegas.length - 1;\\n            while( i < local_vars.coset_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n    }\\n\\n    function prepare_initial_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,\\n        uint256 k,                                              // current batch index\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[0] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[0], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 first_offset = 0x20;\\n        uint256 y_offset;\\n\\n        offset = merkle_verifier.skip_merkle_proof_be(blob, offset);\\n        offset = basic_marshalling.skip_length(offset);             // Skip polynomial number\\n        offset = basic_marshalling.skip_length(offset);             // Skip coset size\\n        offset = basic_marshalling.skip_length(offset);             // Skip y length\\n        for (local_vars.p_ind = 0; local_vars.p_ind < fri_params.batches_sizes[k];) {\\n            for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n                local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n                // Check leaf size\\n                // Prepare y-s\\n                unchecked{ y_offset = offset + ( local_vars.newind << 6 ); }\\n\\n                // push y\\n                if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                    }\\n                } else {\\n                    assembly{\\n                        mstore(\\n                            add(mload(local_vars),first_offset), \\n                            calldataload(add(blob.offset, add(y_offset, 0x20)))\\n                        )\\n                        mstore(\\n                            add(mload(local_vars),add(first_offset, 0x20)), \\n                            calldataload(add(blob.offset, y_offset))\\n                        )\\n                    }\\n                }\\n                unchecked{ \\n                    local_vars.y_ind++; \\n                    first_offset += 0x40;\\n                }\\n            }\\n            unchecked{ offset += (1<<(fri_params.step_list[0]+5)); local_vars.p_ind++; }\\n        }\\n    }\\n\\n    // For round proofs\\n    //     Reorder local_vars.values and push to local_vars.b\\n    function prepare_leaf_data(\\n        bytes calldata blob,\\n        uint256 offset,                                         // round proof offset\\n        types.fri_params_type memory fri_params,\\n        types.fri_state_type memory local_vars\\n    ) internal pure {\\n        uint256 base_index;\\n        uint256 prev_half_size;\\n        uint256 i;\\n        uint256 j;\\n\\n        local_vars.indices_size = 1 << (fri_params.step_list[local_vars.step] - 1);\\n        \\n        fri_params.s_indices[0] = local_vars.x_index;\\n        fri_params.s[0] = local_vars.x;\\n        fri_params.tmp_arr[0] = get_folded_index(local_vars.x_index, fri_params.step_list[local_vars.step], local_vars.domain_size_mod);\\n\\n        // Fill s and s_indices\\n        if( local_vars.indices_size > 1){\\n            unchecked{\\n                base_index = local_vars.domain_size >> 2; \\n                prev_half_size = 1;\\n                i = 1;\\n                local_vars.newind = fri_params.D_omegas.length - 1;\\n            }\\n            while( i < local_vars.indices_size ){\\n                for( j = 0; j < prev_half_size;) {\\n                    unchecked{\\n                        fri_params.s_indices[i] = (base_index + fri_params.s_indices[j]) & local_vars.domain_size_mod;\\n                        fri_params.tmp_arr[i]   = (base_index + fri_params.tmp_arr[j]) & local_vars.domain_size_mod;\\n                    }\\n                    fri_params.s[i] = field.fmul(fri_params.s[j], fri_params.D_omegas[local_vars.newind], fri_params.modulus);\\n                    unchecked{ i++; } // TODO: is it really here? Yes, it is))\\n                    unchecked{ j++; }\\n                }\\n                unchecked{\\n                    base_index >>=1;\\n                    prev_half_size <<=1;\\n                    local_vars.newind--;\\n                }\\n            }\\n        }\\n\\n        // Fill correct_order_idx\\n        for ( i = 0; i < local_vars.indices_size;) {\\n            for(j = 0; j < local_vars.indices_size;){\\n                if(fri_params.s_indices[j] == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                if(get_paired_index(fri_params.s_indices[j], local_vars.domain_size) == fri_params.tmp_arr[i]){\\n                    local_vars.newind = j;\\n                    break;\\n                }\\n                unchecked{ j++; }\\n            }\\n            fri_params.correct_order_idx[i] = local_vars.newind;\\n            unchecked{ i++; }\\n        }\\n\\n        uint256 y;\\n        offset = 0x20;\\n        for(local_vars.y_ind = 0; local_vars.y_ind < local_vars.indices_size;){\\n            local_vars.newind = fri_params.correct_order_idx[local_vars.y_ind];\\n            // Check leaf size\\n            // Prepare y-s\\n\\n            // push y\\n            if(fri_params.s_indices[local_vars.newind] == fri_params.tmp_arr[local_vars.y_ind]){\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            } else {\\n                y = local_vars.values[(local_vars.newind<<1)+1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars), offset), y\\n                    )\\n                }\\n                y = local_vars.values[local_vars.newind<<1];\\n                assembly{\\n                    mstore(\\n                        add(mload(local_vars),add(offset, 0x20)), y\\n                    )\\n                }\\n            }\\n            unchecked{ \\n                local_vars.y_ind++; \\n                offset += 0x40;\\n            }\\n        }\\n    }\\n\\n    function clear_values( uint256[] memory values )\\n    internal pure{\\n        for( uint256 i = 0; i < values.length;){\\n            values[i] = 0;\\n            unchecked{ i++; }\\n        }\\n    }\\n\\n    function load_values( bytes calldata blob, uint256 offset, types.fri_state_type memory local_vars )\\n    internal pure{\\n        uint256 len;\\n        (len, offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( uint256 i = 0; i < len;){\\n            local_vars.values[i] = basic_marshalling.get_uint256_be(blob, offset);\\n            offset = basic_marshalling.skip_uint256_be(offset);\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob, \\n        uint256[] memory roots,\\n        types.transcript_data memory tr_state,\\n        types.fri_params_type memory fri_params\\n    ) internal view returns (bool result) {\\n        types.fri_state_type memory local_vars;\\n\\n        // TODO strange bug. If we we exchange two next lines, then it will not work.\\n        local_vars.alphas = new uint256[](fri_params.r);\\n        local_vars.b = new bytes(0x40 * fri_params.max_batch * fri_params.max_coset);\\n\\n        uint256 offset;\\n        uint256 ind;\\n        uint256 k;\\n        uint256 i;\\n\\n        offset = basic_marshalling.skip_length(fri_params.fri_proof_offset);\\n        offset = basic_marshalling.skip_length(offset);\\n        for( ind = 0; ind < fri_params.step_list.length;){\\n            transcript.update_transcript_b32_by_offset_calldata(tr_state, blob, offset);\\n            for( uint256 round = 0; round < fri_params.step_list[ind];){\\n                local_vars.alphas[local_vars.cur] = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n                unchecked{ round++; local_vars.cur++;}\\n            }\\n            offset = basic_marshalling.skip_octet_vector_32_be(offset);\\n            unchecked{ind++;}\\n        }\\n\\n        for( local_vars.query_id = 0; local_vars.query_id < fri_params.lambda;){\\n            // It'll be init_vars function next\\n            unchecked{ local_vars.domain_size = 1 << (fri_params.D_omegas.length + 1); }\\n            unchecked{ local_vars.domain_size_mod = local_vars.domain_size - 1; }\\n            local_vars.x_index = transcript.get_integral_challenge_be(tr_state, 8) & local_vars.domain_size_mod;\\n            local_vars.x = field.expmod_static(\\n                fri_params.D_omegas[0],\\n                local_vars.x_index,\\n                fri_params.modulus\\n            );\\n\\n            // Check initial proofs\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                // Check merkle local_vars.roots\\n                local_vars.root = merkle_verifier.get_merkle_root_from_proof(blob, offset);\\n                if( local_vars.root != roots[k] ){\\n                    return false;\\n                }\\n                prepare_initial_leaf_data(blob, offset, k, fri_params, local_vars);\\n                local_vars.b_length = (fri_params.batches_sizes[k] << (fri_params.step_list[0] +5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n                offset = skip_initial_proof_be(blob, offset);\\n                // Check merkle proofs\\n                unchecked{k++;}\\n            }\\n\\n            // Construct ys for the first round\\n            local_vars.coset_size = 1 << fri_params.step_list[0];\\n            local_vars.values = new uint256[](1 << fri_params.max_step);\\n            local_vars.tmp_values = new uint256[](1 << fri_params.max_step);\\n\\n            for( ind = 0; ind < fri_params.different_points;){                \\n                offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                offset = basic_marshalling.skip_length(offset);\\n                clear_values(local_vars.tmp_values);\\n                local_vars.cur = 0;\\n                for( k = 0; k < fri_params.batches_num;){\\n                    for( i = 0; i < fri_params.batches_sizes[k];){\\n                        polynomial.multiply_poly_on_coeff(local_vars.tmp_values,fri_params.theta, fri_params.modulus);\\n                        if( fri_params.eval_map[local_vars.cur] == ind ){\\n                            for( uint256 j = 0; j < local_vars.coset_size;){\\n                                local_vars.tmp_values[j] = addmod(\\n                                    local_vars.tmp_values[j], \\n                                    basic_marshalling.get_uint256_be(blob, offset),\\n                                    fri_params.modulus\\n                                );\\n                                offset = basic_marshalling.skip_uint256_be(offset);\\n                                unchecked{ j++; }\\n                            }\\n                        } else {\\n                            offset += (local_vars.coset_size << 5);\\n                        }\\n                        unchecked{ i++; local_vars.cur++;} \\n                    }\\n                    offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    offset = basic_marshalling.skip_length(offset);\\n                    unchecked{ k++; }\\n                }\\n\\n                for( uint256 j = 0; j < local_vars.coset_size; j++){\\n                    if( j & 1 == 0 )\\n                        { local_vars.s = fri_params.s[j>>1];}\\n                    else\\n                        { local_vars.s = fri_params.modulus - fri_params.s[j>>1];}\\n                    local_vars.tmp_values[j] = addmod(\\n                        mulmod( local_vars.tmp_values[j], fri_params.factors[ind], fri_params.modulus),\\n                        fri_params.modulus - polynomial.evaluate(fri_params.combined_U[ind], local_vars.s, fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                    // TODO Denominators for all s can be precomputed. It doesn't depend on polynomial.\\n                    local_vars.tmp_values[j] = mulmod(\\n                        local_vars.tmp_values[j],\\n                        field.inverse_static(\\n                            polynomial.evaluate(fri_params.denominators[ind], local_vars.s, fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        fri_params.modulus\\n                    );\\n                    local_vars.values[j] = addmod(local_vars.values[j], local_vars.tmp_values[j], fri_params.modulus);\\n                }\\n                unchecked{ind++;}\\n            }\\n\\n            offset = basic_marshalling.skip_length(fri_params.fri_cur_query_offset);\\n            for( k = 0; k < fri_params.batches_num; ){\\n                offset = skip_initial_proof_be(blob, offset);\\n                unchecked{k++;}\\n            }\\n\\n            // Round proofs check\\n            local_vars.cur = 0;\\n            offset = basic_marshalling.skip_length(offset);\\n\\n            for( local_vars.step = 0; local_vars.step < fri_params.step_list.length;){\\n                // Merkle check;\\n                local_vars.fri_root = basic_marshalling.get_uint256_be(blob, basic_marshalling.skip_length(offset) + 0x8);\\n                if( local_vars.fri_root != fri_params.fri_roots[local_vars.step]) {\\n                    return false;\\n                }\\n\\n                local_vars.coset_size = 1 << fri_params.step_list[local_vars.step];\\n                prepare_leaf_data(blob, offset, fri_params, local_vars);\\n                local_vars.b_length = (1 << (fri_params.step_list[local_vars.step] + 5));\\n                if (!merkle_verifier.parse_verify_merkle_proof_bytes_be(\\n                    blob, offset, local_vars.b, local_vars.b_length\\n                )) {\\n                    return false;\\n                }\\n\\n                // Colinear check;\\n                local_vars.factor = 1;\\n                for( local_vars.round = 0; local_vars.round < fri_params.step_list[local_vars.step];){\\n                    local_vars.coset_size >>= 1;\\n                    calculate_s(fri_params, local_vars);\\n                    local_vars.domain_size >>= 1;\\n                    local_vars.domain_size_mod >>= 1;\\n                    local_vars.x_index &= local_vars.domain_size_mod;\\n                    local_vars.x = mulmod(local_vars.x, local_vars.x, fri_params.modulus);\\n                    if( local_vars.round == 0){\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, fri_params.modulus-local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            local_vars.values[j] = mulmod(\\n                                local_vars.values[j], \\n                                fri_params.s[j],\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    } else {\\n                        for( uint256 j = 0; j < local_vars.coset_size;){\\n                            local_vars.f0 = local_vars.values[j<<1];\\n                            local_vars.f1 = local_vars.values[(j<<1) + 1];\\n                            local_vars.values[j] = addmod(local_vars.f0, fri_params.modulus - local_vars.f1, fri_params.modulus);\\n                            local_vars.values[j] = mulmod(local_vars.values[j], fri_params.s[j], fri_params.modulus);\\n                            local_vars.values[j] = addmod(\\n                                local_vars.values[j], \\n                                mulmod(\\n                                    local_vars.alphas[local_vars.cur],\\n                                    addmod(local_vars.f0, local_vars.f1, fri_params.modulus), \\n                                    fri_params.modulus\\n                                ),\\n                                fri_params.modulus\\n                            );\\n                            unchecked{ j++; }\\n                        }\\n                        local_vars.factor = mulmod(local_vars.factor, 2, fri_params.modulus);\\n                    }\\n                    unchecked{local_vars.round++; local_vars.cur++;}\\n                }\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.factor = mulmod(local_vars.factor, fri_params.s[0], fri_params.modulus);\\n                local_vars.interpolant = local_vars.values[0];\\n\\n                offset = merkle_verifier.skip_merkle_proof_be(blob,offset);\\n                load_values(blob, offset, local_vars);\\n                if( local_vars.interpolant != mulmod(local_vars.factor, local_vars.values[0], fri_params.modulus) ){\\n                    return false;\\n                }\\n                offset = basic_marshalling.skip_vector_of_uint256_be(blob, offset);\\n                unchecked{local_vars.step++;}\\n            }\\n\\n            // Final polynomial check. Final polynomial degree is already checked while parsing process\\n            if( polynomial.evaluate(fri_params.final_polynomial, local_vars.x, fri_params.modulus) != local_vars.values[0]){\\n                return false;\\n            }\\n            if( polynomial.evaluate(fri_params.final_polynomial, fri_params.modulus-local_vars.x, fri_params.modulus) != local_vars.values[1]){\\n                return false;\\n            }\\n            \\n            fri_params.fri_cur_query_offset = skip_query_proof_be(blob, fri_params.fri_cur_query_offset);\\n            unchecked{local_vars.query_id++;}\\n        }\\n        return true;\\n    }\\n}\",\"keccak256\":\"0xfd95c69c0d5359a10aaad33b60b1480a4e941b54d2749630149cdc56d08c901f\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_lpc_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2022-2023 Elena Tatuzova <e.tatuzova@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"./batched_fri_verifier.sol\\\";\\nimport \\\"../algebra/polynomial.sol\\\";\\nimport \\\"../basic_marshalling.sol\\\";\\n\\nlibrary batched_lpc_verifier {\\n\\n    uint256 constant m = 2;\\n\\n    function skip_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        uint256 i;\\n        uint256 len;\\n        // z\\n        \\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        for( i = 0; i < len; ){\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        result_offset = batched_fri_verifier.skip_proof_be(blob, result_offset);\\n    }\\n\\n    // Check proof data carefully.\\n    // Load necessary offsets to fri params\\n    function parse_proof_be(types.fri_params_type memory fri_params, bytes calldata blob, uint256 offset)\\n    internal pure returns (bool success, uint256 result_offset) {\\n        success = true;\\n        uint256 len;\\n        // z\\n        (len, result_offset) = basic_marshalling.get_skip_length(blob, offset);\\n        if( len != fri_params.batches_sizes.length ){\\n            success = false;\\n            return (success, result_offset);\\n        }\\n        for( uint256 i = 0; i < len; ){\\n            if( fri_params.batches_sizes[i] == 0 ){\\n                fri_params.batches_sizes[i] = basic_marshalling.get_length(blob, result_offset);\\n            } else {\\n                if( basic_marshalling.get_length(blob, result_offset) != fri_params.batches_sizes[i]){\\n                    success = false;\\n                    return (success, result_offset);\\n                }\\n            }\\n            fri_params.poly_num += fri_params.batches_sizes[i];\\n            result_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be_check(blob, result_offset);\\n            unchecked{i++;}\\n        }\\n        // fri_proof\\n        fri_params.fri_proof_offset = result_offset;\\n        (success, result_offset) = batched_fri_verifier.parse_proof_be(fri_params, blob, result_offset);\\n    }\\n\\n    // Input is proof_map.eval_proof_combined_value_offset\\n    function get_variable_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 vv_offset = basic_marshalling.skip_length(offset);\\n\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, vv_offset, i, j\\n        );\\n    }\\n\\n    function get_permutation_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 p_offset = basic_marshalling.skip_length(offset);\\n        \\n        p_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, p_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, p_offset, i, j\\n        );\\n    }\\n\\n    function get_quotient_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 q_offset = basic_marshalling.skip_length(offset);\\n        \\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        q_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, q_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, q_offset, i, j\\n        );\\n    }\\n\\n    // TODO add starting offsets of eval arrays to some kind of proof map\\n    function get_fixed_values_z_i_j_from_proof_be(bytes calldata blob, uint256 offset, uint256 i, uint256 j) \\n    internal pure returns (uint256 z_i_j){\\n        uint256 fv_offset = basic_marshalling.skip_length(offset);\\n        \\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        fv_offset = basic_marshalling.skip_vector_of_vectors_of_uint256_be(blob, fv_offset);\\n        z_i_j = basic_marshalling.get_i_j_uint256_from_vector_of_vectors(\\n            blob, fv_offset, i, j\\n        );\\n    }\\n\\n    function eval_points_eq(uint256[] memory p1, uint256[] memory p2 )\\n    internal pure returns(bool eq){\\n        eq = true;\\n        if (p1.length != p2.length) return false;\\n        for(uint256 i = 0; i < p1.length;){\\n            if(p1[i] != p2[i]) return false;\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    // Use this hack only for lpc test(!)\\n    // Call this function only after fri_params is completely initialized by parse* functions.\\n    function extract_merkle_roots(bytes calldata blob, types.fri_params_type memory fri_params) \\n    internal pure returns (uint256[] memory roots){\\n        return batched_fri_verifier.extract_merkle_roots(blob, fri_params);\\n    }\\n\\n    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z, uint256 modulus)\\n    internal pure returns(uint256[2] memory U){\\n//        require( xi.length == 2 );\\n        U[0] = addmod(mulmod(z[0], xi[1], modulus),modulus - mulmod(z[1], xi[0], modulus), modulus);\\n        U[1] = addmod(z[1], modulus - z[0], modulus);\\n    }\\n\\n//  coeffs for zs on each degree can be precomputed if necessary\\n    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z, uint256 modulus)\\n    internal pure returns(uint256[3] memory U){\\n//        require( xi.length == 3 );\\n        z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);\\n        z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);\\n        z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);\\n\\n        U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);\\n        U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);\\n\\n        U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);\\n    }\\n\\n    function verify_proof_be(\\n        bytes calldata blob,\\n        uint256 offset, \\n        uint256[] memory roots,\\n        uint256[][][] memory evaluation_points,\\n        types.transcript_data memory tr_state, \\n        types.fri_params_type memory fri_params)\\n    internal view returns (bool result) {\\n        uint256 ind;\\n\\n        // Push all merkle roots to transcript\\n        for( ind = 0; ind < fri_params.batches_num;){\\n            transcript.update_transcript_b32(tr_state, bytes32(roots[ind]));\\n            unchecked{ind++;}\\n        }\\n        fri_params.theta = transcript.get_field_challenge(tr_state, fri_params.modulus);\\n        fri_params.eval_map = new uint256[](fri_params.poly_num);\\n        fri_params.unique_eval_points = new uint256[][](fri_params.poly_num);\\n\\n        uint256 cur = 0;\\n        fri_params.different_points = 0;\\n        bool found = false;\\n        uint256[] memory point;\\n        uint256 k;\\n        uint256 i;        \\n\\n        // Prepare evaluation map;\\n        for( k = 0; k < fri_params.batches_num;){\\n            for( i = 0; i < fri_params.batches_sizes[k]; ){\\n                if( evaluation_points[k].length == 1 && i > 0){\\n                    fri_params.eval_map[cur] = fri_params.eval_map[cur - 1];\\n                } else {\\n                    point = evaluation_points[k][i];\\n                    // find this point\\n                    found = false;\\n                    for( ind = 0; ind < fri_params.different_points;){\\n                        if( eval_points_eq(point, fri_params.unique_eval_points[ind]) ){\\n                            found = true;\\n                            fri_params.eval_map[cur] = ind;\\n                            break;\\n                        }\\n                        unchecked{ind++;}\\n                    }\\n                    if(!found) {\\n                        fri_params.unique_eval_points[fri_params.different_points] = point;\\n                        fri_params.eval_map[cur] = fri_params.different_points;\\n                        unchecked{\\n                            fri_params.different_points++;\\n                        }\\n                    }   \\n                }\\n                unchecked{i++;cur++;}\\n            }\\n            unchecked{k++;}\\n        }\\n\\n        fri_params.denominators = new uint256[][](fri_params.different_points);\\n        fri_params.factors = new uint256[](fri_params.different_points);\\n\\n        // Prepare denominators\\n        for( ind = 0; ind < fri_params.different_points;){\\n            fri_params.denominators[ind] = new uint256[](fri_params.unique_eval_points[ind].length + 1);\\n            if( fri_params.unique_eval_points[ind].length == 1 ){\\n                fri_params.factors[ind] = 1;\\n                fri_params.denominators[ind][0] = fri_params.modulus - fri_params.unique_eval_points[ind][0];\\n                fri_params.denominators[ind][1] = 1;\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 2 ){\\n                // xi1 - xi0\\n                fri_params.factors[ind] = \\n                    addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus);\\n                fri_params.denominators[ind][2] = 1;\\n\\n                fri_params.denominators[ind][1] = \\n                    fri_params.modulus - addmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n\\n                fri_params.denominators[ind][0] = \\n                    mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus);\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n            } else \\n            if( fri_params.unique_eval_points[ind].length == 3 ){\\n                fri_params.factors[ind] = fri_params.modulus - \\n                    mulmod(\\n                        mulmod(\\n                            addmod(fri_params.unique_eval_points[ind][0], fri_params.modulus - fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                            addmod(fri_params.unique_eval_points[ind][1], fri_params.modulus - fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ),\\n                        addmod(fri_params.unique_eval_points[ind][2], fri_params.modulus - fri_params.unique_eval_points[ind][0], fri_params.modulus),\\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][3] = 1;\\n                fri_params.denominators[ind][2] =\\n                    fri_params.modulus - addmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        addmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][1] = \\n                    addmod(\\n                        mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][1], fri_params.modulus),\\n                        addmod(\\n                            mulmod(fri_params.unique_eval_points[ind][0], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            mulmod(fri_params.unique_eval_points[ind][1], fri_params.unique_eval_points[ind][2], fri_params.modulus),\\n                            fri_params.modulus\\n                        ), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = \\n                    fri_params.modulus - mulmod(\\n                        fri_params.unique_eval_points[ind][0], \\n                        mulmod(fri_params.unique_eval_points[ind][1],fri_params.unique_eval_points[ind][2], fri_params.modulus), \\n                        fri_params.modulus\\n                    );\\n                fri_params.denominators[ind][0] = mulmod(fri_params.denominators[ind][0], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][1] = mulmod(fri_params.denominators[ind][1], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][2] = mulmod(fri_params.denominators[ind][2], fri_params.factors[ind], fri_params.modulus);\\n                fri_params.denominators[ind][3] = mulmod(fri_params.denominators[ind][3], fri_params.factors[ind], fri_params.modulus);\\n            } else {\\n                return false;\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n        // Prepare combined U\\n        fri_params.combined_U = new uint256[][](fri_params.different_points);\\n        for( ind = 0; ind < fri_params.different_points;){\\n            point = fri_params.unique_eval_points[ind];\\n            fri_params.combined_U[ind] = new uint256[](fri_params.unique_eval_points[ind].length);\\n            cur = 0;\\n            fri_params.z_offset = basic_marshalling.skip_length(offset);\\n            for( k = 0; k < fri_params.batches_num;){\\n                fri_params.z_offset = basic_marshalling.skip_length(fri_params.z_offset);\\n                for( i = 0; i < fri_params.batches_sizes[k];){                    \\n                    polynomial.multiply_poly_on_coeff(\\n                        fri_params.combined_U[ind], \\n                        fri_params.theta, \\n                        fri_params.modulus\\n                    );\\n                    if( fri_params.eval_map[cur] == ind ){\\n                        if( point.length == 1 ){\\n                            fri_params.combined_U[ind][0] = addmod(\\n                                fri_params.combined_U[ind][0],\\n                                basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0), \\n                                fri_params.modulus\\n                            );\\n                        } else \\n                        if( point.length == 2 ){\\n                            uint256[2] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp = calculate_2points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                        } else \\n                        if( point.length == 3){\\n                            uint256[3] memory tmp;\\n                            tmp[0] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 0);\\n                            tmp[1] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 1);\\n                            tmp[2] = basic_marshalling.get_i_uint256_from_vector(blob, fri_params.z_offset, 2);\\n                            tmp = calculate_3points_interpolation(\\n                                point, tmp, fri_params.modulus\\n                            );\\n                            fri_params.combined_U[ind][0] = addmod(fri_params.combined_U[ind][0], tmp[0], fri_params.modulus);\\n                            fri_params.combined_U[ind][1] = addmod(fri_params.combined_U[ind][1], tmp[1], fri_params.modulus);\\n                            fri_params.combined_U[ind][2] = addmod(fri_params.combined_U[ind][2], tmp[2], fri_params.modulus);\\n                        } else {\\n                            return false;\\n                        }\\n                    } \\n                    fri_params.z_offset = basic_marshalling.skip_vector_of_uint256_be(blob, fri_params.z_offset);\\n                    unchecked{i++;cur++;}\\n                }\\n                unchecked{k++;}\\n            }\\n            unchecked{ind++;}\\n        }\\n\\n\\n        if (!batched_fri_verifier.verify_proof_be(blob, roots, tr_state, fri_params)) {\\n            return false;\\n        }\\n        \\n        return true;\\n   }\\n} \",\"keccak256\":\"0xea655e8f167a8588e485b7e69c3635fd6799a37d74651b7c381d8df4b47dc6bf\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/containers/merkle_verifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\nlibrary merkle_verifier {\\n    // Merkle proof has the following structure:\\n    // [0:8] - leaf index\\n    // [8:16] - root length (which is always 32 bytes in current implementation)\\n    // [16:48] - root\\n    // [48:56] - merkle tree depth\\n    //\\n    // Depth number of layers with co-path elements follows then.\\n    // Each layer has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - number of co-path elements on the layer\\n    //  (layer_size = arity-1 actually, which (arity) is always 2 in current implementation)\\n    //\\n    // layer_size number of co-path elements for every layer in merkle proof follows then.\\n    // Each element has following structure (actually indexes begin from a certain offset):\\n    // [0:8] - co-path element position on the layer\\n    // [8:16] - co-path element hash value length (which is always 32 bytes in current implementation)\\n    // [16:48] - co-path element hash value\\n    uint256 constant ROOT_OFFSET = 16;\\n    uint256 constant DEPTH_OFFSET = 48;\\n    uint256 constant LAYERS_OFFSET = 56;\\n    // only one co-element on each layer as arity is always 2\\n    // 8 + (number of co-path elements on the layer)\\n    // 8 + (co-path element position on the layer)\\n    // 8 + (co-path element hash value length)\\n    // 32 (co-path element hash value)\\n    uint256 constant LAYER_POSITION_OFFSET = 8;\\n    uint256 constant LAYER_COPATH_HASH_OFFSET = 24;\\n    uint256 constant LAYER_OCTETS = 56;\\n\\n    uint256 constant LENGTH_OCTETS = 8;\\n    // 256 - 8 * LENGTH_OCTETS\\n    uint256 constant LENGTH_RESTORING_SHIFT = 0xc0;\\n\\n    function skip_merkle_proof_be(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n    }\\n\\n    function skip_merkle_proof_be_check(bytes calldata blob, uint256 offset)\\n    internal pure returns (uint256 result_offset) {\\n        unchecked { result_offset = offset + LAYERS_OFFSET; }\\n        require(result_offset < blob.length);\\n        assembly {\\n            result_offset := add(\\n                result_offset,\\n                mul(\\n                    LAYER_OCTETS,\\n                    shr(\\n                        LENGTH_RESTORING_SHIFT,\\n                        calldataload(\\n                            add(blob.offset, add(offset, DEPTH_OFFSET))\\n                        )\\n                    )\\n                )\\n            )\\n        }\\n        require(result_offset <= blob.length, \\\"skip_merkle_proof_be\\\");\\n    }\\n\\n    function parse_verify_merkle_proof_not_pre_hash_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n//        uint256 x = 0;\\n//        uint256 depth;\\n        assembly {\\n            let depth := shr(LENGTH_RESTORING_SHIFT, calldataload(add(blob.offset, add(offset, DEPTH_OFFSET))))\\n\\n            // save leaf hash data to required position\\n            let pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(\\n                        blob.offset,\\n                        add(add(offset, LAYERS_OFFSET), LAYER_POSITION_OFFSET)\\n                    )\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(0x20, verified_data)\\n            }\\n            case 1 {\\n                mstore(0x00, verified_data)\\n            }\\n\\n            let layer_offst := add(offset, LAYERS_OFFSET)\\n            let next_pos\\n            for {\\n                let cur_layer_i := 0\\n            } lt(cur_layer_i, sub(depth, 1)) {\\n                cur_layer_i := add(cur_layer_i, 1)\\n            } {\\n                pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_POSITION_OFFSET)\\n                        )\\n                    )\\n                )\\n                next_pos := shr(\\n                    LENGTH_RESTORING_SHIFT,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(\\n                                add(layer_offst, LAYER_POSITION_OFFSET),\\n                                LAYER_OCTETS\\n                            )\\n                        )\\n                    )\\n                )\\n//                x := add(x, pos)\\n//                x := mul(x, 10)\\n                switch pos\\n                case 0 {\\n                    mstore(\\n                        0x00,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                case 1 {\\n                    mstore(\\n                        0x20,\\n                        calldataload(\\n                            add(\\n                                blob.offset,\\n                                add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                            )\\n                        )\\n                    )\\n                    switch next_pos\\n                    case 0 {\\n                        mstore(0x20, keccak256(0, 0x40))\\n                    }\\n                    case 1 {\\n                        mstore(0, keccak256(0, 0x40))\\n                    }\\n                }\\n                layer_offst := add(layer_offst, LAYER_OCTETS)\\n            }\\n\\n            pos := shr(\\n                LENGTH_RESTORING_SHIFT,\\n                calldataload(\\n                    add(blob.offset, add(layer_offst, LAYER_POSITION_OFFSET))\\n                )\\n            )\\n//            x := add(x, pos)\\n//            x := mul(x, 10)\\n            switch pos\\n            case 0 {\\n                mstore(\\n                    0x00,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n            case 1 {\\n                mstore(\\n                    0x20,\\n                    calldataload(\\n                        add(\\n                            blob.offset,\\n                            add(layer_offst, LAYER_COPATH_HASH_OFFSET)\\n                        )\\n                    )\\n                )\\n                verified_data := keccak256(0, 0x40)\\n            }\\n        }\\n\\n        bytes32 root;\\n        assembly {\\n            root := calldataload(add(blob.offset, add(offset, ROOT_OFFSET)))\\n        }\\n        result = (verified_data == root);\\n    }\\n    \\n    // We store merkle root as an octet vector. At first length==0x20 is stored.\\n    // We should skip it.\\n    // TODO: this function should return bytes32\\n    function get_merkle_root_from_blob(bytes calldata blob, uint256 merkle_root_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_root_offset, 0x8)))\\n        }\\n    }\\n\\n    // TODO: This function should return bytes32\\n    function get_merkle_root_from_proof(bytes calldata blob, uint256 merkle_proof_offset)\\n    internal pure returns(uint256 root){\\n        assembly {\\n            root := calldataload(add(blob.offset, add(merkle_proof_offset, ROOT_OFFSET)))\\n        }\\n    }\\n\\n    function parse_verify_merkle_proof_be(bytes calldata blob, uint256 offset, bytes32 verified_data)\\n    internal pure returns (bool result) {\\n        assembly {\\n            mstore(0, verified_data)\\n            verified_data := keccak256(0, 0x20)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data)\\n    internal pure returns (bool result) {\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, keccak256(verified_data));\\n    }\\n\\n    function parse_verify_merkle_proof_bytes_be(bytes calldata blob, uint256 offset, bytes memory verified_data_bytes,\\n                                                uint256 verified_data_bytes_len)\\n    internal pure returns (bool result) {\\n        bytes32 verified_data;\\n        assembly {\\n            verified_data := keccak256(add(verified_data_bytes, 0x20), verified_data_bytes_len)\\n        }\\n        result = parse_verify_merkle_proof_not_pre_hash_be(blob, offset, verified_data);\\n    }\\n}\\n\",\"keccak256\":\"0x9495b7b9501fb77dc4e0c8e3a5af3544cb6fac48cc2deb2ec5030c991766b7f4\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/cryptography/transcript.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2021 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2021 Ilias Khairullin <ilias@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\n/**\\n * @title Transcript library\\n * @dev Generates Plonk random challenges\\n */\\nlibrary transcript {\\n    function init_transcript(types.transcript_data memory self, bytes memory init_blob)\\n    internal pure {\\n        self.current_challenge = keccak256(init_blob);\\n    }\\n\\n    function update_transcript(types.transcript_data memory self, bytes memory blob)\\n    internal pure {\\n        self.current_challenge = keccak256(bytes.concat(self.current_challenge, blob));\\n    }\\n\\n    function update_transcript_b32(types.transcript_data memory self, bytes32 blob)\\n    internal pure {\\n        self.current_challenge = keccak256(\\n            bytes.concat(self.current_challenge, blob)\\n        );\\n    }\\n\\n    function update_transcript_b32_by_offset(types.transcript_data memory self, bytes memory blob, uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := mload(add(add(blob, 0x20), offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function update_transcript_b32_by_offset_calldata(types.transcript_data memory self, bytes calldata blob,\\n                                                      uint256 offset)\\n    internal pure {\\n        require(offset < blob.length, \\\"update_transcript_b32_by_offset: offset < blob.length\\\");\\n        require(32 <= blob.length - offset, \\\"update_transcript_b32_by_offset: 32 <= blob.length - offset\\\");\\n\\n        bytes32 blob32;\\n        assembly {\\n            blob32 := calldataload(add(blob.offset, offset))\\n        }\\n        update_transcript_b32(self, blob32);\\n    }\\n\\n    function get_integral_challenge_be(types.transcript_data memory self, uint256 length)\\n    internal pure returns (uint256 result) {\\n        require(length <= 32);\\n        self.current_challenge = keccak256(abi.encodePacked(self.current_challenge));\\n        return (uint256(self.current_challenge) &\\n               (((uint256(1) << (length * 8)) - 1) << (uint256(256) - length * 8))) >> (uint256(256) - length * 8);\\n    }\\n\\n    function get_field_challenge(types.transcript_data memory self, uint256 modulus)\\n    internal pure returns (uint256) {\\n        self.current_challenge = keccak256(abi.encode(self.current_challenge));\\n        return uint256(self.current_challenge) % modulus;\\n    }\\n\\n    function get_field_challenges(types.transcript_data memory self, uint256[] memory challenges, uint256 modulus)\\n    internal pure {\\n        if (challenges.length > 0) {\\n            bytes32 new_challenge = self.current_challenge;\\n            for (uint256 i = 0; i < challenges.length;) {\\n                new_challenge = keccak256(abi.encode(new_challenge));\\n                challenges[i] = uint256(new_challenge) % modulus;\\n                unchecked{ i++; }\\n            }\\n            self.current_challenge = new_challenge;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe87be40233a78f3c08f5af77e7f0fe2e948eaaada4e84db08c94cf2cc1b60b78\",\"license\":\"MIT OR Apache-2.0\"},\"@nilfoundation/evm-placeholder-verification/contracts/interfaces/gate_argument.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\nimport \\\"../types.sol\\\";\\n\\ninterface IGateArgument {\\n    function evaluate_gates_be(bytes calldata blob,\\n        uint256 eval_proof_combined_value_offset,\\n        types.gate_argument_params memory gate_params,\\n        types.arithmetization_params memory ar_params,\\n        int256[][] calldata columns_rotations\\n    ) external pure returns (uint256 gates_evaluation);\\n}\",\"keccak256\":\"0x86cef27f52fe03a046cd54fef8ffacd404568746a8acf9bb7b12d96b1250c2e1\",\"license\":\"Apache-2.0.\"},\"@nilfoundation/evm-placeholder-verification/contracts/types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2018-2021 Mikhail Komarov <nemo@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\n\\npragma solidity >=0.8.4;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct g1_point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct g2_point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct proof {\\n        g1_point W1;\\n        g1_point W2;\\n        g1_point W3;\\n        g1_point W4;\\n        g1_point Z;\\n        g1_point T1;\\n        g1_point T2;\\n        g1_point T3;\\n        g1_point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        g1_point PI_Z;\\n        g1_point PI_Z_OMEGA;\\n        g1_point recursive_P1;\\n        g1_point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct challenge_transcript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct verification_key {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        g1_point Q1;\\n        g1_point Q2;\\n        g1_point Q3;\\n        g1_point Q4;\\n        g1_point Q5;\\n        g1_point QM;\\n        g1_point QC;\\n        g1_point QARITH;\\n        g1_point QECC;\\n        g1_point QRANGE;\\n        g1_point QLOGIC;\\n        g1_point SIGMA1;\\n        g1_point SIGMA2;\\n        g1_point SIGMA3;\\n        g1_point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        g2_point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n    \\n    struct transcript_data {\\n        bytes32 current_challenge;\\n    }\\n\\n    struct fri_params_type {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 r;\\n        // 0x40\\n        uint256 max_degree;\\n        // 0x60\\n        uint256 lambda;\\n        // 0x80\\n        uint256 omega;\\n        // 0xa0\\n        uint256[] D_omegas;\\n        // 0xc0\\n        uint256[] correct_order_idx;       // Ordered indices to pack ys to check merkle proof\\n        // 0xe0\\n        uint256[] step_list;\\n        // 0x100\\n        uint256[] q;\\n\\n        // 0x120\\n        uint256[] s_indices;\\n        uint256[] s;                    // Coset indices\\n        uint256 max_step;       // variable for memory  initializing\\n        uint256 max_batch;      // variable for memory  initializing\\n\\n        // These are local variables for FRI. But it's useful to allocate memory once\\n        uint256[]    tmp_arr;\\n        uint256[][]  evaluation_points;\\n        uint256      z_offset;\\n\\n        // New fields\\n        uint256       max_coset;\\n        uint256       batches_num;\\n        uint256[]     batches_sizes;\\n        uint256       fri_proof_offset;         // fri_roots offset equals to fri_proof_offset + 0x20\\n        uint256       fri_final_poly_offset;\\n        uint256       fri_cur_query_offset;     // It'll be changed during verification process.\\n                                                // It's set at the begining of the first query proof after parse functions running.\\n        uint256       theta;\\n        uint256       poly_num;\\n        uint256[][]   combined_U;                // U polynomials for different evaluation points\\n        uint256[][]   denominators;              // V polynomials for different evaluation points\\n        uint256[]     factors;\\n        uint256[]     eval_map;\\n        uint256[][]   unique_eval_points;\\n        uint256       different_points;\\n        uint256[]     ys;\\n        uint256[]     final_polynomial;         // It's loaded once while parsing fri proof\\n        uint256[]     fri_roots;                // It should be bytes32\\n    }\\n\\n    struct fri_state_type {\\n        bytes   b;\\n        //0x0\\n        uint256 x_index;\\n        //0x20\\n        uint256 x;\\n        //0x40\\n        uint256 domain_size;\\n        //0x60\\n        uint256 domain_size_mod;\\n        //0x80\\n        uint256 newind;\\n        //0xa0\\n        uint256 p_ind;\\n        //0xc0\\n        uint256 y_ind;\\n        //0xe0\\n        uint256 indices_size;\\n        //0x100\\n        uint256 b_length;\\n        //0x120\\n        uint256 query_id;\\n        //0x140\\n        uint256[]     alphas;\\n        uint256[] values;\\n        uint256[] tmp_values;\\n        uint256 coset_size;\\n        uint256 offset;\\n        uint256 root;\\n        uint256 fri_root;\\n        uint256 s;\\n        uint256 step;\\n        uint256 round;\\n        uint256[] point;\\n        uint256 cur;\\n        uint256 interpolant;\\n        uint256 f0;\\n        uint256 f1;\\n        uint256 factor;\\n    }\\n\\n    struct placeholder_proof_map {\\n        // 0x0\\n        uint256 variable_values_commitment_offset;\\n        // 0x20\\n        uint256 v_perm_commitment_offset;\\n        // 0x40\\n        uint256 T_commitment_offset;\\n        // 0x60\\n        uint256 fixed_values_commitment_offset;\\n        // 0x80\\n        uint256 eval_proof_offset;\\n        // 0xa0\\n        uint256 eval_proof_lagrange_0_offset;\\n        // 0xc0\\n        uint256 eval_proof_combined_value_offset;\\n    }\\n\\n    struct placeholder_common_data {\\n        uint256 rows_amount;\\n        // 0x20\\n        uint256 omega;\\n        int256[][] columns_rotations; \\n    }\\n\\n    struct placeholder_state_type {\\n        // 0x0\\n        uint256 len;\\n        // 0x20\\n        uint256 offset;\\n        // 0x40\\n        uint256 zero_index;\\n        // 0x60\\n        uint256[] permutation_argument;\\n        // 0x80\\n        uint256 gate_argument;\\n        // 0xa0\\n        uint256[] alphas;\\n        // 0xc0\\n        uint256 challenge;\\n        // 0xe0\\n        uint256 e;\\n        // 0x100\\n        uint256[][][] evaluation_points;\\n        // 0x120\\n        uint256[] F;\\n        // 0x140\\n        uint256 F_consolidated;\\n        // 0x160\\n        uint256 T_consolidated;\\n        // 0x180\\n        uint256 Z_at_challenge;\\n        // 0x1a0\\n        uint256 beta;\\n        // 0x1c0\\n        uint256 gamma;\\n        // 0x1e0\\n        uint256 g;\\n        // 0x200\\n        uint256 h;\\n        // 0x220\\n        uint256 perm_polynomial_value;\\n        // 0x240\\n        uint256 perm_polynomial_shifted_value;\\n        // 0x260\\n        uint256 q_blind_eval;\\n        // 0x280\\n        uint256 q_last_eval;\\n        // 0x2a0\\n        uint256 S_id_i;\\n        // 0x2c0\\n        uint256 S_sigma_i;\\n        // 0x2e0\\n        uint256[] roots;\\n        // 0x300\\n        uint256 tmp1;\\n        // 0x320\\n        uint256 tmp2;\\n        // 0x340\\n        uint256 tmp3;\\n        // 0x360\\n        uint256 idx1;\\n        // 0x380\\n        uint256 idx2;\\n        // 0x3a0\\n        uint256 inversed_omega;\\n    }\\n\\n    struct arithmetization_params{\\n        uint256 witness_columns;\\n        uint256 public_input_columns;\\n        uint256 constant_columns;\\n        uint256 selector_columns;\\n        uint256 lookup_table_size;\\n\\n        // computed from other params\\n        uint256 permutation_columns;\\n    }\\n\\n    // parameters are sent to gate argument\\n    struct gate_argument_params {\\n        // 0x0\\n        uint256 modulus;\\n        // 0x20\\n        uint256 theta;\\n    }\\n}\\n\",\"keccak256\":\"0xcb25373de1222759842e237744b85bdbec1c00abd6bf7e3627269ad7d91b5c31\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/gates/gate_argument.sol\":{\"content\":\"\\n// SPDX-License-Identifier: Apache-2.0.\\n//---------------------------------------------------------------------------//\\n// Copyright (c) 2022 Mikhail Komarov <nemo@nil.foundation>\\n// Copyright (c) 2022 Aleksei Moskvin <alalmoskvin@nil.foundation>\\n// Copyright (c) 2023 Elena Tatuzova  <alalmoskvin@nil.foundation>\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//    http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n//---------------------------------------------------------------------------//\\npragma solidity >=0.8.4;\\n\\nimport \\\"@nilfoundation/evm-placeholder-verification/contracts/types.sol\\\";\\nimport \\\"@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol\\\";\\nimport \\\"@nilfoundation/evm-placeholder-verification/contracts/commitments/batched_lpc_verifier.sol\\\";\\nimport \\\"@nilfoundation/evm-placeholder-verification/contracts/interfaces/gate_argument.sol\\\";\\n\\ncontract gates_gate_argument_split_gen  is IGateArgument{\\n    uint256 constant GATES_N = 1;\\n\\n    struct local_vars_type{\\n        // 0x0\\n        uint256 constraint_eval;\\n        // 0x20\\n        uint256 gate_eval;\\n        // 0x40\\n        uint256 gates_evaluation;\\n        // 0x60\\n        uint256 theta_acc;\\n\\n\\t\\t//0x80\\n\\t\\tuint256[] witness_evaluations;\\n\\t\\t//a0\\n\\t\\tuint256[] selector_evaluations;\\n\\n    }\\n\\n    uint256 constant MODULUS_OFFSET = 0x0;\\n    uint256 constant THETA_OFFSET = 0x20;\\n\\n    uint256 constant CONSTRAINT_EVAL_OFFSET = 0x00;\\n    uint256 constant GATE_EVAL_OFFSET = 0x20;\\n    uint256 constant GATES_EVALUATIONS_OFFSET = 0x40;\\n    uint256 constant THETA_ACC_OFFSET = 0x60;\\n\\tuint256 constant WITNESS_EVALUATIONS_OFFSET = 0x80;\\n\\tuint256 constant SELECTOR_EVALUATIONS_OFFSET = 0xa0;\\n\\n\\n    function evaluate_gates_be(\\n        bytes calldata blob,\\n        uint256 eval_proof_combined_value_offset,\\n        types.gate_argument_params memory gate_params,\\n        types.arithmetization_params memory ar_params,\\n        int256[][] calldata columns_rotations\\n    ) external pure returns (uint256 gates_evaluation) {\\n        local_vars_type memory local_vars;\\n\\n\\n        local_vars.witness_evaluations = new uint256[](ar_params.witness_columns);\\n        for (uint256 i = 0; i < ar_params.witness_columns;) {\\n            local_vars.witness_evaluations[i] = batched_lpc_verifier.get_variable_values_z_i_j_from_proof_be(\\n                    blob, eval_proof_combined_value_offset, i, 0\\n            );\\n            unchecked{i++;}\\n        }\\n\\n        local_vars.selector_evaluations = new uint256[](ar_params.selector_columns);\\n        for (uint256 i = 0; i < ar_params.selector_columns;) {\\n            local_vars.selector_evaluations[i] = batched_lpc_verifier.get_fixed_values_z_i_j_from_proof_be(\\n                blob, eval_proof_combined_value_offset, ar_params.permutation_columns + ar_params.permutation_columns + ar_params.constant_columns + i, 0\\n            );\\n            unchecked{i++;}\\n        }\\n\\n\\n        local_vars.theta_acc = 1;\\n        local_vars.gates_evaluation = 0;    \\n\\n        uint256 theta_acc = local_vars.theta_acc;\\n\\n        uint256 terms;\\n        assembly {\\n            let modulus := mload(gate_params)\\n            let theta := mload(add(gate_params, THETA_OFFSET))\\n\\n\\n            function get_witness_i(idx, ptr) -> result {\\n                result := mload(add(add(mload(add(ptr, WITNESS_EVALUATIONS_OFFSET)), 0x20), mul(0x20, idx)))\\n            }\\n\\n            function get_selector_i(idx, ptr) -> result {\\n                result := mload(add(add(mload(add(ptr, SELECTOR_EVALUATIONS_OFFSET)), 0x20), mul(0x20, idx)))\\n            }\\n\\n\\t\\t\\t//Gate0\\n\\t\\t\\tmstore(add(local_vars, GATE_EVAL_OFFSET), 0)\\n\\t\\t\\tmstore(add(local_vars, CONSTRAINT_EVAL_OFFSET), 0)\\n\\t\\t\\tterms:=0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000\\n\\t\\t\\tterms:=mulmod(terms, get_witness_i(2, local_vars), modulus)\\n\\t\\t\\tmstore(add(local_vars, CONSTRAINT_EVAL_OFFSET),addmod(mload(add(local_vars, CONSTRAINT_EVAL_OFFSET)),terms,modulus))\\n\\t\\t\\tterms:=get_witness_i(1, local_vars)\\n\\t\\t\\tmstore(add(local_vars, CONSTRAINT_EVAL_OFFSET),addmod(mload(add(local_vars, CONSTRAINT_EVAL_OFFSET)),terms,modulus))\\n\\t\\t\\tterms:=get_witness_i(0, local_vars)\\n\\t\\t\\tmstore(add(local_vars, CONSTRAINT_EVAL_OFFSET),addmod(mload(add(local_vars, CONSTRAINT_EVAL_OFFSET)),terms,modulus))\\n\\t\\t\\tmstore(add(local_vars, GATE_EVAL_OFFSET),addmod(mload(add(local_vars, GATE_EVAL_OFFSET)),mulmod(mload(add(local_vars, CONSTRAINT_EVAL_OFFSET)),theta_acc,modulus),modulus))\\n\\t\\t\\ttheta_acc := mulmod(theta_acc, theta, modulus)\\n\\t\\t\\tmstore(add(local_vars, GATE_EVAL_OFFSET),mulmod(mload(add(local_vars, GATE_EVAL_OFFSET)),get_selector_i(0,local_vars),modulus))\\n\\t\\t\\tgates_evaluation := addmod(gates_evaluation,mload(add(local_vars, GATE_EVAL_OFFSET)),modulus)\\n\\n\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe741965365b53f21aa26e1543697042f39d758cf1493f6b086697112e78bb56c\",\"license\":\"Apache-2.0.\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506105f7806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80638009b83a14610030575b600080fd5b61004361003e3660046104b9565b610055565b60405190815260200160405180910390f35b60006100906040518060c001604052806000815260200160008152602001600081526020016000815260200160608152602001606081525090565b845167ffffffffffffffff8111156100aa576100aa610372565b6040519080825280602002602001820160405280156100d3578160200160208202803683370190505b50608082015260005b855181101561011c576100f38a8a8a8460006102aa565b8260800151828151811061010957610109610584565b60209081029190910101526001016100dc565b50846060015167ffffffffffffffff81111561013a5761013a610372565b604051908082528060200260200182016040528015610163578160200160208202803683370190505b5060a082015260005b85606001518110156101dc576101b38a8a8a848a604001518b60a001518c60a00151610198919061059a565b6101a2919061059a565b6101ac919061059a565b60006102cc565b8260a0015182815181106101c9576101c9610584565b602090810291909101015260010161016c565b506001606082018190526000604083018190528751602089015160006020860181905285526080850151606001517f40000000000000000000000000000000224698fc094cf91b992d30ed000000009350829084099250818360008701510880865260808601516040015193508290849008808652608086015160200151935082908490088086528290819086900960208701510860208601528181850960a08601516020015190945082915060208601510960208501819052819086089c9b505050505050505050505050565b600080600885015b90506102c187878387876102f7565b979650505050505050565b6000600884016102dd87878361033a565b90506102ea87878361033a565b90506102b287878361033a565b600060088401935060005b838110156103235760088588013560c01c6020028601019450600101610302565b506008602083028501870101359695505050505050565b600881018382013560c01c60005b818110156103695760088387013560c01c6020028401019250600101610348565b50509392505050565b634e487b7160e01b600052604160045260246000fd5b60006040828403121561039a57600080fd5b6040516040810181811067ffffffffffffffff821117156103cb57634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b600060c082840312156103f757600080fd5b60405160c0810181811067ffffffffffffffff8211171561042857634e487b7160e01b600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201525092915050565b60008083601f84011261047f57600080fd5b50813567ffffffffffffffff81111561049757600080fd5b6020830191508360208260051b85010111156104b257600080fd5b9250929050565b6000806000806000806000610160888a0312156104d557600080fd5b873567ffffffffffffffff808211156104ed57600080fd5b818a0191508a601f83011261050157600080fd5b81358181111561051057600080fd5b8b602082850101111561052257600080fd5b60208381019a509098508a0135965061053e8b60408c01610388565b955061054d8b60808c016103e5565b94506101408a013591508082111561056457600080fd5b506105718a828b0161046d565b989b979a50959850939692959293505050565b634e487b7160e01b600052603260045260246000fd5b808201808211156105bb57634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220a7a85a4b4f9d0ce36571480ddff1dd6b43233e20a3aa4a7989bf23063acdf60b64736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80638009b83a14610030575b600080fd5b61004361003e3660046104b9565b610055565b60405190815260200160405180910390f35b60006100906040518060c001604052806000815260200160008152602001600081526020016000815260200160608152602001606081525090565b845167ffffffffffffffff8111156100aa576100aa610372565b6040519080825280602002602001820160405280156100d3578160200160208202803683370190505b50608082015260005b855181101561011c576100f38a8a8a8460006102aa565b8260800151828151811061010957610109610584565b60209081029190910101526001016100dc565b50846060015167ffffffffffffffff81111561013a5761013a610372565b604051908082528060200260200182016040528015610163578160200160208202803683370190505b5060a082015260005b85606001518110156101dc576101b38a8a8a848a604001518b60a001518c60a00151610198919061059a565b6101a2919061059a565b6101ac919061059a565b60006102cc565b8260a0015182815181106101c9576101c9610584565b602090810291909101015260010161016c565b506001606082018190526000604083018190528751602089015160006020860181905285526080850151606001517f40000000000000000000000000000000224698fc094cf91b992d30ed000000009350829084099250818360008701510880865260808601516040015193508290849008808652608086015160200151935082908490088086528290819086900960208701510860208601528181850960a08601516020015190945082915060208601510960208501819052819086089c9b505050505050505050505050565b600080600885015b90506102c187878387876102f7565b979650505050505050565b6000600884016102dd87878361033a565b90506102ea87878361033a565b90506102b287878361033a565b600060088401935060005b838110156103235760088588013560c01c6020028601019450600101610302565b506008602083028501870101359695505050505050565b600881018382013560c01c60005b818110156103695760088387013560c01c6020028401019250600101610348565b50509392505050565b634e487b7160e01b600052604160045260246000fd5b60006040828403121561039a57600080fd5b6040516040810181811067ffffffffffffffff821117156103cb57634e487b7160e01b600052604160045260246000fd5b604052823581526020928301359281019290925250919050565b600060c082840312156103f757600080fd5b60405160c0810181811067ffffffffffffffff8211171561042857634e487b7160e01b600052604160045260246000fd5b8060405250809150823581526020830135602082015260408301356040820152606083013560608201526080830135608082015260a083013560a08201525092915050565b60008083601f84011261047f57600080fd5b50813567ffffffffffffffff81111561049757600080fd5b6020830191508360208260051b85010111156104b257600080fd5b9250929050565b6000806000806000806000610160888a0312156104d557600080fd5b873567ffffffffffffffff808211156104ed57600080fd5b818a0191508a601f83011261050157600080fd5b81358181111561051057600080fd5b8b602082850101111561052257600080fd5b60208381019a509098508a0135965061053e8b60408c01610388565b955061054d8b60808c016103e5565b94506101408a013591508082111561056457600080fd5b506105718a828b0161046d565b989b979a50959850939692959293505050565b634e487b7160e01b600052603260045260246000fd5b808201808211156105bb57634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220a7a85a4b4f9d0ce36571480ddff1dd6b43233e20a3aa4a7989bf23063acdf60b64736f6c63430008130033",
  "libraries": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}