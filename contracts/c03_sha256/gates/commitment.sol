
// SPDX-License-Identifier: Apache-2.0.
//---------------------------------------------------------------------------//
// Copyright (c) 2023 Generated by ZKLLVM-transpiler
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//---------------------------------------------------------------------------//
pragma solidity >=0.8.4;

import "@nilfoundation/evm-placeholder-verification/contracts/cryptography/transcript.sol";
import "@nilfoundation/evm-placeholder-verification/contracts/interfaces/modular_commitment.sol";
// Move away unused structures from types.sol
import "@nilfoundation/evm-placeholder-verification/contracts/types.sol";
import "@nilfoundation/evm-placeholder-verification/contracts/basic_marshalling.sol";
import "@nilfoundation/evm-placeholder-verification/contracts/containers/merkle_verifier.sol";
import "@nilfoundation/evm-placeholder-verification/contracts/algebra/polynomial.sol";
import "hardhat/console.sol";

library modular_commitment_scheme_sha256 {
    uint256 constant modulus = 28948022309329048855892746252171976963363056481941560715954676764349967630337;
    uint64 constant batches_num = 4;
    uint256 constant r = 10;
    uint256 constant lambda = 9;
    uint256 constant D0_size = 2048;
    uint256 constant max_degree = 2047;
    uint256 constant D0_omega = 5207999989657576140891498154897385491612440083899963290755562031717636435093;
    uint256 constant unique_points = 5;
    uint256 constant permutation_point = 3;
    uint256 constant quotient_point = 1;
    uint256 constant lookup_point = 140647399863968;
    bytes constant   points_ids = hex"02020202020202020202020202020202020202020202020202020202020202020202020202020202020204040202020202020202020202020202020202020202020202020202020202020202020202020202020200000000000000000001010101010101";
    uint256 constant omega = 5207999989657576140891498154897385491612440083899963290755562031717636435093;
    uint256 constant _etha = 22450439715696355944596763167877838401391585751230009712870269180621954114817;

    struct commitment_state{
        bytes   leaf_data;
        uint256 roots_offset;
        uint256 initial_data_offset;
        uint256 initial_proof_offset;
        uint256 round_proof_offset;
        uint256 round_data_offset;
        uint256[r]  alphas;
        uint64[batches_num] batch_sizes;
        uint64 poly_num;
        uint256 points_num;
        uint256 theta;
        uint256 x_index;
        uint256 x;
        uint256 max_batch;
        uint256 domain_size;
        uint256[] final_polynomial;
        uint256 leaf_length;
        uint256[][unique_points] denominators;
        uint256[unique_points] factors;
        uint256[][unique_points] combined_U;
        uint256[][unique_points] unique_eval_points;
        uint256[2] y;
        uint256 j;
        uint256 offset;
    }

    function calculate_2points_interpolation(uint256[] memory xi, uint256[2] memory z)
    internal pure returns(uint256[2] memory U){
//        require( xi.length == 2 );
unchecked {
        U[0] = addmod(mulmod(z[0], xi[1], modulus),modulus - mulmod(z[1], xi[0], modulus), modulus);
        U[1] = addmod(z[1], modulus - z[0], modulus);
}
    }

//  coeffs for zs on each degree can be precomputed if necessary
    function calculate_3points_interpolation(uint256[] memory xi, uint256[3] memory z)
    internal pure returns(uint256[3] memory U){
//        require( xi.length == 3 );
unchecked {
        z[0] = mulmod(z[0], addmod(xi[1], modulus - xi[2], modulus), modulus);
        z[1] = mulmod(z[1], addmod(xi[2], modulus - xi[0], modulus), modulus);
        z[2] = mulmod(z[2], addmod(xi[0], modulus - xi[1], modulus), modulus);

        U[0] = mulmod(z[0], mulmod(xi[1], xi[2], modulus), modulus);
        U[0] = addmod(U[0], mulmod(z[1], mulmod(xi[0], xi[2], modulus), modulus), modulus);
        U[0] = addmod(U[0], mulmod(z[2], mulmod(xi[0], xi[1], modulus), modulus), modulus);

        U[1] = modulus - mulmod(z[0], addmod(xi[1], xi[2], modulus), modulus);
        U[1] = addmod(U[1], modulus - mulmod(z[1], addmod(xi[0], xi[2], modulus), modulus), modulus);
        U[1] = addmod(U[1], modulus - mulmod(z[2], addmod(xi[0], xi[1], modulus), modulus), modulus);

        U[2] = addmod(z[0], addmod(z[1], z[2], modulus), modulus);
}
    }

    function prepare_eval_points(uint256[][unique_points] memory result, uint256 xi) internal view {
        uint256 inversed_omega = field.inverse_static(omega, modulus);
		 result[0] = new uint256[](3);
		 result[0][0] = mulmod(xi, inversed_omega, modulus);
		 result[0][1] = xi;
		 result[0][2] = mulmod(xi, omega, modulus);
		 result[1] = new uint256[](1);
		 result[1][0] = xi;
		 result[2] = new uint256[](2);
		 result[2][0] = xi;
		 result[2][1] = _etha;
		 result[3] = new uint256[](2);
		 result[3][0] = xi;
		 result[3][1] = mulmod(xi, omega, modulus);
		 result[4] = new uint256[](3);
		 result[4][0] = xi;
		 result[4][1] = mulmod(xi, omega, modulus);
		 result[4][2] = _etha;

    }

    function prepare_U_V(bytes calldata blob, commitment_state memory state, uint256 xi) internal view returns(bool result){

unchecked {
        result = true;
        uint64 ind = 0;
        prepare_eval_points(state.unique_eval_points, xi);
                // Prepare denominators
        for( ind = 0; ind < state.unique_eval_points.length;){
            state.denominators[ind] = new uint256[](state.unique_eval_points[ind].length + 1);
            if( state.unique_eval_points[ind].length == 1 ){
                state.factors[ind] = 1;
                state.denominators[ind][0] = modulus - state.unique_eval_points[ind][0];
                state.denominators[ind][1] = 1;
            } else
            if( state.unique_eval_points[ind].length == 2 ){
                // xi1 - xi0
                state.factors[ind] =
                    addmod(state.unique_eval_points[ind][1], modulus - state.unique_eval_points[ind][0], modulus);
                state.denominators[ind][2] = 1;

                state.denominators[ind][1] =
                    modulus - addmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus);

                state.denominators[ind][0] =
                    mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus);
                state.denominators[ind][0] = mulmod(state.denominators[ind][0], state.factors[ind], modulus);
                state.denominators[ind][1] = mulmod(state.denominators[ind][1], state.factors[ind], modulus);
                state.denominators[ind][2] = mulmod(state.denominators[ind][2], state.factors[ind], modulus);
            } else
            if( state.unique_eval_points[ind].length == 3 ){
                state.factors[ind] = modulus -
                    mulmod(
                        mulmod(
                            addmod(state.unique_eval_points[ind][0], modulus - state.unique_eval_points[ind][1], modulus),
                            addmod(state.unique_eval_points[ind][1], modulus - state.unique_eval_points[ind][2], modulus),
                            modulus
                        ),
                        addmod(state.unique_eval_points[ind][2], modulus - state.unique_eval_points[ind][0], modulus),
                        modulus
                    );
                state.denominators[ind][3] = 1;
                state.denominators[ind][2] =
                    modulus - addmod(
                        state.unique_eval_points[ind][0],
                        addmod(state.unique_eval_points[ind][1],state.unique_eval_points[ind][2], modulus),
                        modulus
                    );
                state.denominators[ind][1] =
                    addmod(
                        mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][1], modulus),
                        addmod(
                            mulmod(state.unique_eval_points[ind][0], state.unique_eval_points[ind][2], modulus),
                            mulmod(state.unique_eval_points[ind][1], state.unique_eval_points[ind][2], modulus),
                            modulus
                        ),
                        modulus
                    );
                state.denominators[ind][0] =
                    modulus - mulmod(
                        state.unique_eval_points[ind][0],
                        mulmod(state.unique_eval_points[ind][1],state.unique_eval_points[ind][2], modulus),
                        modulus
                    );
                state.denominators[ind][0] = mulmod(state.denominators[ind][0], state.factors[ind], modulus);
                state.denominators[ind][1] = mulmod(state.denominators[ind][1], state.factors[ind], modulus);
                state.denominators[ind][2] = mulmod(state.denominators[ind][2], state.factors[ind], modulus);
                state.denominators[ind][3] = mulmod(state.denominators[ind][3], state.factors[ind], modulus);
            } else {
                console.log("UNPROCESSED number of evaluation points");
                return false;
            }
            ind++;
        }

        // Prepare combined U
        for( uint256 ind = 0; ind < unique_points;){
            uint256[] memory point = state.unique_eval_points[ind];
            state.combined_U[ind] = new uint256[](state.unique_eval_points[ind].length);
            uint64 cur = 0;
            uint256 offset = 0x8;
            for( uint256 k = 0; k < batches_num;){
                for( uint256 i = 0; i < state.batch_sizes[k];){
                    uint256 cur_point = 0;
                    if(cur < points_ids.length ) cur_point = uint8(points_ids[cur]);
                    else if(k == 2) cur_point = permutation_point;
                    else if(k == 3) cur_point = quotient_point;
                    else if(k == 4) cur_point = lookup_point;
                    else console.log("Wrong index");

                    polynomial.multiply_poly_on_coeff(
                        state.combined_U[ind],
                        state.theta,
                        modulus
                    );
                    if( cur_point == ind ){
                        if( point.length == 1 ){
                            state.combined_U[ind][0] = addmod(
                                state.combined_U[ind][0],
                                basic_marshalling.get_uint256_be(blob, offset),
                                modulus
                            );
                        }  else
                        if( point.length == 2 ){
                            uint256[2] memory tmp;
                            tmp[0] = basic_marshalling.get_uint256_be(blob, offset);
                            tmp[1] = basic_marshalling.get_uint256_be(blob, offset + 0x20);
                            tmp = calculate_2points_interpolation(
                                point, tmp);
                            state.combined_U[ind][0] = addmod(state.combined_U[ind][0], tmp[0], modulus);
                            state.combined_U[ind][1] = addmod(state.combined_U[ind][1], tmp[1], modulus);
                        } else
                        if( point.length == 3){
                            uint256[3] memory tmp;
                            tmp[0] = basic_marshalling.get_uint256_be(blob, offset);
                            tmp[1] = basic_marshalling.get_uint256_be(blob, offset + 0x20);
                            tmp[2] = basic_marshalling.get_uint256_be(blob, offset + 0x40);
                            tmp = calculate_3points_interpolation(
                                point, tmp);
                            state.combined_U[ind][0] = addmod(state.combined_U[ind][0], tmp[0], modulus);
                            state.combined_U[ind][1] = addmod(state.combined_U[ind][1], tmp[1], modulus);
                            state.combined_U[ind][2] = addmod(state.combined_U[ind][2], tmp[2], modulus);
                        } else {
                            return false;
                        }
                    }
                    offset += state.unique_eval_points[cur_point].length * 0x20;
                    i++;cur++;
                }
                k++;
            }
            ind++;
        }
}
    }

    function compute_combined_Q(bytes calldata blob,commitment_state memory state) internal view returns(uint256[2] memory y){

unchecked {
        uint256[2][unique_points] memory values;
        {
            uint256 offset = state.initial_data_offset - state.poly_num * 0x40; // Save initial data offset for future use;
            uint256 cur = 0;
            for(uint256 b = 0; b < batches_num;){
                for(uint256 j = 0; j < state.batch_sizes[b];){
                    uint256 cur_point = 0;
                    if(cur < points_ids.length ) cur_point = uint8(points_ids[cur]);
                    else if(b == 2) cur_point = permutation_point;
                    else if(b == 3) cur_point = quotient_point;
                    else if(b == 4) cur_point = lookup_point;
                    else console.log("Wrong index");

                    for(uint256 k = 0; k < unique_points; ){
                        values[k][0] = mulmod(values[k][0], state.theta, modulus);
                        values[k][1] = mulmod(values[k][1], state.theta, modulus);
                        k++;
                    }

                    values[cur_point][0] = addmod(values[cur_point][0], basic_marshalling.get_uint256_be(blob, offset), modulus);
                    values[cur_point][1] = addmod(values[cur_point][1], basic_marshalling.get_uint256_be(blob, offset + 0x20), modulus);
                    offset += 0x40;j++; cur++;
                }
                b++;
            }
        }
        for(uint256 p = 0; p < unique_points; ){
            uint256[2] memory tmp = values[p];
            tmp[0] = mulmod(tmp[0], state.factors[p], modulus);
            tmp[1] = mulmod(tmp[1], state.factors[p], modulus);
            uint256 s = state.x;
            tmp[0] = addmod(tmp[0], modulus - polynomial.evaluate(state.combined_U[p], s , modulus), modulus);
            tmp[1] = addmod(tmp[1], modulus - polynomial.evaluate(state.combined_U[p], modulus - s, modulus), modulus);
            tmp[0] = mulmod(tmp[0], field.inverse_static(polynomial.evaluate(state.denominators[p], s, modulus), modulus), modulus);
            tmp[1] = mulmod(tmp[1], field.inverse_static(polynomial.evaluate(state.denominators[p], modulus - s, modulus), modulus), modulus);
            y[0] = addmod(y[0], tmp[0], modulus);
            y[1] = addmod(y[1], tmp[1], modulus);
            p++;
        }
}
    }

    function initialize(
        bytes32 tr_state_before
    ) internal returns(bytes32 tr_state_after){
        types.transcript_data memory tr_state;
        tr_state.current_challenge = tr_state_before;
        uint256 etha = transcript.get_field_challenge(tr_state, modulus);
        require(etha == _etha, "Wrong etha");
        tr_state_after = tr_state.current_challenge;
    }

    function copy_memory_pair_and_check(bytes calldata blob, uint256 proof_offset, bytes memory leaf, uint256[2] memory pair)
    internal pure returns(bool b){
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly{
            mstore(
                add(leaf, 0x20),
                c
            )
            mstore(
                add(leaf, 0x40),
                d
            )
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40 )){
            return false;
        } else {
            return true;
        }
    }

    function copy_reverted_memory_pair_and_check(bytes calldata blob, uint256 proof_offset, bytes memory leaf, uint256[2] memory pair)
    internal pure returns(bool b){
        uint256 c = pair[0];
        uint256 d = pair[1];
        assembly{
            mstore(
                add(leaf, 0x20),
                d
            )
            mstore(
                add(leaf, 0x40),
                c
            )
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, 0x40 )){
            return false;
        } else {
            return true;
        }
    }

    function copy_pairs_and_check(bytes calldata blob, uint256 offset, bytes memory leaf, uint256 size, uint256 proof_offset)
    internal pure returns(bool b){
unchecked {
        uint256 offset2 = 0x20;
        for(uint256 k = 0; k < size;){
            assembly{
                mstore(
                    add(leaf, offset2),
                    calldataload(add(blob.offset, offset))
                )
                mstore(
                    add(leaf, add(offset2, 0x20)),
                    calldataload(add(blob.offset, add(offset, 0x20)))
                )
            }
            k++; offset2 += 0x40; offset += 0x40;
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20 )){
            return false;
        } else {
            return true;
        }
}
    }

    function copy_reverted_pairs_and_check(bytes calldata blob, uint256 offset, bytes memory leaf, uint256 size, uint256 proof_offset)
    internal pure returns(bool){
unchecked {
        uint256 offset2 = 0x20;
        for(uint256 k = 0; k < size;){
            assembly{
                mstore(
                    add(leaf, offset2),
                    calldataload(add(blob.offset, add(offset, 0x20)))
                )
                mstore(
                    add(leaf, add(offset2, 0x20)),
                    calldataload(add(blob.offset, offset))
                )
            }
            k++; offset2 += 0x40; offset += 0x40;
        }
        if( !merkle_verifier.parse_verify_merkle_proof_bytes_be(blob, proof_offset, leaf, offset2 - 0x20 )){
            return false;
        } else {
            return true;
        }
}
    }

    function colinear_check(uint256 x, uint256[2] memory y, uint256 alpha, uint256 colinear_value) internal pure returns(bool){

unchecked {
        uint256 tmp;
        tmp = addmod(y[0], y[1], modulus);
        tmp = mulmod(tmp, x, modulus);
        tmp = addmod(
            tmp,
            mulmod(
                alpha,
                addmod(y[0], modulus-y[1], modulus),
                modulus
            ),
            modulus
        );
        uint256 tmp1 = mulmod(colinear_value , 2, modulus);
        tmp1 = mulmod(tmp1 , x, modulus);
        if( tmp !=  tmp1 ){
            console.log("Colinear check failed");
            return false;
        }
        return true;
}
    }

    function verify_eval(
        bytes calldata blob,
        uint256[5] memory commitments,
        uint256 challenge,
        bytes32 transcript_state
    ) internal view returns (bool){

unchecked {
        types.transcript_data memory tr_state;
        tr_state.current_challenge = transcript_state;
        commitment_state memory state;

        		{
			uint256 poly_at_eta;
			/* 1 - 2*permutation_size */
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 40);// 0
			if(poly_at_eta != 0x31a27fa2ca7db8f8d0d4bb2297f23e36a80eaa0b196422265ac5d6465bd66501) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x68);// 0x1
			if(poly_at_eta != 0x382c7e2df4749cdc1427a7acf7bb3710e1758743630dbf6cfa559c98cb2ff902) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa8);// 0x2
			if(poly_at_eta != 0x18de76e5c647104c64c64660d6a81353de314060ca10d8b27ef74b47f7efdd06) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe8);// 0x3
			if(poly_at_eta != 0x3c58527cdf63517df7df5fe4314860a334afa8e7e9074260e1a7477ad7af511d) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x128);// 0x4
			if(poly_at_eta != 0x2db99c705cf09775d75cdf74f669e32f7e53e89767f06776038fa1b2366c958d) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x168);// 0x5
			if(poly_at_eta != 0x24a00e31d0b2f54d34d05d48d0116fed10cfc000ebcb19fb464695b4101eebbe) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1a8);// 0x6
			if(poly_at_eta != 0x372046f9137eca820811d26c10572fa10f818e0c885d8fb12d068aaa509a9ab4) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1e8);// 0x7
			if(poly_at_eta != 0x13a162dd6179f48a28591c1c51b3ee24c46d624e849fea077c6bf19f93050580) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x228);// 0x8
			if(poly_at_eta != 0x2226ee52e761c6b2c9bd8c8d9883a6b7b3dc528c8dd29909d4ee8730df191b7f) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x268);// 0x9
			if(poly_at_eta != 0x2ac2a79e84e8e17df0b3bec3fa9241963ec06ac6b2830af9f64e421a5b7d8979) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x2a8);// 0xa
			if(poly_at_eta != 0x15cd4618988c6775b382b9d3e4db47eed2ee4aed60a84b8f03ffb7bcc973af5a) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x2e8);// 0xb
			if(poly_at_eta != 0x2d025e7afabe054c818da123784867a9fc60dda6d9fc80af7ad165c2ef426cc1) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x328);// 0xc
			if(poly_at_eta != 0x210bd866e5b61a7e87c425b1596a06518710894e2607981a9a8f6a07ac4c1fc2) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x368);// 0xd
			if(poly_at_eta != 0x253b3a027c8e8478a6d4bc76bf121f975ec57c8eab8c064dd272b04c5d7c9ec8) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x3a8);// 0xe
			if(poly_at_eta != 0x3a28220c6ec8965b4227ae51bb5a9df4954e3cd147222d4de9e30fa3d36f19e6) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x3e8);// 0xf
			if(poly_at_eta != 0x22c8aa3e29eaefc84ac66798a8c515c6616ccc263e76fe172cba8a7f212b817a) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x428);// 0x10
			if(poly_at_eta != 0x2deb5336d196aee975e005fb4bd96cdfa292cac725b9043cad4a52a1a5d98760) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x468);// 0x11
			if(poly_at_eta != 0x2598a01217f16a8f4d601de87b3f205dc60a2aefa0b629dc96ec0a613d3fa4dd) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x4a8);// 0x12
			if(poly_at_eta != 0x3bfb205a77b714cc82e0958a683ba1d499a5a4b610f4df17c041d20c323e384f) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x4e8);// 0x13
			if(poly_at_eta != 0x2be7a1c4569367fe8e62ebb4092a29267721d39e2f9477085c945688fb371987) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x528);// 0x14
			if(poly_at_eta != 0x1b8628d5b0e107f8c7ee9a842dd2cdbfecd55722d1ff67d7035e1de5e8137fa0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x568);// 0x15
			if(poly_at_eta != 0x7bfd77a40d5b556abde21e99e0b21dfaaa5babd9e65fea8563db3b571c4c53c) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x5a8);// 0x16
			if(poly_at_eta != 0x285a8d414b05c36238da01fb55e2bae610cb63cf7c87bbb00dcd7ef547c2a28a) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x5e8);// 0x17
			if(poly_at_eta != 0x1476971127dd5940b81b49c81171edd5192174fbfdc6be7c079b14d4c399f138) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x628);// 0x18
			if(poly_at_eta != 0x9e88edc1f7c831c0a42a3b79b75f9495c7253aeca536cf20cfa7dbf1135a2e3) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x668);// 0x19
			if(poly_at_eta != 0x176049e1af1bfc4c1f97b8eff8fa42d0b093e6f95459995bb2d9ef2b537b128a) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x6a8);// 0x1a
			if(poly_at_eta != 0x1d579df129d9888f6b5e94de986fe5b42bb7046618fd8ea985e8fc47d327f02b) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x6e8);// 0x1b
			if(poly_at_eta != 0x3c3492bb4ae6ed9f671c1694498a9e88799e6c9b172afa02b2cbf8a9f4f82eda) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x728);// 0x1c
			if(poly_at_eta != 0x38593fab56452a823c6f220d2e1c4ecfa487375c78dcfc4edd8d6be6d7ceee40) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x768);// 0x1d
			if(poly_at_eta != 0x15d9251409e851b5b32bd24228ad7d4db1fab434425a97c2554591084a492006) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x7a8);// 0x1e
			if(poly_at_eta != 0x2ac2a79e84e8e17df0b3bec3fa9241963ec06ac6b2830af9f64e421a5b7d8979) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x7e8);// 0x1f
			if(poly_at_eta != 0x15cd4618988c6775b382b9d3e4db47eed2ee4aed60a84b8f03ffb7bcc973af5a) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x828);// 0x20
			if(poly_at_eta != 0x2d025e7afabe054c818da123784867a9fc60dda6d9fc80af7ad165c2ef426cc1) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x868);// 0x21
			if(poly_at_eta != 0x210bd866e5b61a7e87c425b1596a06518710894e2607981a9a8f6a07ac4c1fc2) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x8a8);// 0x22
			if(poly_at_eta != 0x253b3a027c8e8478a6d4bc76bf121f975ec57c8eab8c064dd272b04c5d7c9ec8) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x8e8);// 0x23
			if(poly_at_eta != 0x3a28220c6ec8965b4227ae51bb5a9df4954e3cd147222d4de9e30fa3d36f19e6) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x928);// 0x24
			if(poly_at_eta != 0xfac8fe55970eb1749a34d9a822e9800e402ce39b0bf9f616f85dae393c1a51d) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x968);// 0x25
			if(poly_at_eta != 0x21d8aa781382ca5261c4a9ad5b95f428bdf371921a913dd722a3e1b65f29cd18) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x9a8);// 0x26
			if(poly_at_eta != 0x134a13990e24233ed04ec2471e59b4903af8c034c74d7d26a1e8089abc426d4e) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x9e8);// 0x27
			if(poly_at_eta != 0x3bfb205a77b714cc82e0958a683ba1d499a5a4b610f4df17c041d20c323e384f) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa28);// 0x28
			if(poly_at_eta != 0x2be7a1c4569367fe8e62ebb4092a29267721d39e2f9477085c945688fb371987) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xa68);// 0x29
			if(poly_at_eta != 0x1b8628d5b0e107f8c7ee9a842dd2cdbfecd55722d1ff67d7035e1de5e8137fa0) return false;
			/* 2 - special selectors */
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xac8);// 0x2a
			if(poly_at_eta != 0x2c29483d790e559c1f073af22ada6d8cfd97d77aa5776fcae41c1f9eb8e492e5) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xb28);// 0x2b
			if(poly_at_eta != 0x27e0dac669cc855a2f2474cc3454f02ea6b75a67d588dc064189b0f90eedf7) return false;
			/* 3 - constant columns */
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xb68);// 0x2c
			if(poly_at_eta != 0x2d83e7c9e053627caae0c9bf9cafb7a3db79f607ced095a2c6fbb99724ec26b8) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xba8);// 0x2d
			if(poly_at_eta != 0x29387fb682258b95bacea870f40774b07bd4661085cbfa211518893fce4e10fd) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xbe8);// 0x2e
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xc28);// 0x2f
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xc68);// 0x30
			if(poly_at_eta != 0x0) return false;
			/* 4 - selector columns */
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xca8);// 0x31
			if(poly_at_eta != 0x1db4b92eafe8893053cdcd10be223db731c296f61e45f53e4e2b979829f06e18) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xce8);// 0x32
			if(poly_at_eta != 0x359cd563eea5efe39f4778c5d88b498553e67892402c90b6887d133795795f05) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xd28);// 0x33
			if(poly_at_eta != 0x382f749b696fe369607299c77f3ea418b925014aa373556695b77630f55268b0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xd68);// 0x34
			if(poly_at_eta != 0x1cdf4f19a23ac701ccfd88eb3656b1f25045468f3d2f3ee0a50b39ef01282a84) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xda8);// 0x35
			if(poly_at_eta != 0x2ce6e9eb7d25e6801de2bb289b74be4b76c7e8c0e3f2727c713963e8f59f1ed0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xde8);// 0x36
			if(poly_at_eta != 0x2b2589548fed3859054173240c70c8b6c68454035a08cc7de236f97c2fccc7f) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe28);// 0x37
			if(poly_at_eta != 0xba7ace18503fdba87875fd7fdb94ba7b438130789e65b6ddbb8caa2649bef2c) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xe68);// 0x38
			if(poly_at_eta != 0x14ebac47c3bf1161769fe3675d8cc6ee7014ef38d0ecc77b3fa5840c0e827cdc) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xea8);// 0x39
			if(poly_at_eta != 0x14ebac47c3bf1161769fe3675d8cc6ee7014ef38d0ecc77b3fa5840c0e827cdc) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xee8);// 0x3a
			if(poly_at_eta != 0xb6250598f4af8c2d994a7d76eae1011b8bc59b2c22a6e40744de3917f2691af) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xf28);// 0x3b
			if(poly_at_eta != 0x2405e4f2ed88fd9241141da63d475cf6f3e56cbefe868c52326d3fa44b6ed079) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xf68);// 0x3c
			if(poly_at_eta != 0x6fff54d1bc8ffe472d9d062c880ee7b36deab5c4fd21cdf38be49bc42fa90bd) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xfa8);// 0x3d
			if(poly_at_eta != 0x12d5b2265b3fa46012dd780f74393b63eda9c9a83c7ed7ce8760ac0282b91aa3) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0xfe8);// 0x3e
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1028);// 0x3f
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1068);// 0x40
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x10a8);// 0x41
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x10e8);// 0x42
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1128);// 0x43
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1168);// 0x44
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x11a8);// 0x45
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x11e8);// 0x46
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1228);// 0x47
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1268);// 0x48
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x12a8);// 0x49
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x12e8);// 0x4a
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1328);// 0x4b
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1368);// 0x4c
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x13a8);// 0x4d
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x13e8);// 0x4e
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1428);// 0x4f
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1468);// 0x50
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x14a8);// 0x51
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x14e8);// 0x52
			if(poly_at_eta != 0x0) return false;
			poly_at_eta = basic_marshalling.get_uint256_be(blob, 0x1528);// 0x53
			if(poly_at_eta != 0x0) return false;
		}


        {
            uint256 offset;

            if (challenge!= transcript.get_field_challenge(tr_state, modulus)) return false;

            for(uint8 i = 0; i < batches_num;){
                transcript.update_transcript_b32(tr_state, bytes32(commitments[i]));
                i++;
            }
            state.theta = transcript.get_field_challenge(tr_state, modulus);

            state.points_num = basic_marshalling.get_length(blob, 0x0);
            offset = 0x8 + state.points_num*0x20 + 0x8;
            for(uint8 i = 0; i < batches_num;){
                state.batch_sizes[i] = uint64(uint8(blob[offset + 0x1]));
                if( state.batch_sizes[i] > state.max_batch ) state.max_batch = state.batch_sizes[i];
                state.poly_num += state.batch_sizes[i];
                i++; offset +=2;
            }

            offset += 0x8;
            offset += state.poly_num;
            state.roots_offset = offset + 0x8;
            offset += 0x8;

            for( uint8 i = 0; i < r;){
                transcript.update_transcript_b32(tr_state, bytes32(basic_marshalling.get_uint256_be(blob, offset + 0x8)));
                state.alphas[i] = transcript.get_field_challenge(tr_state, modulus);
                i++; offset +=40;
            }

            

            offset += 0x8 + r;
            state.initial_data_offset = offset + 0x8;
            offset += 0x8 + 0x20*basic_marshalling.get_length(blob, offset);

            state.round_data_offset = offset + 0x8;
            offset += 0x8 + 0x20*basic_marshalling.get_length(blob, offset);
            offset += 0x8;

            state.initial_proof_offset = offset;
            for(uint8 i = 0; i < lambda;){
                for(uint j = 0; j < batches_num;){
                    if(basic_marshalling.get_uint256_be(blob, offset + 0x10) != commitments[j] ) return false;
                    offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                    j++;
                }
                i++;
            }
            offset += 0x8;
            state.round_proof_offset = offset;

            for(uint256 i = 0; i < lambda;){
                for(uint256 j = 0; j < r;){
                    if(basic_marshalling.get_uint256_be(blob, offset + 0x10) != basic_marshalling.get_uint256_be(blob, state.roots_offset + j * 40 + 0x8) ) return false;
                    offset = merkle_verifier.skip_merkle_proof_be(blob, offset);
                    j++;
                }
                i++;
            }

            state.final_polynomial = new uint256[](basic_marshalling.get_length(blob, offset));
            offset += 0x8;
            for (uint256 i = 0; i < state.final_polynomial.length;) {
                state.final_polynomial[i] = basic_marshalling.get_uint256_be(blob, offset);
                i++; offset+=0x20;
            }
        }
        if( state.final_polynomial.length > (( 1 << (field.log2(max_degree + 1) - r + 1) ) ) ){
            console.log("Wrong final poly degree");
            return false;
        }

        if( !prepare_U_V(blob, state, challenge) ) return false;

        state.leaf_data = new bytes(state.max_batch * 0x40 + 0x40);
        for(uint256 i = 0; i < lambda;){
            // Initial proofs
            state.x_index = uint256(transcript.get_integral_challenge_be(tr_state, 8))  % D0_size;
            state.x = field.pow_small(D0_omega, state.x_index, modulus);
            state.domain_size = D0_size >> 1;
            for(uint256 j = 0; j < batches_num;){
                if( state.x_index < state.domain_size ){
                    if(!copy_pairs_and_check(blob, state.initial_data_offset, state.leaf_data, state.batch_sizes[j], state.initial_proof_offset)){
                        console.log("Error in initial mekle proof");
                        return false;
                    }
                } else {
                    if(!copy_reverted_pairs_and_check(blob, state.initial_data_offset, state.leaf_data, state.batch_sizes[j], state.initial_proof_offset)){
                        console.log("Error in initial mekle proof");
                        return false;
                    }
                }
                state.leaf_length = state.batch_sizes[j] * 0x40;
                state.initial_data_offset += state.batch_sizes[j] * 0x40;
                state.initial_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.initial_proof_offset);
                j++;
            }
            {
                state.y = compute_combined_Q(blob, state);
                if( state.x_index < state.domain_size ){
                    if( !copy_memory_pair_and_check(blob, state.round_proof_offset, state.leaf_data, state.y) ){
                        console.log("Not validated!");
                        return false;
                    }
                }else{
                    if( !copy_reverted_memory_pair_and_check(blob, state.round_proof_offset, state.leaf_data, state.y) ){
                        console.log("Not validated!");
                        return false;
                    }
                }
            }
            if( !colinear_check(state.x, state.y, state.alphas[0], basic_marshalling.get_uint256_be(blob,state.round_data_offset)) ){
                console.log("Colinear check failed");
                return false;
            }

            state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
            for(state.j = 1; state.j < r;){
                state.x_index %= state.domain_size;
                state.x = mulmod(state.x, state.x, modulus);
                state.domain_size >>= 1;
                if( state.x_index < state.domain_size ){
                    if(!copy_pairs_and_check(blob, state.round_data_offset, state.leaf_data, 1, state.round_proof_offset)) {
                        console.log("Error in round mekle proof");
                        return false;
                    }
                } else {
                    if(!copy_reverted_pairs_and_check(blob, state.round_data_offset, state.leaf_data, 1, state.round_proof_offset)) {
                        console.log("Error in round mekle proof");
                        return false;
                    }
                }
                state.y[0] = basic_marshalling.get_uint256_be(blob, state.round_data_offset);
                state.y[1] = basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20);
                if( !colinear_check(state.x, state.y, state.alphas[state.j], basic_marshalling.get_uint256_be(blob,state.round_data_offset + 0x40)) ){
                    console.log("Round colinear check failed");
                    return false;
                }
                state.j++; state.round_data_offset += 0x40;
                state.round_proof_offset = merkle_verifier.skip_merkle_proof_be(blob, state.round_proof_offset);
            }

            state.x = mulmod(state.x, state.x, modulus);
            if(polynomial.evaluate(state.final_polynomial, state.x, modulus) != basic_marshalling.get_uint256_be(blob, state.round_data_offset)) {
                console.log("Wrong final poly check");
                return false;
            }
            if(polynomial.evaluate(state.final_polynomial, modulus - state.x, modulus) != basic_marshalling.get_uint256_be(blob, state.round_data_offset + 0x20)){
                console.log("Wrong final poly check");
                return false;
            }
            state.round_data_offset += 0x40;

            i++;
        }
        return true;
}
    }
}
    