{
  "address": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
  "abi": [],
  "transactionHash": "0xefad48fbaa233e4bb200223cf54750530ac7a9a5742d2600bc6f850a1533d076",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    "transactionIndex": 0,
    "gasUsed": "72227",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0f80809bea288cfcee4e3d433129d627ecdffa7d16bc1e2eddd961dc2b04d823",
    "transactionHash": "0xefad48fbaa233e4bb200223cf54750530ac7a9a5742d2600bc6f850a1533d076",
    "logs": [],
    "blockNumber": 4,
    "cumulativeGasUsed": "72227",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "302373d55c962bb0d0823a9404549626",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CircuitParams.sol\":\"CircuitParams\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/CircuitParams.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.8.4;\\n\\nlibrary CircuitParams {\\n    uint256 constant modulus = 28948022309329048855892746252171976963363056481941560715954676764349967630337;\\n    uint256 constant r = 2;\\n    uint256 constant max_degree = 7;\\n    uint256 constant lambda = 2;\\n\\n    uint256 constant rows_amount = 8;\\n    uint256 constant omega = 199455130043951077247265858823823987229570523056509026484192158816218200659;\\n\\n    function get_D_omegas()\\n    internal pure returns (uint256[2] memory) {\\n        uint256[2] memory D_omegas = [\\n            uint256(199455130043951077247265858823823987229570523056509026484192158816218200659), \\n            uint256(24760239192664116622385963963284001971067308018068707868888628426778644166363)\\n        ];\\n        return (D_omegas);\\n    }\\n    function get_step_list()\\n    internal pure returns (uint256[2] memory) {\\n        uint256[2] memory step_list = [\\n            uint256(1), \\n            uint256(1)\\n        ];\\n        return step_list;\\n    }\\n\\n    function get_arithmetization_params()\\n    internal pure returns (uint256[4] memory) {\\n        uint256[4] memory arithmetization_params = [\\n            uint256(15), \\n            uint256(5), \\n            uint256(5), \\n            uint256(30)\\n        ];\\n        return (arithmetization_params);\\n    }\\n\\n    function get_init_params()\\n    internal pure returns (uint256[] memory init_params) {\\n        uint256[2] memory d_omegas = get_D_omegas();\\n        uint256[2] memory step_list = get_step_list();\\n        uint256[4] memory arithmetization_params = get_arithmetization_params();\\n\\n        uint256[] memory init_args = new uint256[](\\n            6 // static fields: modulus to omega\\n            + (1 + d_omegas.length) // D_omegas.length + D_omegas\\n            + (1 + step_list.length) // step_list.length + step_list\\n            + (1 + arithmetization_params.length) // arithmetization_params.length + arithmetization_params\\n        );\\n\\n        uint cur_index = 0;\\n\\n        init_args[cur_index++] = modulus;\\n        init_args[cur_index++] = r;\\n        init_args[cur_index++] = max_degree;\\n        init_args[cur_index++] = lambda;\\n        init_args[cur_index++] = rows_amount;\\n        init_args[cur_index++] = omega;\\n\\n        // Append D_omegas and length\\n        init_args[cur_index++] = d_omegas.length;\\n        for (uint idx = 0; idx < d_omegas.length; idx++) {\\n            init_args[cur_index++] = d_omegas[idx];\\n        }\\n\\n        // Append step_list and length\\n        init_args[cur_index++] = step_list.length;\\n        for (uint idx = 0; idx < step_list.length; idx++) {\\n            init_args[cur_index++] = step_list[idx];\\n        }\\n\\n        // Append arithmetization_params and length\\n        init_args[cur_index++] = arithmetization_params.length;\\n        for (uint idx = 0; idx < arithmetization_params.length; idx++) {\\n            init_args[cur_index++] = arithmetization_params[idx];\\n        }\\n\\n        return (init_args);\\n    }\\n\\n    function makeDyn1(int256 value) internal pure returns (int256[] memory) {\\n        int256[] memory rslt = new int256[](1);\\n        rslt[0] = value;\\n        return rslt;\\n    }\\n\\n    function makeDyn3(int256 value1, int256 value2, int256 value3) internal pure returns (int256[] memory) {\\n        int256[] memory rslt = new int256[](3);\\n        rslt[0] = value1;\\n        rslt[1] = value2;\\n        rslt[2] = value3;\\n        return rslt;\\n    }\\n\\n    function get_column_rotations()\\n    internal pure returns (int256[][] memory) {\\n        int256[][] memory column_rotations = new int256[][](55);\\n        uint idx = 0;\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        column_rotations[idx++] = makeDyn1(0);\\n        return column_rotations;\\n    }\\n}\",\"keccak256\":\"0xe24d5eb3e0166b50eae26e81e79ad11617c85ce5cdc699f4350946853208d9c3\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220da64233b328573f1ee3d6ee457f2b2c2b4b869a57b21489527f3aba889b1150764736f6c63430008130033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220da64233b328573f1ee3d6ee457f2b2c2b4b869a57b21489527f3aba889b1150764736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}